<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/blog/2019/12/07/hello-world/</url>
    <content><![CDATA[<!-- category 文章分类 -->
<!-- tag 文章标签 -->

<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM-获取DOM元素、修改属性</title>
    <url>/blog/2020/01/16/DOM-%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E3%80%81%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="·DOM-获取-DOM-元素、修改属性"><a href="#·DOM-获取-DOM-元素、修改属性" class="headerlink" title="·DOM-获取 DOM 元素、修改属性"></a>·DOM-获取 DOM 元素、修改属性</h1><h1 id="一、Web-API-的基本认识"><a href="#一、Web-API-的基本认识" class="headerlink" title="一、Web API 的基本认识"></a>一、Web API 的基本认识</h1><h2 id="1、作用和分类"><a href="#1、作用和分类" class="headerlink" title="1、作用和分类"></a>1、作用和分类</h2><p>​ <strong>作用:</strong> 就是使用 JS 去操作 html 和浏览器</p>
<p>​ <strong>分类：</strong>DOM (文档对象模型)、BOM（浏览器对象模型）</p>
<h2 id="2、什么是-DOM"><a href="#2、什么是-DOM" class="headerlink" title="2、什么是 DOM"></a>2、什么是 DOM</h2><p>​ <strong>DOM</strong>（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 文档交互的 API</p>
<p>​ <strong>白话文：</strong>DOM 是浏览器提供的一套专门用来 <strong>操作**<strong>网页*</strong>*内容</strong> 的功能</p>
<p>​ <strong>DOM 作用:</strong> 开发网页内容特效和实现用户交互</p>
<h2 id="3、DOM-树"><a href="#3、DOM-树" class="headerlink" title="3、DOM 树"></a>3、DOM 树</h2><p><strong>lDOM 树是什么</strong>?</p>
<p>​ a：将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树</p>
<p>​ b：描述网页内容关系的名词</p>
<p>​ c：作用：文档树直观的体现了标签与标签之间的关系</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.ev61ukot49s.webp">

<h2 id="4、DOM-对象"><a href="#4、DOM-对象" class="headerlink" title="4、DOM 对象"></a>4、DOM 对象</h2><p><strong>lDOM 对象：浏览器根据 html 标签生成的 JS 对象</strong></p>
<ol>
<li>所有的标签属性都可以在这个对象上面找到</li>
<li>修改这个对象的属性会自动映射到标签身上</li>
</ol>
<p><strong>lDOM 的核心思想</strong></p>
<ol>
<li>把网页内容当做对象来处理</li>
</ol>
<p><strong>ldocument 对象</strong></p>
<ol>
<li><p>是 DOM 里提供的一个<strong>对象</strong></p>
</li>
<li><p>所以它提供的属性和方法都是<strong>用来访问和操作网页内容的</strong></p>
</li>
<li><p>网页所有内容都在 document 里面</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/2.39cbhcf08220.webp"></li>
</ol>
<h1 id="二、获取-DOM-对象"><a href="#二、获取-DOM-对象" class="headerlink" title="二、获取 DOM 对象"></a>二、获取 DOM 对象</h1><h2 id="1、根据-CSS-选择器来获取-DOM-元素"><a href="#1、根据-CSS-选择器来获取-DOM-元素" class="headerlink" title="1、根据 CSS 选择器来获取 DOM 元素"></a>1、根据 CSS 选择器来获取 DOM 元素</h2><h3 id="1-1-选择匹配的第一个元素"><a href="#1-1-选择匹配的第一个元素" class="headerlink" title="1.1 选择匹配的第一个元素"></a><strong>1.1 选择匹配的第一个元素</strong></h3><p><strong>语法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/3.6vdlcn8lhg00.webp">

<p><strong>参数</strong></p>
<ol>
<li>包含一个或多个有效的 CSS 选择器 <strong>字符串</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>CSS 选择器匹配的第一个元素,一个 HTMLElement 对象。</li>
<li>如果没有匹配到，则返回 null。</li>
</ol>
<h3 id="1-2-选择匹配的多个元素"><a href="#1-2-选择匹配的多个元素" class="headerlink" title="1.2 选择匹配的多个元素"></a><strong>1.2 选择匹配的多个元素</strong></h3><p><strong>语法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/4.1585wrbzbtts.webp">

<p><strong>参数</strong></p>
<ol>
<li>包含一个或多个有效的 CSS 选择器 <strong>字符串</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>CSS 选择器匹配的 NodeList 对象集合</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>该方法得到的是一个<strong>伪数组</strong>：</li>
<li>有长度有索引号的数组</li>
<li>但是没有 pop() push() 等数组方法</li>
<li>想要得到里面的每一个对象，则需要遍历（for）的方式获得。</li>
</ul>
<p><strong>例如：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/3-1.2k59o0n4a2g0.webp">

<h3 id="1-3-其他获取-DOM-元素方法"><a href="#1-3-其他获取-DOM-元素方法" class="headerlink" title="1.3 其他获取 DOM 元素方法"></a>1.3 其他获取 DOM 元素方法</h3><img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/5.5rwr9qe1ass0.webp">

<h1 id="三、设置-x2F-修改-DOM-元素内容"><a href="#三、设置-x2F-修改-DOM-元素内容" class="headerlink" title="三、设置&#x2F;修改 DOM 元素内容"></a>三、设置&#x2F;修改 DOM 元素内容</h1><h2 id="1、设置-x2F-修改-DOM-元素内容"><a href="#1、设置-x2F-修改-DOM-元素内容" class="headerlink" title="1、设置&#x2F;修改 DOM 元素内容"></a>1、设置&#x2F;修改 DOM 元素内容</h2><h3 id="1-1document-write"><a href="#1-1document-write" class="headerlink" title="1.1document.write()"></a>1.1document.write()</h3><ul>
<li>只能将文本内容追加到 </body> 前面的位置</li>
<li>文本中包含的标签会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-1.69swq3hv2qc0.webp">

<h3 id="1-2-元素-innerText-属性"><a href="#1-2-元素-innerText-属性" class="headerlink" title="1.2 元素 innerText 属性"></a>1.2 元素 innerText 属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>文本中包含的标签不会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-2.5wxmw3vy4fw0.webp">

<h3 id="1-3-元素-innerHTML-属性"><a href="#1-3-元素-innerHTML-属性" class="headerlink" title="1.3 元素 innerHTML 属性"></a>1.3 元素 innerHTML 属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>文本中包含的标签会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-3.4y46t382rhc0.webp">

<h1 id="四、设置-x2F-修改-DOM-元素属性"><a href="#四、设置-x2F-修改-DOM-元素属性" class="headerlink" title="四、设置&#x2F;修改 DOM 元素属性"></a>四、设置&#x2F;修改 DOM 元素属性</h1><h3 id="1-设置-x2F-修改元素常用属性"><a href="#1-设置-x2F-修改元素常用属性" class="headerlink" title="1. 设置&#x2F;修改元素常用属性"></a><strong>1.</strong> <strong>设置&#x2F;修改元素常用属性</strong></h3><ul>
<li>还可以通过 JS 设置&#x2F;修改标签元素属性，比如通过 src 更换 图片</li>
<li>最常见的属性比如： href、title、src 等</li>
</ul>
<pre><code class="js">语法：
对象.属性 = 值
</code></pre>
<h3 id="2-设置-x2F-修改元素样式属性"><a href="#2-设置-x2F-修改元素样式属性" class="headerlink" title="2.设置&#x2F;修改元素样式属性"></a>2.设置&#x2F;修改元素<strong>样式</strong>属性</h3><p><strong>方法：</strong></p>
<ul>
<li>通过 style 属性操作 CSS</li>
<li>操作类名(className) 操作 CSS</li>
<li>通过 classList 操作类控制 CSS</li>
</ul>
<h3 id="3-通过-设置-style-属性操作-CSS"><a href="#3-通过-设置-style-属性操作-CSS" class="headerlink" title="3.通过 设置 style 属性操作 CSS"></a>3.通过 设置 style 属性操作 CSS</h3><pre><code class="js">语法：
对象.style.样式属性 = 值
</code></pre>
<h3 id="4-操作类名-className-操作-CSS"><a href="#4-操作类名-className-操作-CSS" class="headerlink" title="4.操作类名(className) 操作 CSS"></a>4.操作类名(className) 操作 CSS</h3><p>说明：如果修改的样式比较多，直接通过 style 属性修改比较繁琐，我们可以通过借助于 css 类名的形式。</p>
<pre><code class="js">语法：
元素.className = &#39;active&#39;   // active是一个类名
</code></pre>
<p><strong>注意：</strong></p>
<p>1.由于 class 是关键字, 所以使用 className 去代替</p>
<p>2.className 是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名</p>
<h3 id="5-通过-classList-操作类控制-CSS"><a href="#5-通过-classList-操作类控制-CSS" class="headerlink" title="5.通过( classList) 操作类控制 CSS"></a>5.通过( classList) 操作类控制 CSS</h3><p>说明：为了解决 className 容易覆盖以前的类名，我们可以通过 classList 方式追加和删除类名</p>
<pre><code class="js">语法：
//  追加一个类
元素.classList.add(&#39;类名&#39;)
//  删除一个类
元素.classList.remove(&#39;类名&#39;)
//  切换一个类
元素.classList.toggle(&#39;类名&#39;)
</code></pre>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>className</tag>
        <tag>classList</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环语法|数组|对象</title>
    <url>/blog/2019/12/23/for-%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h1><h3 id="语法结构："><a href="#语法结构：" class="headerlink" title="语法结构："></a>语法结构：</h3><pre><code class="tex">for（循环条件初始化；循环条件判断；循环迭代）&#123;
  循环体；
&#125;
</code></pre>
<h3 id="执行规则："><a href="#执行规则：" class="headerlink" title="执行规则："></a>执行规则：</h3><pre><code class="tex">第一步：循环条件的初始化（只在最开始执行一次）
第二步：循环条件判断
1》若判断条件结果为真：则执行循环体；
2》若不成立：结束循环；
第三步：循环迭代
第四步：回到第二步
</code></pre>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><h4 id="1、打印-5-行-5-列的星星"><a href="#1、打印-5-行-5-列的星星" class="headerlink" title="1、打印 5 行 5 列的星星"></a>1、打印 5 行 5 列的星星</h4><pre><code class="js">//  打印5行5列的星星

let star = &#39;&#39;
for (var i = 0; i &lt; 5; i++) &#123;
  for (var j = 0; j &lt; 5; j++) &#123;
    star += &#39;*&#39;
  &#125;
  star += &#39;\n&#39;
&#125;
console.log(star)
</code></pre>
<h4 id="2、打印三角形星星"><a href="#2、打印三角形星星" class="headerlink" title="2、打印三角形星星"></a>2、打印三角形星星</h4><pre><code class="js">//  打印三角形星星

let num = Number(prompt(&#39;请输入行数：&#39;))
// 正五角
// for (let i = 1; i &lt;= num; i++) &#123;
//     for (let j = 1; j &lt;= i; j++) &#123;
//         document.write(&#39;⭐&#39;)
//     &#125;
//     document.write(&#39;&lt;br&gt;&#39;)
// &#125;

// 倒五角
for (let i = 1; i &lt;= num; i++) &#123;
  for (let j = i; j &lt;= num; j++) &#123;
    document.write(&#39;⭐&#39;)
  &#125;
  document.write(&#39;&lt;br&gt;&#39;)
&#125;
</code></pre>
<h4 id="3、乘法表"><a href="#3、乘法表" class="headerlink" title="3、乘法表"></a>3、乘法表</h4><pre><code class="js">//  乘法表

let num = Number(prompt(&#39;请输入一个数字：&#39;))
// for (let i = 1; i &lt;= num; i++) &#123;
//     for (let j = 1; j &lt;= i; j++) &#123;
//         document.write(`$&#123;j&#125; x $&#123;i&#125; = $&#123;i * j&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`);
//     &#125;
//     document.write(&#39;&lt;br&gt;&lt;br&gt;&#39;)
// &#125;

for (let i = 1; i &lt;= num; i++) &#123;
  for (let j = i; j &lt;= 9; j++) &#123;
    document.write(`&lt;span&gt;$&#123;i&#125; x $&#123;j&#125; = $&#123;i * j&#125;&lt;/span&gt;`)
  &#125;
  document.write(&#39;&lt;br&gt;&lt;br&gt;&#39;)
&#125;
</code></pre>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1.数组的创建"></a>1.数组的创建</h2><p>1） 字面量创建</p>
<pre><code class="js">let arr = [1, true, &#39;zhaimin&#39;, [1, 2]]

let Arr2 = [, ,] //undefined,undefined
</code></pre>
<p>2）利用 array 构造器创建数组</p>
<pre><code class="js">let arr = new Array()
</code></pre>
<h2 id="2-遍历数组"><a href="#2-遍历数组" class="headerlink" title="2.遍历数组"></a>2.遍历数组</h2><pre><code class="js">let arr = [1, 2, 3, 4, 5, 6]
for (var i = 0; i &lt; arr.length; i++) &#123;
  console.log(arr[i])
&#125;

// 1 2 3 4 5 6
</code></pre>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h2><p>1）字面量创建</p>
<pre><code class="js">let obj = &#123;
  name: &#39;我是一个对象&#39;,
  age: 21
&#125;
</code></pre>
<p>2）使用 Object 构造器创建对象</p>
<pre><code class="js">let obj = new Object()
</code></pre>
<p>3）使用构造函数创建对象</p>
<pre><code class="js">function Obj(name,age)&#123;
    this.name = name
    this.age = age
&#125;

// 创建构造函数
const fn = new Obj(&#39;小红&#39;,21)
console.log(fn);  &#123; name:&#39;小红&#39;,age:21 &#125;
</code></pre>
<h2 id="2-使用-for…in-遍历对象"><a href="#2-使用-for…in-遍历对象" class="headerlink" title="2.使用 for…in 遍历对象"></a>2.使用 for…in 遍历对象</h2><pre><code class="js">let obj = &#123; a: 1, b: 2 &#125;
for (let i in obj) &#123;
  console(&#39;key:&#39; + i + &#39;, value:&#39; + obj[i])
&#125;
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>for</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM-事件基础</title>
    <url>/blog/2020/01/06/DOM-%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="DOM-事件基础"><a href="#DOM-事件基础" class="headerlink" title="DOM-事件基础"></a>DOM-事件基础</h1><h2 id="一、事件"><a href="#一、事件" class="headerlink" title="一、事件"></a>一、事件</h2><p><strong>什么是事件？</strong></p>
<ul>
<li>事件是在编程时系统内发生的<strong>动作</strong>或者发生的事情</li>
<li>比如用户在网页上<strong>单击</strong>一个按钮</li>
</ul>
<p><strong>什么是事件监听？</strong></p>
<ul>
<li>​ 就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code class="js">//  之前的语法
// 注意：该方法对同一个dom元素使用时，只能绑定一个事件，若绑定多个则后者覆盖前者
元素.onclick = function()&#123;逻辑代码&#125;

//  es6语法
// 注意：该方法可以给同一个dom元素绑定多个事件，之间互不影响
元素.addEventListener(&#39;事件&#39;，要执行的函数)
</code></pre>
<p><strong>事件监听三要素：</strong></p>
<ul>
<li><strong>事件源：</strong> 那个 dom 元素被事件触发了，要获取 dom 元素</li>
<li><strong>事件：</strong> 用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等</li>
<li><strong>事件调用的函数</strong>： 要做什么事</li>
</ul>
<p><strong>举例说明：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/11.2qxr6165m0e0.webp">

<p><strong>注意：</strong></p>
<p>1.事件类型要加引号</p>
<p>2.函数是点击之后再去执行，每次点击都会执行一次</p>
<h2 id="二、高阶函数"><a href="#二、高阶函数" class="headerlink" title="二、高阶函数"></a>二、高阶函数</h2><p>说明：可以被简单理解为函数的高级应用，JavaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用。</p>
<h3 id="1-函数表达式"><a href="#1-函数表达式" class="headerlink" title="1.函数表达式"></a>1.函数表达式</h3><p>函数表达式和普通函数并无本质上的区别：</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648398044(1).41nbmi30vqq0.webp">

<p><strong>注意 ：</strong></p>
<ul>
<li>普通函数的声明与调用无顺序限制，推荐做法先声明再调用</li>
<li><strong>函数表达式必须要先声明再调用</strong></li>
</ul>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>把函数当做另外一个函数的参数传递，这个函数就叫回调函数</p>
<p>回调函数本质还是函数，只不过把它当成参数使用</p>
<p>使用匿名函数做为回调函数比较常见</p>
<p>例如：</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/xx.50hr5m42gyo0.webp">

<h2 id="三、编程思想"><a href="#三、编程思想" class="headerlink" title="三、编程思想"></a>三、编程思想</h2><p><strong>说明：</strong>当前元素为 A 状态,其他元素为 B 状态</p>
<p><strong>使用：</strong></p>
<ol>
<li><p>干掉所有人</p>
<pre><code>使用for循环
</code></pre>
</li>
<li><p>复活他自己</p>
<pre><code>通过this或者下标找到自己或者对应的元素
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的变量和数据类型</title>
    <url>/blog/2019/12/08/js%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JavaScript-的变量和数据类型"><a href="#JavaScript-的变量和数据类型" class="headerlink" title="JavaScript 的变量和数据类型"></a>JavaScript 的变量和数据类型</h1><h2 id="1-变量的含义和存储"><a href="#1-变量的含义和存储" class="headerlink" title="1.变量的含义和存储"></a>1.变量的含义和存储</h2><p>变量就是用来存放数据的容器，可以通过变量名获取数据，也可以修改数据；</p>
<p>在内存中存储的本质：变量是程序在内存中申请的一块用来存放数据的空间；</p>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><p>变量的声明：使用 var 或者 let (ES6 语法) 进行声明<br>var 声明的变量会进行变量提升（可以先使用，后定义）<br>let 声明的变量不会变量提升（先定义，后使用）</p>
<p>变量的命名规范：</p>
<p>1.由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成， 2.严格区分大小写。 3.不能 以数字开头。 4.不能 是关键字。 5.变量名必须有意义。 6.遵守驼峰命名法。首字母小写，后面单词的首字母需要大写</p>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h3 id="3-1-数据类型的种类"><a href="#3-1-数据类型的种类" class="headerlink" title="3.1 数据类型的种类"></a>3.1 数据类型的种类</h3><h4 id="1-简单的数据类型："><a href="#1-简单的数据类型：" class="headerlink" title="1.简单的数据类型："></a>1.简单的数据类型：</h4><p>Number: 数字型，包含整型和浮点型；</p>
<p>String：字符串类型（用引号引起来）；</p>
<p>Boolean：布尔值类型（true 和 false）；</p>
<p>Undefined ：声明一个变量但是未赋值，就是 undefined；</p>
<p>Null：空值；</p>
<h4 id="2-复杂的数据类型：Object"><a href="#2-复杂的数据类型：Object" class="headerlink" title="2.复杂的数据类型：Object"></a>2.复杂的数据类型：Object</h4><pre><code class="js">typeof Object //&quot;function&quot;
typeof typeof Object //string类型
</code></pre>
<p><strong>01.数字型进制：</strong>二进制、八进制、十进制、十六进制</p>
<p>02.数字型的范围：</p>
<p>最大值：(Number.MAX_VALUE)&#x3D;1.7976931348623157e+308；</p>
<p>最小值：（Number.MIN_VALUE)&#x3D;5e-324;</p>
<p>03.三个特殊值：</p>
<p>infinity:无穷大，大于任何值；</p>
<p>-infinity:无穷小，小于任何值；</p>
<p>NaN:Not a number 非数值；</p>
<p>04.判断一个变量是否为非数字类型返回 true 或 false：</p>
<p>isNaN(a):a 是数字返回 false；a 不是数字返回 true</p>
<pre><code class="js">//数字
console.log(3.14) //3.14
//八进制 0-7 数字前边加0表示8进制
console.log(015) //13
//十六进制 0-9 a-f 数字前边加0x 表示十六进制
console.log(0xa) //10
console.log(0x2a) //42
//数字型的最大值和最小值
console.log(Number.MAX_VALUE) //1.7976931348623157e+308
console.log(Number.MIN_VALUE) //5e-324
//无穷大和无穷小 最大值乘以大于1的数就是无穷大，前边加一个负号就是负无穷
console.log(Number.MAX_VALUE * 1.1) // infinity 无穷大
console.log(-Number.MIN_VALUE * 1.1) // -infinity 无穷小
//NaN 非数字
console.log(0 / 0) //NaN
console.log(10 - &#39;a&#39;) //NaN
</code></pre>
<h3 id="3-3-字符串型-String"><a href="#3-3-字符串型-String" class="headerlink" title="3.3 字符串型 String"></a>3.3 字符串型 String</h3><pre><code class="js">typeof string //&quot;undefined&quot;
typeof typeof string //string类型
typeof (10 + &#39;5&#39;) //string
</code></pre>
<p>字符串是引号中的任意文本，用双引号或者单引号；</p>
<p><strong>引号的嵌套</strong>(外双内单，外单内双)：1.单引号嵌套双引号；2.双引号嵌套单引号；</p>
<pre><code class="js">\n :换行符；
\\ :单斜杠\;
\&#39; :&#39;单引号;
\&quot; :” 双引号;
\t :tab缩进；
\b ：空格
</code></pre>
<p><strong>字符串拼接</strong>：</p>
<p>多个字符串之间使用 z：字符串 + 任何类型 &#x3D; 新的字符串；</p>
<p>拼接前会把与字符串相加的任何类型转换成字符串，在拼接一个新的字符串</p>
<pre><code class="js">//Boolean
typeof Boolean //&quot;function&quot;
typeof typeof Boolean //string类型
typeof true //Boolean
typeof false //Boolean
</code></pre>
<h3 id="3-5undefined-和-null"><a href="#3-5undefined-和-null" class="headerlink" title="3.5undefined 和 null"></a>3.5undefined 和 null</h3><pre><code class="js">//null
typeof null //&quot;object&quot;
typeof typeof null //string类型
//undefined
typeof undefined //&quot;undefined&quot;
typeof typeof undefined //string类型
</code></pre>
<p>特殊情况：<br>undefined &gt; 0 false;<br>undefined &lt; 0 false;<br>undefined &#x3D;&#x3D; 0 false;<br>undefined&#x3D;&#x3D;null true;</p>
<p>（1）一个声明后没有被赋值的变量会有一个默认值 undefined;</p>
<p>（2) 调用函数时，应该提供的参数没有提供，为 undefined;</p>
<p>（3）函数没有返回值时，默认返回 undefined;</p>
<p>（4）对象没有赋值的属性，该属性的值为 undefined;</p>
<p>(5)一个声明变量给 null 值，里面存的值为空;</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串引号|do while|while</title>
    <url>/blog/2019/12/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%95%E5%8F%B7-for%E5%90%8C%E7%B1%BB-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="一、字符串引号"><a href="#一、字符串引号" class="headerlink" title="一、字符串引号"></a>一、字符串引号</h1><h2 id="1、类别"><a href="#1、类别" class="headerlink" title="1、类别"></a>1、类别</h2><p>字符串的字面量表达方式——用引号包起来：</p>
<pre><code class="js">单引号（ ‘’）
双引号（ “”）
反引号 ( `` )
</code></pre>
<p>注意事项：</p>
<pre><code class="js">1、无论单引号或是双引号必须成对使用
2、单引号或双引号可以互相嵌套，但是不以自已嵌套自已（口诀：外双内单，或者外单内双）
3、也可以使用转义符 \ 来输出单引号或双引号
</code></pre>
<h1 id="二、for-同类"><a href="#二、for-同类" class="headerlink" title="二、for 同类"></a>二、for 同类</h1><h2 id="1、while-循环"><a href="#1、while-循环" class="headerlink" title="1、while 循环"></a>1、while 循环</h2><p>说明：循环重复执行一段代码，直到某个条件不再满足。<br>结构：</p>
<pre><code class="js">while（条件表达式）&#123;
  只要条件表达式结果为true,循环一直执行，当条件表达式结果为false的时候，循环终止
&#125;
</code></pre>
<p>注意：条件表达式即为判断表达式</p>
<h3 id="案例一-将-1-10-打印到控制台"><a href="#案例一-将-1-10-打印到控制台" class="headerlink" title="案例一 将 1-10 打印到控制台"></a>案例一 <strong>将 1-10 打印到控制台</strong></h3><pre><code class="js">let n1=1;
while(n1&gt;=1 &amp;&amp; n1&lt;=10)&#123;    // n1满足条件
    console.log(n1);       // 若没有n1++，控制台会一直循环1这个数字
    n1++;
// 当代码执行到console.log(n1)；时为1，继续执行到n1++；此时结果为2。然后继续循环这执行 console.log(n1)； // console.log(n1);此时结果为2+1=3，会一直循环执行这两行代码，直到条件不满足条件式 (n1&gt;=1 &amp;&amp; n1&lt;=10)时终止。
</code></pre>
<h3 id="案例二-求-1-到-100-之间的数字和-在控制台输出"><a href="#案例二-求-1-到-100-之间的数字和-在控制台输出" class="headerlink" title="案例二 求 1 到 100 之间的数字和,在控制台输出"></a>案例二 求 1 到 100 之间的数字和,在控制台输出</h3><pre><code class="js">let n1 = 1
let sum = 0
while (n1 &gt;= 1 &amp;&amp; n1 &lt;= 100) &#123;
  sum = sum + n1
  n1++
&#125;
console.log(sum)
</code></pre>
<h3 id="案例二-将-1-100-之间-3-的倍数找出来，在控制台输出"><a href="#案例二-将-1-100-之间-3-的倍数找出来，在控制台输出" class="headerlink" title="案例二 将 1-100 之间 3 的倍数找出来，在控制台输出"></a>案例二 将 1-100 之间 3 的倍数找出来，在控制台输出</h3><pre><code class="js">let n1=1;
while(n1&gt;=1 &amp;&amp; n1&lt;=100)&#123;
    if(n1%3==0)&#123;
        console.log(n1);     当n1=1时不满足条件式if(n1%3==0)，所以不在控制台输出，但是满足主条件式(n1&gt;=1 &amp;&amp; n1&lt;=100)，所以继续执行下面代码n1++;由此循环。
    &#125;else&#123;
    &#125;
    n1++;
&#125;
</code></pre>
<h2 id="2、do-while-循环"><a href="#2、do-while-循环" class="headerlink" title="2、do while 循环"></a>2、do while 循环</h2><p>结构：</p>
<pre><code class="js">do&#123;
    循环体代码，首先这行该循环体代码一次，如果while后面的表达式结果为true,该循环体会一直循环，如果结果为false,该循环体终止。
&#125;while(条件表达式）
</code></pre>
<p>注意：do while 比 while 多循环一次</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="js">let n1 = 1
let n2 = 5
do &#123;
  alert(&#39;n1&gt;n2&#39;) // 循环一次显示的结果
&#125; while (n1 &gt; n2) // while表达式为false,循环终止。
</code></pre>
<h1 id="三、术语解释"><a href="#三、术语解释" class="headerlink" title="三、术语解释"></a>三、术语解释</h1><pre><code class="js">(关键字)
    说明
        在javascript中有特殊意义的词汇
    举例
        let   var   function    if   else    switch    case    break........
(保留字)
    说明
        在目前的javascript中没意义，但未来可能具有特殊意义的词汇
    举例
        int   short   long   char
标识（标识符）
    说明
        变量名、函数名的另一种叫法
(表达式)
    说明
        能产生值的代码，一般配合运算符出现
    举例
        10+3  、  age&gt;=18.....
(语句)
    说明
        一句代码也称为一条语句，一般按用途还会分类：输出语句、声明语句、分支语句
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>while</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/blog/2019/12/15/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>运算符：算术运算符，赋值运算符，比较运算符，逻辑运算符，三目运算符</li>
<li>表达式：算术表示式，赋值表达式，判断表达式，逻辑表达式</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><pre><code class="js">+  -   *   /  %取余      自增++    自减--
</code></pre>
<ul>
<li><p>数据在进行运算的时候，会尽量转为数字在进行运算（内置帮我们去转的，属于隐式转换）符合 Number 的规律</p>
</li>
<li><p>+ :一旦遇到字符串表示拼接 将另一边数据也转为字符串</p>
</li>
<li><pre><code class="js">console.log(10 + 10)
console.log(10 + &#39;10&#39;) //&quot;10&quot; + &quot;10&quot; =&gt;&quot;1010&quot;
console.log(10 + 20 + &#39;100&#39;) //30 + &quot;100&quot; =&gt; &quot;30&quot; + &quot;100&quot; =&gt; &quot;30100&quot;
console.log(true + 100) // 1 + 100 =&gt;101
console.log(false + null) // 0 + 0 =&gt; 0
console.log(&#39;&#39; + 100) // &quot;&quot; + &quot;100&quot; =&gt; &quot;100&quot;

console.log(10 - &#39;5&#39;) // 10 - 5 = &gt;5
console.log(10 - &#39;5px&#39;) // 10 - NaN =&gt;NaN
console.log(10 - null) // 10 - 0 =&gt; 10
console.log(10 - true) // 10 - 1 =&gt; 9

console.log(10 * null) // 10 * 0 =&gt; 0
console.log(10 * true) // 10 * 1 =&gt; 10

console.log(100 / &#39;&#39;) // 100 / 0 =&gt; Infinity

// % 取余（取模）
console.log(100 % &#39;5&#39;) //0
console.log(100 % &#39;3&#39;) //1
</code></pre>
</li>
<li><p>++ ：不管++在前还是++在后都表示自身加 1，++在前表示先自身加 1，然后再进行运算，++在后表示先进行运算然后再自身加 1</p>
</li>
<li><p>– ：不管–在前还是–在后都表示自身减 1，–在前表示先自身减 1，然后再进行运算，–在后表示先进行运算然后再自身减 1</p>
<pre><code class="js">let a = 5
// a++;
++a
console.log(a) //6
let b = 3
// var c = ++b;
// console.log(c,b); //4 4

// var c = 3;
// console.log(c, b); //3 4
let e = 2 //10
//          2   +  3  +  5 + 5   +  7  -  7  -  9   + 9
console.log(e++ + e++ + ++e + e++ + ++e - e++ - ++e + e++) //15
console.log(e) //10
let f = 3 //5
//          3  +  4  +  6  -  5  - 5  +  4   -  5  -  4  +  4   + 4
console.log(f++ + f++ + ++f - --f - f-- + f++ - f-- - f-- + ++f + f++) //6
console.log(f) //5
// ++ -- 同样存在隐式转换
let test1 = &#39;10&#39;
--test1
console.log(test1) //9
</code></pre>
</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code class="js">let a = 10
console.log(a)

// 在a的基础上增加 5
// 给a重新赋值
// a = 15;
// console.log(a);

// a = a + 5;
a += 5 //相当于 a = a + 5；
console.log(a)

let b = 100
b -= 50 //&lt;=&gt; b = b - 50;
console.log(b)
</code></pre>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id="普通比较"><a href="#普通比较" class="headerlink" title="普通比较"></a>普通比较</h3><pre><code class="js">// 1.数据在进行比较的时候，会尽量转为数字进行比较（内置帮我们去转的，属于隐式转换）符合Number的规律
console.log(10 &gt; 5) //true
console.log(10 &gt; &#39;5&#39;) // 10 &gt; 5 true
console.log(true &gt; false) //1 &gt; 0 =&gt; true
console.log(&#39;100px&#39; &gt; 100) // NaN &gt; 100 =&gt; false
console.log(null &gt; &#39;&#39;) // 0 &gt; 0 =&gt;false
console.log(null &gt;= &#39;&#39;) // 0 &gt; 0 =&gt;true
console.log(10 != &#39;20&#39;) //10 != 20 =&gt; true

// 2.null等于undefined 但是null和undefined与其它数据类型都不相等
//null == 0  =&gt;false
console.log(null == &#39;&#39;) //false
console.log(null == undefined) //true
console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
console.log(undefined == undefined) //true
console.log(undefined == 0) //false
console.log(null == undefined) //true
console.log(4 == &#39;abc&#39;) //false
console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
console.log(null == null) //true
console.log(null !== undefined) //true
console.log(3 !== &#39;3&#39;) //true
console.log(null &gt;= 0)
true
console.log(null &lt;= 0)
true
// 3.字符串比较是按照ASCII（Unicode编码）值进行比较的，并且是按位进行比较的一旦某一位比较出结果，就不再比了
console.log(&#39;158&#39; &gt; &#39;1399999999999931231&#39;) //false
// 0 - 9 :48 - 57
// A - Z: 65 - 90
// a - z: 97 - 122
</code></pre>
<h3 id="绝对比较"><a href="#绝对比较" class="headerlink" title="绝对比较"></a>绝对比较</h3><pre><code class="text">=== 绝对等于   !== 绝对不等于

1.不同数据类型一定不相等
  === 绝对等于 （不仅要值相等，数据类型也要一样）
  !==    10 !== &quot;10&quot;   10 != &quot;10&quot;
</code></pre>
<pre><code class="js">console.log(0 == &#39;&#39;) // true
console.log(0 === &#39;&#39;) // false
console.log(9 === &#39;9&#39;) // false
console.log(null === undefined) // false
console.log(&#39;10&#39; !== 10) //true
</code></pre>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><pre><code class="text">&amp;&amp;与  || 或   ! 非
</code></pre>
<pre><code class="js">// &amp;&amp; 与  || 或
console.log(true &amp;&amp; true) //true
console.log(true &amp;&amp; false &amp;&amp; true) //false
console.log(true || false) //true
// 逻辑运算符会自动检测当前数据类型的真假 符合Boolean的规律
// 根据自身的规律返回对应位置的值
// 短路运算
var res = 66 &amp;&amp; &#39;10&#39; &amp;&amp; &#39;哈哈&#39; &amp;&amp; 100
console.log(res) //100
var res1 = 66 &amp;&amp; null &amp;&amp; &#39;哈哈&#39; &amp;&amp; 100
console.log(res1) //null
var res2 = &#39;aa&#39; || &#39;bb&#39; || &#39;&#39;
console.log(res2) //&quot;aa&quot;
var res3 = &#39;&#39; || null || undefined || NaN
console.log(res3) //NaN
</code></pre>
<h3 id="非：取反"><a href="#非：取反" class="headerlink" title="! 非：取反"></a>! 非：取反</h3><pre><code class="js">// 先将当前数据转为布尔值符合Number的规律，然后再进行取反
console.log(!10) // true - &gt; false
console.log(!20) //true -&gt; false
console.log(!&#39;哈哈&#39;) //true -&gt; false
console.log(!&#39;&#39;) //false -&gt; true
</code></pre>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><img src="https://raw.githubusercontent.com/3-ygd/image-hosting/master/运算符优先级.6svw4j0gciw0.webp">

<h2 id="三目运算符-三元表达式"><a href="#三目运算符-三元表达式" class="headerlink" title="三目运算符(三元表达式)"></a>三目运算符(三元表达式)</h2><pre><code class="txt">条件 ? 条件成立执行的代码段 : 条件不成立执行的代码段; (三目运算符又称之为问号冒号表达式，一般应用于简单的判断相当于if..else)
</code></pre>
<pre><code class="js">// 条件  ? 条件成立执行的代码段 : 条件不成立执行的代码段; (三目运算符又称之为问号冒号表达式，一般应用于简单的判断相当于if..else)
// 条件为真执行的是问号后边的代码段  条件为假执行的是冒号后边的代码段
let score = 50
score &gt;= 60 ? console.log(&#39;中午吃点好的&#39;) : console.log(&#39;中午不吃了~~~&#39;)

// 单个数据会自动检测真假
&#39;&#39; ? console.log(&#39;真的&#39;) : console.log(&#39;假的&#39;)
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM 节点操作</title>
    <url>/blog/2020/01/27/DOM%20%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a>DOM 节点操作</h1><h2 id="一、节点操作"><a href="#一、节点操作" class="headerlink" title="一、节点操作"></a>一、节点操作</h2><h3 id="1-DOM-节点"><a href="#1-DOM-节点" class="headerlink" title="1.DOM 节点"></a>1.DOM 节点</h3><p><strong>概念</strong>：DOM 树里每一个内容都称之为节点</p>
<p>​ <strong>节点类型</strong>：</p>
<p>​ <strong>元素节点</strong> ：所有的标签 比如 body、 div | html 是根节点</p>
<p>​ <strong>属性节点</strong> ：所有的属性 比如 href</p>
<p>​ <strong>文本节点</strong> ：所有的文本</p>
<p>​ <strong>其他</strong></p>
<h3 id="2-查找节点"><a href="#2-查找节点" class="headerlink" title="2.查找节点"></a>2.查找节点</h3><p><strong>父节点查找</strong>：</p>
<p>语法：</p>
<pre><code class="js">子元素.parentNode
</code></pre>
<p>注意：该方式会返回最近一级的父节点 找不到返回为 null</p>
<p><strong>子节点查找：</strong></p>
<p>语法：</p>
<pre><code class="js">父元素.children
</code></pre>
<p>注意：该方式可以获得所有元素节点，并且返回的还是一个伪数组</p>
<p><strong>兄弟关系查找</strong></p>
<p>语法：</p>
<pre><code class="js">// 下一个兄弟元素节点
dom元素.nextElementSibling

// 获取上一个兄弟元素节点
dom元素.previousElementSibling
</code></pre>
<h3 id="3-增加节点"><a href="#3-增加节点" class="headerlink" title="3.增加节点"></a>3.增加节点</h3><p><strong>创建节点</strong></p>
<p>语法：</p>
<pre><code class="js">document.createElement(&#39;标签名&#39;)
</code></pre>
<p>说明：即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点</p>
<p><strong>追加节点</strong></p>
<p>语法：</p>
<pre><code class="js">// 插入到父元素的最后一个子元素
父元素.appendChild(要插入的元素)

// 插入到父元素中某个子元素的前面
父元素.insertBefore(要插入的元素，在那个元素前面)
</code></pre>
<p><strong>克隆节点</strong></p>
<p>语法：</p>
<pre><code class="js">// 克隆一个已有的元素节点
dom元素.cloneNode(布尔值)
</code></pre>
<p>说明：该方法会克隆出一个跟原标签一样的元素，括号内传入布尔值</p>
<p>​ 若为 true，则代表克隆时会包含后代节点一起克隆</p>
<p>​ 若为 false, 则代表克隆时不好含后代节点</p>
<p>​ 默认为 false</p>
<h3 id="4-删除节点"><a href="#4-删除节点" class="headerlink" title="4.删除节点"></a>4.删除节点</h3><p>语法：</p>
<pre><code class="js">父元素.removeChild(要删除的元素)
</code></pre>
<p>注意：</p>
<p>​ 如不存在父子关系则删除不成功</p>
<p>​ 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从 html 中删除节点</p>
<h2 id="二、时间对象"><a href="#二、时间对象" class="headerlink" title="二、时间对象"></a>二、时间对象</h2><h3 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1.实例化"></a>1.实例化</h3><p>说明：</p>
<p>​ 在代码中发现了 new 关键字时，一般将这个操作称为<strong>实例化</strong></p>
<p>​ 创建一个时间对象并获取时间</p>
<p>语法：</p>
<pre><code class="js">// 获取当前的时间
let date = new Date()

// 获取指定时间
let date = new Date(&#39;1966-10-01&#39;)
</code></pre>
<h3 id="2-时间对象方法"><a href="#2-时间对象方法" class="headerlink" title="2.时间对象方法"></a>2.时间对象方法</h3><p>说明： 因为时间对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式</p>
<p><strong>以下为常用的一些方法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648481367(1).vkvql1yec2o.webp">

<h3 id="3-时间戳"><a href="#3-时间戳" class="headerlink" title="3.时间戳"></a>3.时间戳</h3><p>概念：是指 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的毫秒数，它是一种特殊的计量时间的方式</p>
<p><strong>使用 getTime() 方法</strong> 获取</p>
<pre><code class="js">// 实例化时间对象
let date = new Date()
// 获取时间戳
console.log(date.getTime())
</code></pre>
<p><strong>简写 + new Date()</strong> 获取</p>
<pre><code class="js">// 获取时间戳
console.log(+new Date())
</code></pre>
<p><strong>使用 Date.now()</strong> 获取</p>
<pre><code class="js">// 获取时间戳
console.log(Date.now())

// 注意：
// 该方法无需实例化
// 该方法只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳
</code></pre>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>节点操作</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM- 操作浏览器</title>
    <url>/blog/2020/02/26/BOM-%20%E6%93%8D%E4%BD%9C%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="BOM-操作浏览器"><a href="#BOM-操作浏览器" class="headerlink" title="BOM- 操作浏览器"></a>BOM- 操作浏览器</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><h3 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM(浏览器对象模型)"></a>BOM(浏览器对象模型)</h3><p>BOM(Browser Object Model ) 是浏览器对象模型</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.2m9rwhel15q0.webp">

<p>window 是浏览器内置中的全局对象，我们所学习的所有 Web APIs 的知识内容都是基于 window 对象实现的</p>
<p>window 对象下包含了 navigator、location、document、history、screen 5 个属性，即所谓的 BOM （浏览器对象模型）</p>
<p>document 是实现 DOM 的基础，它其实是依附于 window 的属性。</p>
<p>注：依附于 window 对象的所有属性和方法，使用时可以省略 window</p>
<h3 id="定时器-延时函数"><a href="#定时器-延时函数" class="headerlink" title="定时器-延时函数"></a>定时器-延时函数</h3><p>JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout</p>
<pre><code class="js">// 语法：
setTimeout(回调函数，等待的毫秒数)
</code></pre>
<p>setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略 window</p>
<p><strong>清除延时函数</strong>：</p>
<pre><code class="js">// 语法：
let timer = setTimeout(回调函数，等待的毫秒数)
clearTimeout(timer) // 清除操作
</code></pre>
<p><strong>结合递归函数可以使用 setTimeout 实现 setInterval 一样的功能</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484053(1).11f3ojnjbrgw.webp">

<p><strong>两种定时器对比：</strong></p>
<ul>
<li>setInterval 的特征是重复执行，首次执行会延时</li>
<li>setTimeout 的特征是延时执行，只执行 1 次</li>
<li>setTimeout 结合递归函数，能模拟 setInterval 重复执行</li>
<li>clearTimeout 清除由 setTimeout 创建的定时任务</li>
</ul>
<h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分</p>
<p><strong>常用属性和方法：</strong></p>
<ul>
<li>href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484228(1).28dyzfbpmqtc.webp">

<ul>
<li>reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484291(1).1y7oon8x7fts.webp">

<h3 id="histroy-对象"><a href="#histroy-对象" class="headerlink" title="histroy 对象"></a>histroy 对象</h3><p>history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等</p>
<p><strong>常用属性和方法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484385(1).3ybl9j8q6h40.webp">

<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>1、生命周期永久生效，除非手动删除 否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3、以键值对的形式存储使用</p>
<pre><code class="js">// 存储数据
localStorage.setItem(key, value)

// 获取数据
localStorage.getItem(key)

// 删除数据
localStorage.removeItem(key)
</code></pre>
<p><strong>存储复杂</strong> 数据类型存储</p>
<p>本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成 JSON 字符串,在存储到本地</p>
<p><strong>JSON.stringify</strong>(复杂数据类型)</p>
<p>​ 将复杂数据转换成 JSON 字符串 <strong>存储</strong> 本地存储中</p>
<p><strong>JSON.parse</strong>(JSON 字符串)</p>
<p>​ 将 JSON 字符串转换成对象 <strong>取出</strong> 时候使用</p>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>window</tag>
        <tag>setTimeout</tag>
        <tag>histroy对象</tag>
      </tags>
  </entry>
  <entry>
    <title>获取元素大小和位置</title>
    <url>/blog/2020/02/20/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="获取元素大小和位置"><a href="#获取元素大小和位置" class="headerlink" title="获取元素大小和位置"></a>获取元素大小和位置</h1><h2 id="一、scroll-家族"><a href="#一、scroll-家族" class="headerlink" title="一、scroll 家族"></a>一、scroll 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的<strong>内容</strong>总宽高（不包含滚动条）返回值不带单位</li>
<li>scrollWidth 和 scrollHeight</li>
</ul>
<p>获取位置:</p>
<ul>
<li><p>获取元素内容往左、往上滚出去看不到的距离</p>
</li>
<li><p><strong>scrollLeft</strong>和<strong>scrollTop</strong></p>
</li>
<li><p>这两个属性是可以<strong>修改</strong>的</p>
<pre><code class="js">// 例如
div.addEventListener(&#39;scroll&#39;, function () &#123;
  console.log(this.scrollTop)
&#125;)
</code></pre>
</li>
</ul>
<p>注意：开发中，我们经常检测页面滚动的距离，比如页面滚动 100 像素，就可以显示一个元素，或者固定一个元素</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648483445(1).blsri7mcqqw.webp">

<h2 id="二、offset-家族"><a href="#二、offset-家族" class="headerlink" title="二、offset 家族"></a>二、offset 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的自身宽高、包含元素自身设置的宽高、padding、border</li>
<li>offsetWidth 和 offsetHeight</li>
</ul>
<p>获取位置：</p>
<ul>
<li>获取元素距离自己<strong>定位父级</strong>元素的左、上距离</li>
<li><strong>offsetLeft</strong>和<strong>offsetTop</strong> 注意是只读属性</li>
</ul>
<h2 id="三、client-家族"><a href="#三、client-家族" class="headerlink" title="三、client 家族"></a>三、client 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的可见部分宽高（不包含边框，滚动条等）</li>
<li>clientWidth 和 clientHeight</li>
</ul>
<p>获取位置：</p>
<ul>
<li>获取左边框和上边框宽度</li>
<li>clientLeft 和 clientTop 注意是只读属性</li>
</ul>
<p>触发时机：会在窗口尺寸改变的时候触发事件 | 检测屏幕宽度</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.offset 家族</p>
<ul>
<li><p>获取元素自身大小：包括自身设置的宽高、padding、border</p>
</li>
<li><p>获取元素距离定位父级的左和上距离 只读属性</p>
<p>2.client 家族</p>
</li>
<li><p>获取元素可见区域的大小</p>
</li>
<li><p>获取元素左、上边框距离 只读属性</p>
<p>3.scroll 家族</p>
</li>
<li><p>获取元素内容的总大小</p>
</li>
<li><p><strong>获取元素向左向上滚出去看不见的</strong>距离 可读写属性</p>
</li>
</ul>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>scroll</tag>
        <tag>offset</tag>
        <tag>client</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动事件和加载事件</title>
    <url>/blog/2020/02/13/%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="滚动事件和加载事件"><a href="#滚动事件和加载事件" class="headerlink" title="滚动事件和加载事件"></a>滚动事件和加载事件</h1><h2 id="一、滚动事件"><a href="#一、滚动事件" class="headerlink" title="一、滚动事件"></a>一、滚动事件</h2><p>触发时机：当页面进行滚动时触发的事件</p>
<p>为什么要使用？</p>
<p>​ 因为很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部</p>
<p>事件名：scroll</p>
<pre><code class="js">// 语法
window.addEventListener(&#39;scroll&#39;, function () &#123;
  // 执行的操作
&#125;)

// 给 window 或 document 添加 scroll 事件
</code></pre>
<p>监听那个元素的内部滚动直接给某个元素加即可</p>
<h2 id="二、加载事件"><a href="#二、加载事件" class="headerlink" title="二、加载事件"></a>二、加载事件</h2><p>触发时机：加载外部资源（如图片、外联 CSS 和 JavaScript 等）加载完毕时触发的事件</p>
<p>为什么要使用？</p>
<ul>
<li>有些时候需要等页面资源全部处理完了做一些事情</li>
<li>老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到</li>
</ul>
<p>事件名：load</p>
<p>例如：给 window 添加 load 事件</p>
<pre><code class="js">// 语法
// 页面加载事件
window.addEventListener(&#39;load&#39;, function () &#123;
  // 执行的操作
&#125;)

// 给 window 添加 load 事件
</code></pre>
<p>注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定 load 事件</p>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>滚动事件</tag>
        <tag>加载事件</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM- 事件对象、事件流、事件委托</title>
    <url>/blog/2020/02/06/DOM-%20%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%B5%81%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h1 id="DOM-事件对象、事件流、事件委托"><a href="#DOM-事件对象、事件流、事件委托" class="headerlink" title="**DOM- 事件对象、事件流、事件委托"></a>**DOM- 事件对象、事件流、事件委托</h1><h2 id="一、事件对象"><a href="#一、事件对象" class="headerlink" title="一、事件对象"></a>一、事件对象</h2><h3 id="1-获取事件对象"><a href="#1-获取事件对象" class="headerlink" title="1.获取事件对象"></a>1.获取事件对象</h3><p><strong>事件对象是什么：</strong></p>
<ul>
<li>也是个对象，这个对象里有事件触发时的相关信息</li>
<li>例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息</li>
</ul>
<p><strong>如何获取：</strong></p>
<ul>
<li>在事件绑定的回调函数的第一个参数就是事件对象</li>
<li>一般命名为 event、ev、e</li>
</ul>
<pre><code class="js">// 例如
元素.addEventListener(&#39;click&#39;, function (e) &#123;&#125;) //  这里的e就是事件对象参数
</code></pre>
<h3 id="2-事件对象常用属性"><a href="#2-事件对象常用属性" class="headerlink" title="2.事件对象常用属性"></a>2.事件对象常用属性</h3><p><strong>部分常用属性：</strong></p>
<ul>
<li>type：获取当前的事件类型</li>
<li>clientX&#x2F;clientY：获取光标相对于浏览器可见窗口左上角的位置</li>
<li>offsetX&#x2F;offsetY：获取光标相对于当前 DOM 元素左上角的位置</li>
<li>key：用户按下的键盘键的值</li>
</ul>
<p>注意：现在不提倡使用 keyCode</p>
<h3 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h3><h3 id="1-事件流与两个阶段说明"><a href="#1-事件流与两个阶段说明" class="headerlink" title="1.事件流与两个阶段说明"></a>1.事件流与两个阶段说明</h3><p>事件流：指的是事件完整执行过程中的流动路径</p>
<p>简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父</p>
<h3 id="2-事件捕获和事件冒泡"><a href="#2-事件捕获和事件冒泡" class="headerlink" title="2.事件捕获和事件冒泡"></a>2.事件捕获和事件冒泡</h3><p><strong>事件冒泡</strong></p>
<ul>
<li>概念：当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡</li>
<li>简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件</li>
<li>注意：事件冒泡是默认存在的</li>
</ul>
<p><strong>事件捕获</strong></p>
<ul>
<li><p>概念： 从 DOM 的根元素开始去执行对应的事件 (从外到里)</p>
</li>
<li><p>说明：addEventListener 第三个参数传入 true 代表是捕获阶段触发（很少使用）</p>
<p>​ 若传入 false 代表冒泡阶段触发，默认就是 false</p>
<p>​ 若是用 L0 事件监听，则只有冒泡阶段，没有捕获</p>
</li>
</ul>
<p><strong>阻止事件流动的方式</strong></p>
<p>语法：</p>
<pre><code class="js">事件对象.stopPropagation()

// 注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效
</code></pre>
<p><strong>阻止默认行为</strong></p>
<p>使用场景：l 比如链接点击不跳转，表单域的不提交</p>
<p>语法：</p>
<pre><code class="js">e.preveentDefault()
</code></pre>
<p><strong>两种注册事件的区别：</strong></p>
<p>传统 on 注册（L0）</p>
<ul>
<li>同一个对象,后面注册的事件会覆盖前面注册(同一个事件)</li>
<li>直接使用 null 覆盖偶就可以实现事件的解绑</li>
<li>都是冒泡阶段执行的</li>
</ul>
<p>事件监听注册（L2）</p>
<ul>
<li>语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获)</li>
<li>后面注册的事件不会覆盖前面注册的事件(同一个事件)</li>
<li>可以通过第三个参数去确定是在冒泡或者捕获阶段执行</li>
<li>必须使用 removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)</li>
<li>匿名函数无法被解绑</li>
</ul>
<h3 id="3-阻止事件流动"><a href="#3-阻止事件流动" class="headerlink" title="3.阻止事件流动"></a>3.阻止事件流动</h3><h3 id="三、事件委托"><a href="#三、事件委托" class="headerlink" title="三、事件委托"></a>三、事件委托</h3><p><strong>原理：</strong>事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发</p>
<p><strong>使用场景：</strong>当子元素是动态创建并且需要注册事件的时候，推荐使用事件委托</p>
<p><strong>优点：</strong>给父级元素加事件（可以提高性能）</p>
<p><strong>实现：</strong>事件对象.target 可以获得真正触发事件的元素</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648482711(1).2qvzd2cnol40.webp">
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>事件对象</tag>
        <tag>事件流</tag>
        <tag>事件委托</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-类-继承</title>
    <url>/blog/2020/04/10/ES6-%E7%B1%BB-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="ES6-类-继承"><a href="#ES6-类-继承" class="headerlink" title="ES6-类-继承"></a>ES6-类-继承</h1><h2 id="1、类"><a href="#1、类" class="headerlink" title="1、类"></a>1、类</h2><p><strong>概念:</strong> 将对象中公共的方法或者属性封装成一个模板 (es5 中的构造函数)</p>
<p><strong>作用:</strong> 创建对象</p>
<pre><code class="js">// 语法
class 自定义类名 &#123;&#125;
let 实例对象 = new 类名()
</code></pre>
<p><strong>注意事项:</strong></p>
<ul>
<li>通过类创建对象必须使用 new 关键字</li>
<li>类的命名规范与构造函数的命名规范一样(帕斯卡命名法)</li>
<li>创建对象后类名后面必须加()</li>
</ul>
<pre><code class="js">// 设置属性语法
class 自定义类名 &#123;
      constructor(形参,形参) &#123;
         this.属性 = 形参;
         this.属性 = 形参;
     &#125;
&#125;

// 类设置方法
class 类名 &#123;
    constructor() &#123;&#125;
    方法名() &#123;&#125;
&#125;
注意事项:
1. 类中设置方法名,不能添加function关键字
2. 类中方法之间不需要任何的分割符
</code></pre>
<p><strong>constructor 介绍:</strong></p>
<ul>
<li>类中默认的构造函数,用来初始化操作</li>
<li>constructor 构造函数用来接收创建对象时候传递的参数,创建对象并返回</li>
<li>通过 new + 类名创建对象的时候,程序就会自动调用类中 constructor’</li>
<li>如果我们在类中没有定义 constructor 函数,程序在执行的时候也会自动创建的</li>
</ul>
<p><strong>继承(子类继承父类)</strong></p>
<pre><code class="js">// 语法:

class 子类 extends 父类 &#123;&#125;
</code></pre>
<pre><code class="js">// 例如
//父类
class Student &#123;
  ks(ksName) &#123;
    alert(ksName)
  &#125;
&#125;
//子类继承父类
class C_student extends Student &#123;&#125;
class A_student extends Student &#123;&#125;
var zs = new C_student()
var ls = new A_student()
zs.ks(&#39;汉语&#39;)
ls.ks(&#39;英语&#39;)
</code></pre>
<p><strong>super 关键字</strong></p>
<pre><code class="js">作用：子类继承父类时候,如果子类中设置了构造函数,则通过super关键字调用父类中的构造函数

语法:  super(参数)

子类中如果要执行父类中的方法,可以通过super调用父类中的方法
super.方法名()
</code></pre>
<p><strong>call,bind,apply</strong></p>
<p><strong>作用：</strong>修改 this 指向</p>
<pre><code class="js">call作用: 调用函数 + 修改this指向
call语法: 函数.call(对象,参数1,参数2...)

apply作用: 调用函数 + 修改this指向
apply语法:函数.apply(对象,[值,值]);

bind作用: 不调用函数 + 修改this指向
bind语法: 函数.bind(对象,参数1,参数2...)
bind返回值: 返回当前函数
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>继承</tag>
        <tag>class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery-动画-操作元素</title>
    <url>/blog/2020/05/02/JQuery-%E5%8A%A8%E7%94%BB-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="JQuery-动画-操作元素"><a href="#JQuery-动画-操作元素" class="headerlink" title="JQuery-动画-操作元素"></a>JQuery-动画-操作元素</h1><h3 id="1-JQuery-动画"><a href="#1-JQuery-动画" class="headerlink" title="1. JQuery 动画"></a>1. JQuery 动画</h3><h4 id="1-1-显示-隐藏动画"><a href="#1-1-显示-隐藏动画" class="headerlink" title="1.1 显示-隐藏动画"></a>1.1 显示-隐藏动画</h4><ul>
<li><p><code>show()</code></p>
<pre><code class="js">语法:
$(对象).show([speed, [easing], [fn]])
//参数介绍:
1. show() 方法中的3个参数可以不用设置, 显示元素没有动画效果
2. 第一个参数表示动画速度,可以设置 &#39;slow&#39; , &#39;normal&#39;, &#39;fast&#39; 或者表示动画的时长毫秒
3. 第二个参数表示动画切换效果, 默认 &#39;swing[摇动摆动,由快到慢]&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示动画完成后执行的函数(回调函数)

//代码演示1,未设置任何参数,控制元素显示,没有动画效果
var btn = $(&#39;input&#39;);
var div = $(&#39;div&#39;);
btn.click(function()&#123;
    div.show();
&#125;)

//代码演示2,设置第一个参数,元素按照动画显示
var btn = $(&#39;input&#39;);
var div = $(&#39;div&#39;);
btn.click(function()&#123;
    div.show(&#39;fast&#39;);
&#125;)

//代码演示3,设置两个参数,元素实现切换效果
btn.click(function()&#123;
    div.show(&#39;normal&#39;,&#39;swing&#39;);
&#125;)

//代码4演示,设置第三个参数,动画执行完后回调函数
btn.click(function()&#123;
    div.show(&#39;normal&#39;,&#39;swing&#39;, function()&#123;
        alert(&#39;动画完成&#39;);
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><code>hide()</code></p>
<pre><code class="js">语法:
$(对象).hide([speed, [easing], [fn]);
//参数介绍:
1. 参数可以省略,隐藏元素没有动画效果
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行
//代码演示同上
</code></pre>
</li>
<li><p><strong>课堂案例-好友列表案例</strong></p>
</li>
</ul>
<h4 id="1-2-滑动动画"><a href="#1-2-滑动动画" class="headerlink" title="1.2 滑动动画"></a>1.2 滑动动画</h4><ul>
<li><p><code>slideDown()</code></p>
<pre><code class="js">介绍: slideDown()  显示元素(通过改变元素高度)
语法:
// $(对象).slideDown([speed],[easing],[fn]);

参数介绍:
1. 参数可以省略
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行

//代码演示1:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown();
&#125;)

//代码演示2
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown(&#39;fast&#39;);
&#125;)

//代码演示3
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown(&#39;fast&#39;, &#39;linear&#39;);
&#125;)

//代码演示4
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown(&#39;fast&#39;, &#39;linear&#39;, function()&#123;
        alert(&#39;动画完成&#39;)
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><code>slideUp()</code></p>
<pre><code class="js">介绍: 通过高度变化（向上减小）来动态地隐藏所有匹配的元素
语法:
// $(对象).slideUp([speed,[easing],[fn]])

参数介绍:
1. 参数可以省略
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行

//代码演示:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideUp(&#39;fast&#39;, &#39;linear&#39;, function()&#123;
        console.log(&#39;动画完成&#39;)
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><strong>小米课堂案例</strong></p>
<pre><code class="js">//1. 鼠标进入大盒子显示内容区域,鼠标离开隐藏内容区域
$(&#39;.nav&#39;).hover(
  function () &#123;
    $(&#39;.content&#39;).slideDown(&#39;fast&#39;)
    //2.给每一项设置鼠标进入事件
    $(this)
      .find(&#39;a&#39;)
      .mouseenter(function () &#123;
        $(this).css(&#39;color&#39;, &#39;red&#39;).parent().siblings().find(&#39;a&#39;).css(&#39;color&#39;, &#39;#888&#39;)
        //获取索引
        var index = $(this).parent().index()
        //显示内容区域
        $(&#39;.item&#39;).eq(index).show().siblings().hide()
      &#125;)
  &#125;,
  function () &#123;
    $(&#39;.content&#39;).slideUp()
    $(&#39;a&#39;).css(&#39;color&#39;, &#39;#888&#39;)
  &#125;
)
</code></pre>
</li>
</ul>
<h4 id="1-3-淡入淡出动画"><a href="#1-3-淡入淡出动画" class="headerlink" title="1.3 淡入淡出动画"></a>1.3 淡入淡出动画</h4><ul>
<li><p><code>fadeIn()</code></p>
<pre><code class="js">介绍: 通过透明度的变化来实现所有匹配元素的淡入效果[显示]
语法:
// $(对象).fadeIn([speed],[easing],[fn])

参数介绍:
1. 参数可以不用设置
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行

//代码演示1:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeIn();
&#125;)

//代码演示2
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeIn(&#39;fast&#39;);
&#125;)

//代码演示3
$(&#39;input&#39;).click(function()&#123;
     $(&#39;div&#39;).fadeIn(&#39;fast&#39;, &#39;linear&#39;);
&#125;)

//代码演示4
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeIn(&#39;fast&#39;, &#39;linear&#39;, function() &#123;
         alert(&#39;动画完成&#39;);
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><code>fadeOut()</code></p>
<pre><code class="js">介绍: 通过透明度的变化来实现所有匹配元素的淡出效果[隐藏]
语法:
// $(对象).fadeOut([speed],[easing],[fn])

参数介绍:
1. 参数可以不用设置
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行
</code></pre>
</li>
<li><p><code>fadeTo()</code></p>
<pre><code class="js">介绍:  可以自定义透明度动画效果
语法:
//  $(对象).fadeTo([[speed],opacity,[easing],[fn]])

参数介绍:
1. speed 表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间  [必须设置]
2. opacity 表示透明度, 0 - 1 之间必须设置
3. easing 表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. fn 表示回调函数,动画完成后执行

//代码演示:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeTo(1000, 0.1);
&#125;)
</code></pre>
</li>
<li><p><strong>课堂高亮显示案例</strong></p>
<pre><code class="js">$(&#39;.item&#39;).hover(
  function () &#123;
    $(this).fadeTo(&#39;fast&#39;, 1, &#39;linear&#39;).siblings().fadeTo(&#39;fast&#39;, 0.5, &#39;linear&#39;)
  &#125;,
  function () &#123;
    $(&#39;.item&#39;).fadeTo(&#39;fast&#39;, 1)
  &#125;
)
// 问题: 当鼠标无限次晃动,动画会一直排队执行

// 解决: 通过stop()停止动画排队,必须写到动画前
$(&#39;.item&#39;).hover(
  function () &#123;
    $(this).stop().fadeTo(&#39;fast&#39;, 1, &#39;linear&#39;).siblings().stop().fadeTo(&#39;fast&#39;, 0.5, &#39;linear&#39;)
  &#125;,
  function () &#123;
    $(&#39;.item&#39;).stop().fadeTo(&#39;fast&#39;, 1)
  &#125;
)
</code></pre>
</li>
</ul>
<h4 id="1-5-自定义动画"><a href="#1-5-自定义动画" class="headerlink" title="1.5 自定义动画"></a>1.5 自定义动画</h4><ul>
<li><p><code>animate()</code></p>
<pre><code class="js">介绍: 用于创建自定义动画的函数。
语法:
// $(对象).animate(params,[speed],[easing],[fn]);

参数介绍:
1.params 一组包含作为动画属性和终值的样式属性和及其值的集合   [必须设置]
2.speed  三种预定速度之一的字符串(&quot;slow&quot;,&quot;normal&quot;, or &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)
3.easing 默认jQuery提供&quot;linear&quot; 和 &quot;swing&quot;.
4.fn:在动画完成时执行的函数

//代码演示1
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;)
&#125;)

//代码演示2
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;, &#39;fast&#39;)
&#125;)

//代码演示3
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;, &#39;fast&#39;, &#39;linear&#39;)
&#125;)

//代码演示4
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;, &#39;fast&#39;, &#39;linear&#39;, function()&#123;
        alert(&#39;动画完成&#39;)
    &#125;)
&#125;)

//注意:
1. animate自定义动画,无法实现颜色动画效果,如果需要改变颜色,需要单独下载插件实现
2. 无法直接实现css中转化效果,如果需要实现,则可以通过添加类名得的方式实现
3. 单独的属性,可以使用驼峰命名法 (&#39;marginLeft&#39; 替代 &#39;margin-left&#39;)

https://www.runoob.com/jquery/eff-animate.html
</code></pre>
</li>
<li><p><strong>课堂案例-手风琴案例</strong></p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>搭建 HTML 结构</p>
<pre><code class="html">&lt;div class=&quot;box&quot;&gt;
  &lt;ul&gt;
    &lt;!--注意这里写结构的时候不需要加类名current--&gt;
    &lt;li class=&quot;current&quot;&gt;
      &lt;img src=&quot;imgs/c1.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
      &lt;img src=&quot;imgs/c.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;img src=&quot;imgs/h1.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
      &lt;img src=&quot;imgs/h.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>设置 CSS 样式</p>
<pre><code class="css">.box &#123;
  width: 773px;
  background: url(&#39;imgs/bg.png&#39;) no-repeat;
  padding: 10px;
  margin: 50px auto;
&#125;
.box ul &#123;
  overflow: hidden;
&#125;
.box li &#123;
  width: 70px;
  height: 70px;
  float: left;
  position: relative;
  margin-right: 5px;
&#125;
.box li img &#123;
  position: absolute;
&#125;
.small &#123;
  width: 70px;
  height: 70px;
&#125;
.big &#123;
  display: none;
&#125;
.box .current .big &#123;
  display: block;
&#125;
.box .current .small &#123;
  display: none;
&#125;
.box .current &#123;
  width: 224px;
&#125;
</code></pre>
</li>
<li><p>设置 JS 代码</p>
<ul>
<li><p>鼠标移动到当前元素(li)上,修改当前 li 的宽度及兄弟元素的宽度</p>
<pre><code class="js">$(this).animate(&#123; width: 224 &#125;).siblings().animate(&#123; width: 70 &#125;)
</code></pre>
</li>
<li><p>设置当前元素中的大图片显示,小图片隐藏</p>
<pre><code class="js">$(this).find(&#39;.big&#39;).fadeIn().siblings().fadeOut()
</code></pre>
</li>
<li><p>设置当前元素兄弟元素中大图片隐藏,小图片显示</p>
<pre><code class="js">$(this).siblings().find(&#39;.big&#39;).fadeOut().siblings().fadeIn()
</code></pre>
</li>
<li><p><strong>注意: 在所有动画前加 stop()方法停止动画排队</strong></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-JQ-操作元素属性"><a href="#3-JQ-操作元素属性" class="headerlink" title="3.JQ 操作元素属性"></a>3.JQ 操作元素属性</h3><h4 id="1-1-回顾-webAPI-中操作标签属性"><a href="#1-1-回顾-webAPI-中操作标签属性" class="headerlink" title="1.1 回顾 webAPI 中操作标签属性"></a>1.1 回顾 webAPI 中操作标签属性</h4><ul>
<li><p>操作标签内置系统属性</p>
<ul>
<li><code>getAttribute(属性名)</code></li>
<li><code>setAttribute(属性名, 值)</code></li>
</ul>
</li>
<li><p>操作标签自定义属性</p>
<ul>
<li><p><code>getAttribute(属性名)</code> <code>setAttribute(属性名, 值)</code></p>
</li>
<li><p><code>DOM.dataset</code></p>
<pre><code class="js">DOM.dataset  返回的是一个对象
☞ 获取自定义属性值:   DOM.dataset.属性名
☞ 设置自定义属性值:   DOM.dataset.自定义属性名 = 值;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-JQ-操作元素属性"><a href="#1-2-JQ-操作元素属性" class="headerlink" title="1.2 JQ 操作元素属性"></a>1.2 JQ 操作元素属性</h4><ul>
<li><p><strong>获取标签内置系统属性</strong></p>
<pre><code class="js">语法: $(对象).prop(&#39;属性名&#39;)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.prop(&#39;class&#39;)
console.log(res)
</code></pre>
</li>
<li><p><strong>设置标签内置系统属性</strong></p>
<pre><code class="js">语法: $(对象).prop(&#39;属性名&#39;, 值)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.prop(&#39;class&#39;, 123)

//备注如果设置多个可以通过对象的方式设置,例如:
$(&#39;input&#39;).prop(&#123;
  id: &#39;test&#39;,
  name: &#39;abc&#39;
&#125;)
</code></pre>
</li>
<li><p><strong>获取标签自定义属性</strong></p>
<pre><code class="js">语法: $(对象).attr(自定义属性名)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.attr(&#39;data-myname&#39;)
</code></pre>
</li>
<li><p><strong>设置标签自定义属性</strong></p>
<pre><code class="js">语法: $(对象).attr(自定义属性名, 值)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.attr(&#39;myAge&#39;, 18)
</code></pre>
</li>
<li><p><strong>备注</strong></p>
<pre><code class="js">$(对象).attr() 既可以操作标签自定义属性也可以操作标签内置属性
</code></pre>
</li>
</ul>
<h3 id="4-JQ-操作标签中的值"><a href="#4-JQ-操作标签中的值" class="headerlink" title="4. JQ 操作标签中的值"></a>4. JQ 操作标签中的值</h3><h4 id="1-1-获取-x2F-设置表单控件中的值"><a href="#1-1-获取-x2F-设置表单控件中的值" class="headerlink" title="1.1 获取&#x2F;设置表单控件中的值"></a>1.1 获取&#x2F;设置表单控件中的值</h4><ul>
<li><p><strong>获取</strong></p>
<pre><code class="js">语法: $(对象).val()
</code></pre>
</li>
<li><p><strong>设置</strong></p>
<pre><code class="js">语法: $(对象).val(值)
</code></pre>
</li>
</ul>
<h4 id="1-2-获取-x2F-设置普通标签中的值"><a href="#1-2-获取-x2F-设置普通标签中的值" class="headerlink" title="1.2 获取&#x2F;设置普通标签中的值"></a>1.2 获取&#x2F;设置普通标签中的值</h4><ul>
<li><p><strong>获取</strong></p>
<pre><code class="js">语法: $(对象).text() // 特点与原生js中的innerText一样

$(对象).html() // 特点与原生js中的innerHTML一样
</code></pre>
</li>
<li><p><strong>设置</strong></p>
<pre><code class="js">语法: $(对象).text(值) // 特点与原生js中的innerText一样

$(对象).html(值) // 特点与原生js中的innerHTML一样
</code></pre>
</li>
</ul>
<h4 id="1-3-课堂案例-小计功能"><a href="#1-3-课堂案例-小计功能" class="headerlink" title="1.3 课堂案例-小计功能"></a>1.3 课堂案例-小计功能</h4><ul>
<li><p>步骤:</p>
<ol>
<li><p>设置 HTML 结构</p>
</li>
<li><p>设置 CSS 样式</p>
</li>
<li><p>实现具体功能</p>
<ol>
<li><p>点击<code>加号/减号</code>修改输入框中的值</p>
<pre><code class="js">//获取输入框中的值: 当前按钮的兄弟元素
var num_v = $(this).siblings(&#39;input&#39;).val()

// 将当前值增加1
num_v++

//将当前值赋值给输入框
$(this).siblings(&#39;input&#39;).val(num_v)
</code></pre>
</li>
<li><p>点击<code>加号/减号</code>计算小计总价</p>
<pre><code class="js">补充: 价格保留2位小数  toFixed(2)

例如:  var num = 123;
      num = num.toFixed(2);
</code></pre>
<pre><code class="js">//计算总价: 当前商品数量 * 商品单价
var money = num_v * $(this).parent().siblings(&#39;.sprice&#39;).find(&#39;strong&#39;).text()

//将当前总价设置给总价标签
$(this).parent().siblings(&#39;.t_price&#39;).find(&#39;strong&#39;).text(money.toFixed(2))
</code></pre>
</li>
<li><p>用户修改输入框中的值计算小计总结</p>
<pre><code class="js">$(&#39;.num1 input&#39;).change(function () &#123;
  //获取当前输入框中的值
  var num_v = $(this).val()

  //计算总价: 当前商品数量 * 商品单价
  var money = num_v * $(this).parent().siblings(&#39;.sprice&#39;).find(&#39;strong&#39;).text()

  //将当前总价设置给总价标签
  $(this).parent().siblings(&#39;.t_price&#39;).find(&#39;strong&#39;).text(money.toFixed(2))
&#125;)
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>####1.4 课堂案例-商品总数-总价功能</p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>设置 HTML 结构</p>
</li>
<li><p>设置 CSS 样式</p>
</li>
<li><p>实现功能</p>
<ol>
<li><p><strong>JQ 遍历对象,获取对象中的值</strong></p>
<pre><code class="js">&lt;ul&gt;
  &lt;li&gt;12&lt;/li&gt;
  &lt;li&gt;12&lt;/li&gt;
  &lt;li&gt;12&lt;/li&gt;
&lt;/ul&gt;
如何获取li标签中的值?

语法:
$对象.each(function(index, item)&#123; &#125;)

参数介绍:
1. index 伪数组中的索引值
2. item 伪数组中的每一个DOM对象

注意:
1. each遍历后item是一个dom对象不是JQ对象
</code></pre>
</li>
<li><p><strong>JQ 遍历方式二</strong></p>
<pre><code class="js">//语法:
$.each(数组对象, function(index, item)&#123; &#125;)

//参数介绍:
index  数组中索引值
item   数组中的每一个值
</code></pre>
</li>
<li><p>实现总数求和功能</p>
<pre><code class="js">var num_sum = 0
//数量求和: 获取页面中的每一个input标签中的值累加
$(&#39;.num1 input&#39;).each(function (index, item) &#123;
  num_sum += parseInt($(item).val())
&#125;)
//将总和设置给对应的标签
$(&#39;.product_num strong&#39;).text(num_sum)
</code></pre>
</li>
<li><p>实现总计求和功能</p>
<pre><code class="js">var money_sum = 0
$(&#39;.t_price strong&#39;).each(function (i, item) &#123;
  money_sum += Number($(item).text())
&#125;)
//将总价设置给对应的标签
$(&#39;.product_money strong&#39;).text(money_sum.toFixed(2))
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="5-JQ-删除元素"><a href="#5-JQ-删除元素" class="headerlink" title="5. JQ 删除元素"></a>5. JQ 删除元素</h3><h4 id="1-1-删除元素-x2F-元素中内容"><a href="#1-1-删除元素-x2F-元素中内容" class="headerlink" title="1.1 删除元素&#x2F;元素中内容"></a>1.1 删除元素&#x2F;元素中内容</h4><ul>
<li><p><code>remove()</code></p>
<pre><code class="js">语法: $对象.remove()

// 特点: 从页面中将当前标签删除
</code></pre>
</li>
<li><p><code>empty()</code></p>
<pre><code class="js">语法: $对象.empty()
// 特点: 将标签中的所有内容清空
</code></pre>
</li>
<li><p><code>html()</code></p>
<pre><code class="js">语法: $对象.html(&#39;&#39;)
//特点: 将标签中的所有内容清空,当标签标签依然保留
</code></pre>
</li>
</ul>
<h4 id="1-2-课堂案例-删除功能"><a href="#1-2-课堂案例-删除功能" class="headerlink" title="1.2 课堂案例-删除功能"></a>1.2 课堂案例-删除功能</h4><h3 id="6-JQ-创建元素"><a href="#6-JQ-创建元素" class="headerlink" title="6.JQ 创建元素"></a>6.JQ 创建元素</h3><h4 id="1-1-创建元素"><a href="#1-1-创建元素" class="headerlink" title="1.1 创建元素"></a>1.1 创建元素</h4><ul>
<li><p><code>$对象.html(标签)</code></p>
<pre><code class="js">语法:
$对象.html(&#39;html标签名&#39;);

例如:
$(&#39;div&#39;).html(&#39;&lt;h1&gt;我是标题标签&lt;/h1&gt;&#39;);

特点:
与原生js中 innerHTML的效果一样
</code></pre>
</li>
<li><p><code>$(html标签)</code></p>
<pre><code class="js">语法: $(&#39;html标签&#39;)

返回: JQ标签对象

例如: var span = $(&#39;&lt;span&gt;&lt;/span&gt;&#39;)
</code></pre>
</li>
</ul>
<h4 id="1-2-添加元素"><a href="#1-2-添加元素" class="headerlink" title="1.2 添加元素"></a>1.2 添加元素</h4><ul>
<li><p>父元素末尾添加元素</p>
<pre><code class="js">语法: $父元素.append(元素)

例如: var p = $(&#39;&lt;p&gt;我是创建的p&lt;/p&gt;&#39;)
$(&#39;div&#39;).append(p)
</code></pre>
</li>
<li><p>父元素开始位置添加元素</p>
<pre><code class="js">语法
$父元素.prepend(元素)

例如: var p = $(&#39;&lt;p&gt;我是创建的p&lt;/p&gt;&#39;)
$(&#39;div&#39;).prepend(p)
</code></pre>
</li>
</ul>
<p>​</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jq</tag>
        <tag>jq动画</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery-获取元素大小和位置-事件-表单</title>
    <url>/blog/2020/05/11/JQuery-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE-%E4%BA%8B%E4%BB%B6-%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="JQuery-获取元素大小和位置-事件-表单"><a href="#JQuery-获取元素大小和位置-事件-表单" class="headerlink" title="JQuery-获取元素大小和位置-事件-表单"></a>JQuery-获取元素大小和位置-事件-表单</h1><h3 id="1-JQ-方式获取元素大小和位置"><a href="#1-JQ-方式获取元素大小和位置" class="headerlink" title="1.JQ 方式获取元素大小和位置"></a>1.JQ 方式获取元素大小和位置</h3><h4 id="1-1-JQ-获取元素大小"><a href="#1-1-JQ-获取元素大小" class="headerlink" title="1.1 JQ 获取元素大小"></a>1.1 JQ 获取元素大小</h4><ul>
<li><p><strong>获取元素大小</strong></p>
<ul>
<li><p><code>$对象.width()</code></p>
<pre><code class="js">语法: $对象.width() //获取当前元素大小,只包含内容区域大小

代码演示: console.log($(&#39;div&#39;).width())
</code></pre>
</li>
<li><p><code>$对象.height()</code></p>
<pre><code class="js">语法: $对象.height() //获取当前元素高度,只包含内容区域高度

代码演示: console.log($(&#39;div&#39;).height())
</code></pre>
</li>
<li><p><code>$对象.innerWidth()</code></p>
<pre><code class="js">语法: $对象.innerWidth() //获取当前元素宽度 = 内容区域大小 + 内边距

代码演示: console.log($(&#39;div&#39;).innerWidth())
</code></pre>
</li>
<li><p><code>$对象.innerHeight()</code></p>
<pre><code class="js">语法: $对象.innerHeight() //获取当前元素高度 = 内容区域大小 + 内边距

代码演示: console.log($(&#39;div&#39;).innerHeight())
</code></pre>
</li>
<li><p><code>$对象.outerWidth()</code></p>
<pre><code class="js">语法:
$对象.outerWidth();   //获取当前元素宽度 = 内容区域大小 + 内边距 +边框

代码演示:
console.log($(&#39;div&#39;).outerWidth();
</code></pre>
</li>
</ul>
</li>
<li><p><strong>设置元素大小</strong></p>
<ul>
<li><p><code>$对象.width(值)</code> <code>$对象.height(值)</code></p>
<pre><code class="js">代码演示:
$(&#39;div&#39;).width(&#39;200&#39;).height(&#39;200&#39;);

//注意:
1. 在设置值的时候可以带单位px也可以不用带单位px
</code></pre>
</li>
<li><p><code>$对象.innerWidth(值)</code> <code>$对象.innerHeight(值)</code></p>
<pre><code class="js">代码演示:
$(&#39;div&#39;).innerWidth(&#39;200&#39;).innerHeight(&#39;200&#39;);

//注意:
1. 此时设置的值中已经包含内边距,内边距默认为0,如果在css中给当前元素设置内边距,则元素大内容区域大小会发生改变
</code></pre>
</li>
<li><p><code>$对象.outerWidth(值)</code> <code>$对象.outerHeight(值)</code></p>
<pre><code class="js">代码演示:
$(&#39;div&#39;).outerWidth(&#39;200&#39;, true).outerHeight(&#39;200&#39;, true);

//注意
1. 此时设置的值是包含外边距的,如果通过css给当前元素设置外边距,则元素内容区域大小会发生改变
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-2JQ-获取元素位置"><a href="#1-2JQ-获取元素位置" class="headerlink" title="1.2JQ 获取元素位置"></a>1.2JQ 获取元素位置</h4><ul>
<li><p><code>offset()</code></p>
<pre><code class="js">语法:
$(对象).offset();

//总结:
1. $对象.offset() 返回的是一个对象
2. $对象.offset() 返回对象中包含 left 属性 和 top属性
3. 获取当前元素的位置是相对整个页面
4. 类似于固定定位

//代码演示:
$(&#39;.one&#39;).offset().left
$(&#39;.one&#39;).offset().top
</code></pre>
</li>
<li><p><code>position()</code></p>
<pre><code class="js">语法:
$(对象).position();

//总结:
1. $对象.position() 返回的是一个对象
2. $对象.position() 返回对象中包含 left 属性和 top属性
3. 获取当前元素的位置,如果当前父元素没有定位,相对整个页面,如果父元素有定位,参照父元素
4. 类似于绝对定位

//代码演示:
$(&#39;.one&#39;).position().left
$(&#39;.one&#39;).position().top
</code></pre>
</li>
<li><p><code>scrollTop()</code></p>
<pre><code class="js">语法:
$(对象).scrollTop();
//总结:
1. 获取当前元素(内容)滚动出去的距离
2. 如果希望在程序中获取当前距离大小,需要在scroll事件中获取
//代码演示:
$(&#39;.box&#39;).scroll(function()&#123;
    console.log($(this).scrollTop());
&#125;);
</code></pre>
</li>
</ul>
<h4 id="1-3-课堂案例-返回顶部案例"><a href="#1-3-课堂案例-返回顶部案例" class="headerlink" title="1.3 课堂案例-返回顶部案例"></a>1.3 课堂案例-返回顶部案例</h4><h3 id="2-JQ-方式注册事件"><a href="#2-JQ-方式注册事件" class="headerlink" title="2.JQ 方式注册事件"></a>2.JQ 方式注册事件</h3><h4 id="1-1-通过常规方式注册事件"><a href="#1-1-通过常规方式注册事件" class="headerlink" title="1.1 通过常规方式注册事件"></a>1.1 通过常规方式注册事件</h4><pre><code class="js">事件源.事件类型(function()&#123;&#125;);

//代码演示:

$(&#39;.box&#39;).click(function()&#123;
    $(this).css(&#39;background&#39;,&#39;pink&#39;);
&#125;);
$(&#39;.box&#39;).mouseenter(function()&#123;
    $(this).css(&#39;background&#39;,&#39;blue&#39;);
&#125;);
$(&#39;.box&#39;).mouseleave(function()&#123;
    $(this).css(&#39;background&#39;, &#39;red&#39;)
&#125;);

特点:
1. 只能给事件源注册一个事件
2. 如果注册多个事件,重复设置,不符合JQ的特性(do more do less)
</code></pre>
<h4 id="1-2-通过-on-方式注册事件"><a href="#1-2-通过-on-方式注册事件" class="headerlink" title="1.2 通过 on 方式注册事件"></a>1.2 通过 on 方式注册事件</h4><pre><code class="js">事件源.on(&#39;事件类型&#39;, function () &#123;&#125;)

//代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, function () &#123;
  console.log(123)
&#125;)

事件源.on(&#123;
  事件类型: function () &#123;&#125;,
  事件类型: function () &#123;&#125;
&#125;)

//代码演示:
$(&#39;.box&#39;).on(&#123;
  click: function () &#123;
    $(this).css(&#39;background&#39;, &#39;blue&#39;)
  &#125;,
  mouseenter: function () &#123;
    $(this).css(&#39;background&#39;, &#39;pink&#39;)
  &#125;
&#125;)
</code></pre>
<h4 id="1-3-通过委托方式注册事件"><a href="#1-3-通过委托方式注册事件" class="headerlink" title="1.3 通过委托方式注册事件"></a>1.3 通过委托方式注册事件</h4><pre><code class="js">父事件源.on(&#39;事件类型&#39;, &#39;子选择器&#39;, function () &#123;&#125;)

// 代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, &#39;.one&#39;, function () &#123;
  console.log(123)
&#125;)
// 注意:
// 1. 如果页面中的元素是动态创建的,给元素注册事件,需要使用委托的方式
//代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, &#39;.one&#39;, function () &#123;
  console.log(123)
&#125;)
$(&#39;&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;&#39;).appendTo(&#39;.box&#39;)
</code></pre>
<h4 id="1-4-课堂案例-发布微博案例"><a href="#1-4-课堂案例-发布微博案例" class="headerlink" title="1.4 课堂案例-发布微博案例"></a>1.4 课堂案例-发布微博案例</h4><p>![1594695224614](D:&#x2F;前端_资料&#x2F;就业班&#x2F;JQuery&#x2F;JQuery 第三天&#x2F;03&#x2F;01-课堂笔记&#x2F;img&#x2F;1594695224614.png)</p>
<h4 id="1-5-解绑事件"><a href="#1-5-解绑事件" class="headerlink" title="1.5 解绑事件"></a>1.5 解绑事件</h4><ul>
<li><p><code>off()</code></p>
<pre><code class="js">$对象.off([事件名]);

//代码演示1:
$(&#39;.box&#39;).click(function()&#123;
    alert(123);
&#125;)
$(&#39;.box&#39;).off();

//代码演示2:
$(&#39;div&#39;).on(&#39;click&#39;, function()&#123;
    alert(123);
&#125;)
$(&#39;.box&#39;).off();

// 如果元素身上有很多事件如何解绑?
$(&#39;.box&#39;).on(&#123;
    click: function() &#123;
        alert(123);
    &#125;,
    mouseenter: function() &#123;
        alert(789);
    &#125;
&#125;)
$(&#39;.box&#39;).off();
或者:
$(&#39;.box&#39;).off(&#39;mouseenter&#39;);
// 总结
1. 如果off() 中没有设置任何参数,代表将所有的事件移除
2. 如果要移除对应的事件,在off方法中设置对应的方法名称即可
</code></pre>
</li>
<li><p><code>off()解绑委托事件</code></p>
<pre><code class="js">$父元素对象.off(&#39;事件类型&#39;, &#39;选择器&#39;)

// 代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, &#39;.one&#39;, function () &#123;
  console.log(123)
&#125;)
$(&#39;.box&#39;).off(&#39;click&#39;, &#39;.one&#39;)
</code></pre>
</li>
</ul>
<h3 id="3-表单"><a href="#3-表单" class="headerlink" title="3.表单"></a>3.表单</h3><h4 id="3-1-通过-jQuery-监听表单提交"><a href="#3-1-通过-jQuery-监听表单提交" class="headerlink" title="3.1 通过 jQuery 监听表单提交"></a>3.1 通过 jQuery 监听表单提交</h4><pre><code class="js">HTML 标签本身具有数据提交的能力，然而现实中更常见的是通过监听 DOM 事件获取表单的数据，然后通过 Ajax 将表单的数据提交至服务端。
&lt;form&gt;
  昵称: &lt;input type=&quot;text&quot; name=&quot;nickname&quot;&gt;
  &lt;br&gt;
  密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
  &lt;br&gt;
  &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;script src=&quot;your/path/jquery-版本号.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
 // 监听表单的 submit 事件
  $(&#39;form&#39;).submit(function (ev) &#123;
    // 表单提交的相关逻辑...

    // 阻止 HTML 表单的默认提交
    // ev.preventDefault();

    // ev.preventDefault() 在 jQuery 中可以
    // 被简写成 return false
    return false;
  &#125;)
&lt;/script&gt;
</code></pre>
<h4 id="3-2-表单序列化"><a href="#3-2-表单序列化" class="headerlink" title="3.2 表单序列化"></a>3.2 表单序列化</h4><pre><code class="js">HTML 标签默认提交表单时会自动根据表单项的 name 属性将用户在表单中填写的数据提交至服务端，然而采用监听 DOM 事件对表单提交时，需要开发者自行获取表单项中用户填写的数据，其用户如下代码所示：

&lt;form&gt;
  昵称: &lt;input type=&quot;text&quot; name=&quot;nickname&quot;&gt;
  &lt;br&gt;
  密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
  &lt;br&gt;
  &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;script src=&quot;your/path/jquery-版本号.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 监听表单的 submit 事件
  $(&#39;form&#39;).on(&#39;submit&#39;, function () &#123;

    // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据
    $(this).serialize();

    // 阻止表单默认提交
    return false;
  &#125;)
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jq</tag>
        <tag>jq表单</tag>
        <tag>jq事件</tag>
      </tags>
  </entry>
  <entry>
    <title>git-操作命令</title>
    <url>/blog/2020/05/22/git-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="git-操作命令"><a href="#git-操作命令" class="headerlink" title="git-操作命令"></a>git-操作命令</h1><p><strong>git init</strong><br>本地初始化仓库<br><strong>git add .</strong><br>将项目提交到缓存区<br><strong>git commit -m “备注说明”</strong><br>将项目提交到本地仓库<br><strong>git branch “新分支名称”</strong><br><strong>git checkout master</strong><br>切换主分支<br><strong>git branch -d 分支名称</strong><br>删除分支(切换到主分支，并且合并完之后)<br><strong>git remote add origin SSH 地址</strong><br>关联远程（与远程建立联系）<br><strong>git push -u origin master</strong><br>执行远程同步<br>多次同步 git push<br><strong>git clone SSSH 地址</strong><br>克隆项目<br><strong>git pull origin master</strong><br>更新远程代码（下拉）<br><strong>git log &#x2F; git log –oneline</strong><br>查看本地有几次提交记录<br><strong>git resset –hard 序号</strong><br>回滚（查看之前提交过的存档文件）<br><strong>git branch</strong><br>查看本地所有分支<br><strong>git remote show origin</strong><br>查看远程仓储分支<br><strong>git status (-s)</strong><br>查看文件状态<br><strong>git checkout 新分支名</strong><br>切换新分支<br><strong>git merge 分支名</strong><br>合并分支</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery-基本操作</title>
    <url>/blog/2020/04/21/jQuery-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="jQuery-基本操作"><a href="#jQuery-基本操作" class="headerlink" title="jQuery-基本操作"></a>jQuery-基本操作</h1><h2 id="1、入口函数"><a href="#1、入口函数" class="headerlink" title="1、入口函数"></a>1、入口函数</h2><p>DOM 中如果在 HTML 结构之前写 JS 代码,需要设置加载事件,获取 HTML 元素</p>
<pre><code class="js">window.onload = function () &#123;
  var div = document.querySelector(&#39;div&#39;)
  console.log(div)
&#125;
</code></pre>
<p>JQ 如果在 HTML 结构之前写 js 代码,需要设置加载事件(入口函数)</p>
<pre><code class="js">$(function () &#123;
  var div = document.querySelector(&#39;div&#39;)
  console.log(div)
&#125;)
</code></pre>
<h2 id="2、-符号介绍"><a href="#2、-符号介绍" class="headerlink" title="2、$符号介绍"></a>2、$符号介绍</h2><p>1.就是 JQuer 的一个别名</p>
<p>$(function(){})</p>
<p>2.可以如下写法:</p>
<pre><code class="js">jQuery(function () &#123;&#125;)
</code></pre>
<p>3.是 JQ 中的顶级对象</p>
<pre><code class="js">$(function () &#123;
  console.dir($)
&#125;)
</code></pre>
<h2 id="3、DOM-对象和-jQuery-对象转化"><a href="#3、DOM-对象和-jQuery-对象转化" class="headerlink" title="3、DOM 对象和 jQuery 对象转化"></a>3、DOM 对象和 jQuery 对象转化</h2><p><strong>DOM 对象:</strong></p>
<p>​ 通过 document 方式获取到的元素都叫 DOM 对象</p>
<p><strong>jQuery 对象</strong></p>
<p>​ 通过 $ 方式获取到的元素都叫 JQ 对象</p>
<p><strong>将 JQ 对象转为 DOM 对象方式:</strong></p>
<ul>
<li>JQ 对象[索引]</li>
<li>JQ 对象.get(索引)</li>
<li>将 DOM 对象转化为 JQ 对象:</li>
<li>$(dom 对象)</li>
</ul>
<h2 id="4、获取元素"><a href="#4、获取元素" class="headerlink" title="4、获取元素"></a>4、获取元素</h2><p>1.<strong>语法:</strong> $(‘选择器’);</p>
<p>2.选择器可以是 CSS 中的选择器</p>
<p>3.选择器可以是 jQ 中提供的: :first :last :odd (获取索引是奇数的元素) :even (获取索引是偶数的元素) :eq(index)</p>
<p>4.通过方法找对应的元素</p>
<p>5.parent() 或者 parents(选择器)</p>
<p>6.children([选择器])</p>
<p>7.find(选择器)</p>
<p>8.siblings(选择器)</p>
<p>9.nextAll([选择器])</p>
<p>10.prevAll([选择器])</p>
<p>11.eq(值)</p>
<h2 id="5、注册事件"><a href="#5、注册事件" class="headerlink" title="5、注册事件"></a>5、注册事件</h2><p><strong>语法:</strong></p>
<pre><code class="js">JQ对象.事件名称(function () &#123;
  处理程序
&#125;)
</code></pre>
<p><strong>事件:</strong></p>
<ul>
<li>点击事件: click</li>
<li>鼠标进入事件: mouseenter</li>
<li>鼠标离开事件: mouseleave</li>
</ul>
<h2 id="6、设置样式"><a href="#6、设置样式" class="headerlink" title="6、设置样式"></a>6、设置样式</h2><p>$(‘元素’).css(‘属性’, 值); 设置单个属性样式</p>
<p>$(‘元素’).css({‘属性’: ‘值’,’属性’: ‘值’}) 设置多个属性样式</p>
<p>$(‘元素’).addClass(‘类名 类名’);</p>
<p>$(‘元素’).removeClass(‘类名’);</p>
<p>$(‘元素’).toggleClass(‘类名’);</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title>node-操作命令</title>
    <url>/blog/2020/05/30/node-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="node-操作命令"><a href="#node-操作命令" class="headerlink" title="node-操作命令"></a>node-操作命令</h1><img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648561357(1).4q52g88dmns0.webp">
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/blog/2020/02/27/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h2><p><strong>全局作用域:</strong> 在 javaScript 中,函数外部的所有作用范围都称为全局作用域</p>
<p><strong>全局变量:</strong> 在全局作用域中定义的变量,叫全局变量</p>
<p><strong>全局变量特点:</strong> 在全局作用域中的全局变量可以在任何地方被访问到</p>
<pre><code class="js">// 例如：
&lt;script&gt;

  变量a是一个全局变量

  let a = 123;

  函数fn是一个全局变量

  function fn() &#123;&#125;

  数组ary是一个全局变量

  let ary = []
&lt;script&gt;
</code></pre>
<h2 id="2、局部作用域"><a href="#2、局部作用域" class="headerlink" title="2、局部作用域"></a>2、局部作用域</h2><p><strong>局部作用域:</strong> 在函数内部形成的作用范围称为局部作用域或者函数作用域</p>
<p><strong>局部变量:</strong> 在局部作用域中定义的变量称为局部变量</p>
<p><strong>局部变量特点:</strong> 局部变量只能在当前作用域中被访问</p>
<p><strong>局部作用域和全局作用域之间的关系</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648557530(1).3nhkowhdmpa0.webp">

<h2 id="3、块级作用域"><a href="#3、块级作用域" class="headerlink" title="3、块级作用域"></a>3、块级作用域</h2><p><strong>块级作用域:</strong> 在 javaScript 中,通过 let 关键字&#x2F;const 关键字 定义变量且位于{}中,就会形成块级作用域</p>
<p><strong>块级作用域特点:</strong> 变量只能在当前块级作用域中被访问</p>
<pre><code class="js">&lt;script&gt;
      &#123;let a = 123; console.log(a)&#125;

      if(true) &#123;
          let userName = &#39;dhl&#39;;
      &#125;
&lt;script&gt;
</code></pre>
<h2 id="4、作用域链"><a href="#4、作用域链" class="headerlink" title="4、作用域链"></a>4、作用域链</h2><p><strong>作用域链:</strong> 在 javaScript 中,多个作用域嵌套形成的一个链状结构</p>
<p><strong>作用域链作用:</strong> 通过作用域链进行变量查找</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648557734(1).44hmkm9i3ry0.webp">

<h2 id="5、const-关键字"><a href="#5、const-关键字" class="headerlink" title="5、const 关键字"></a>5、const 关键字</h2><p><strong>const 关键字:</strong> 在程序中定义常量的关键字</p>
<p><strong>const 关键字注意事项:</strong></p>
<ul>
<li>const 定义常量时候必须设置初始值</li>
<li>const 定义常量后,常量的值不能被修改</li>
<li>const 定义常量名不能重复</li>
<li>const 可以产生块级作用域</li>
</ul>
<pre><code class="js">&lt;script&gt;
    const  a = 123;
    const  b = 456;
   &#123;const c = 678&#125;;
&lt;script&gt;
</code></pre>
<h2 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h2><p><strong>闭包:</strong> 闭包就是能够读取其他函数内部变量的函数(简单理解的就是：一个函数定义到了另一个函数的内部，并且还可以使用这个函数内部 定义的变量)</p>
<p><strong>闭包作用:</strong> 可以延长变量的使用生命周期</p>
<p><strong>闭包总结:</strong></p>
<ul>
<li>闭包本质上就是一个函数</li>
<li>闭包函数就是在一个函数中访问另外一个函数中的变量</li>
<li>闭包函数的作用延长了变量的使用生命周期</li>
</ul>
<h2 id="7、变量提升"><a href="#7、变量提升" class="headerlink" title="7、变量提升"></a>7、变量提升</h2><p><strong>变量提升:</strong> 使用 var 关键字定义变量的时候,程序会先将变量的声明提升到当前作用域的开始,不包括赋值</p>
<p><strong>函数提升:</strong> 定义函数的时候,程序会将函数的声明提升到当前作用域的开始位置,不包括函数的调用</p>
<p><strong>let 不存在变量提升</strong></p>
<p><strong>注意:</strong></p>
<p>当程序中同时出现变量和函数的时候,先提升函数,再提升变量(前提是通过 var 定义的变量才可以)</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>全局作用域</tag>
        <tag>局部作用域</tag>
        <tag>块级作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/blog/2020/03/15/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1、默认值参数"><a href="#1、默认值参数" class="headerlink" title="1、默认值参数"></a>1、默认值参数</h2><ol>
<li><p>函数中的形参可以设置默认值,函数中的形参本质就是一个变量,可以直接默认赋值</p>
</li>
<li><p>函数中的形参如果设置了默认值,在没有设置实参的情况下,就是默认值,否则就是实参的值</p>
<pre><code class="js">&lt;script&gt;
function fn(a,b) &#123;
    console.log(a, b);
&#125;
fn()
function fn2(a = 1, b = 2) &#123;
    console.log(a, b);
&#125;
fn2()
&lt;script&gt;
</code></pre>
</li>
</ol>
<h2 id="2、动态参数"><a href="#2、动态参数" class="headerlink" title="2、动态参数"></a>2、动态参数</h2><p>​ 1.<strong>arguments</strong>是函数中用来保存实参信息的一个数组</p>
<p>​ 2.当函数中实参个数不确定的时候,可以通过 arguments 获取实参信息</p>
<pre><code class="js">&lt;script&gt;
    function fn() &#123;
        console.log(arguments);
    &#125;
   fn(1, 2, 3, 4);
&lt;script&gt;
</code></pre>
<h2 id="3、剩余参数"><a href="#3、剩余参数" class="headerlink" title="3、剩余参数"></a>3、剩余参数</h2><ol>
<li><p>语法: **…**自定义参数名</p>
</li>
<li><p>作用: 用来获取多余的实参值 (类似于 arguments)</p>
</li>
<li><p>注意事项:</p>
<p>3.1 剩余参数必须写到函数形参的最后</p>
<p>3.2 剩余参数的名字是自定义的</p>
<p>3.3 剩余参数保存的值是以数组形式保存的</p>
<pre><code class="js">&lt;script&gt;
function fn(a, b, ...c) &#123;
   console.log(a, b, c);
&#125;
 fn(1,2,3);
 fn(1,2,3,4,5);
&lt;script&gt;
</code></pre>
</li>
</ol>
<h2 id="4、箭头函数"><a href="#4、箭头函数" class="headerlink" title="4、箭头函数"></a>4、箭头函数</h2><p>1.<strong>箭头函数语法</strong>: () &#x3D;&gt; {} 等价于 function() {}</p>
<p>2.<strong>函数的组成</strong></p>
<p>​ 2.1 函数名</p>
<p>​ 2.2 参数</p>
<p>​ 2.3 函数体</p>
<p>​ 2.4 返回值</p>
<p><strong>3.箭头函数注意事项</strong>:</p>
<p>​ 3.1 如果只有且只有一个参数,可以省略()</p>
<p>​ 3.2 如果函数体只有一行代码,可以省略{}</p>
<p>​ 3.3 如果函数只有一行代码,返回值 return 可以省略</p>
<p>​ 3.4 箭头函数中不能使用 arguments,只能使用剩余参数</p>
<p>​ 3.5 箭头函数中没有自己的 this,this 是父级作用域中的<strong>this</strong></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值 | 内置对象</title>
    <url>/blog/2020/03/26/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="解构赋值-内置对象"><a href="#解构赋值-内置对象" class="headerlink" title="解构赋值 | 内置对象"></a>解构赋值 | 内置对象</h1><h2 id="一、解构赋值"><a href="#一、解构赋值" class="headerlink" title="一、解构赋值"></a>一、解构赋值</h2><h3 id="1-数组解构"><a href="#1-数组解构" class="headerlink" title="1.数组解构"></a>1.数组解构</h3><p><strong>解构:</strong> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
<p><strong>数组解构:</strong> 将数组中的值一一对应的方式取出赋值给变量</p>
<p><strong>数组解构本质:</strong> 将数组中的值获取到赋值给变量</p>
<p><strong>数组解构语法:</strong> let [变量 1, 变量 2, 变量 3] &#x3D; 数组;</p>
<p><strong>数组解构特点:</strong></p>
<ol>
<li><p>数组解构是将数组中的值一一对应取出分别赋值给变量</p>
</li>
<li><p>如果被赋值的变量个数大于数组中的值,则多余的变量值为 undefined</p>
</li>
<li><p>在数组解构中可以为变量设置默认值</p>
<pre><code class="js">&lt;script&gt;
   let [name1, name2, name3] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
   console.log(name1, name2, name3);
&lt;script&gt;
</code></pre>
</li>
</ol>
<h3 id="2-对象解构"><a href="#2-对象解构" class="headerlink" title="2.对象解构"></a>2.对象解构</h3><p><strong>对象解构:</strong> 将对象中的属性或方法取出赋值给变量</p>
<p><strong>语法 1:</strong> let {属性名:变量名 1, 属性名:变量名 2 …} &#x3D; 对象</p>
<p><strong>语法 2:</strong> let {属性名,属性名} &#x3D; 对象</p>
<p><strong>对象解构总结</strong></p>
<ol>
<li><p>对象解构中,属性名和对象中的属性必须保持一致,否则值为 undefined</p>
</li>
<li><p>对象解构中,如果属性名和变量名一样,则可以省略变量名,但属性名必须与对象中的属性一样</p>
<pre><code class="js">&lt;script&gt;
   let persone = &#123;uname: &#39;zs&#39;, uage: 23&#125;
   let &#123;uname: n1, uage: n2&#125; = persone;
   let &#123;uname, uage&#125; = persone;
&lt;script&gt;
</code></pre>
</li>
</ol>
<h2 id="二、内置对象-js-内部提供的对象"><a href="#二、内置对象-js-内部提供的对象" class="headerlink" title="二、内置对象 (js 内部提供的对象)"></a>二、内置对象 (js 内部提供的对象)</h2><h3 id="1-数组对象"><a href="#1-数组对象" class="headerlink" title="1.数组对象"></a>1.数组对象</h3><ol>
<li><p>数组内置对象: Array()</p>
</li>
<li><p>Array 中的实例方法</p>
<p>- reverse() 翻转数组</p>
<p>- indexOf() 检索数组中的值</p>
<p>- lastIndexOf() 检索数组中的值</p>
<p>- splice() 删除或其他数组中的值</p>
<p>- concat()合并两个数组的值</p>
<p>- join() 将数组中的值拼接为字符串</p>
<p>- forEach(function(item, index){}) 遍历数组</p>
<p>- filter(function(item, index){}) 过滤筛选数组,返回一个新数组</p>
<p>- map(function(item, index){})迭代原数组,生成新数组</p>
</li>
</ol>
<h3 id="2-字符串对象"><a href="#2-字符串对象" class="headerlink" title="2.字符串对象"></a>2.字符串对象</h3><p>1.Array 内置对象中的静态方法</p>
<p>2.Array.from(对象) 将伪数组转换为数组</p>
<h3 id="3-包装类型"><a href="#3-包装类型" class="headerlink" title="3.包装类型"></a>3.包装类型</h3><p><strong>String 构造函数</strong></p>
<p>- 属性 : length 属性</p>
<p>- 方法: 拼接字符串 concat()</p>
<p>- 方法: split()分割字符串 toUpperCase()转大写 toLowerCase()转小写</p>
<p>- substring(indexStart, indexEnd) - substr(start[,length])</p>
<p>- 方法: startsWith() 检测是否以某个字母开始 endsWith()检测是否以某个字母结束</p>
<p>- 方法: replace(‘被替换的字符’, ‘替换后的字符’)替换 indexOf()</p>
<p>- 方法: padStart(位数, ‘值’), 是否够几位数,如果不够在前面添加对应的内容</p>
<p>- 方法: padEnd(‘位数’, ‘值’),是否够几位数,如果不够在后面添加对应的内容</p>
<p><strong>Number 构造函数</strong></p>
<p>- 方法: toFixed()保留几位小数</p>
<p><strong>Boolean 构造函数</strong></p>
<p><strong>包装类型:</strong> 一个简单类型可以通过 js 内部的构造函数包装成一个对象</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>解构赋值，内置对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/blog/2020/04/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h2><p><strong>封装:</strong> 将一段功能代码封装成一个函数</p>
<p>封装一个构造函数创建对象</p>
<pre><code class="js">function People(uname) &#123;
  this.uname = uname

  this.eat = function () &#123;&#125;
&#125;
</code></pre>
<p>通过构造函数封装后,创建多个对象,对象调用同一个方法,在内存中执行的并不是同一个方法</p>
<h2 id="2、原型对象"><a href="#2、原型对象" class="headerlink" title="2、原型对象"></a>2、原型对象</h2><p><strong>prototype:</strong> 叫原型,是每一个构造函数身上的一个属性,该属性是以对象的形式存在的(原型对象)</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648559112(1).5zhb0ex1q7k0.webp">

<p><strong>作用:</strong> 通过原型对象设置构造函数中功能的方法</p>
<p><strong>语法:</strong> 构造函数.prototype.方法名 &#x3D; function(){}</p>
<p><strong>构造函数与 prototype 之间的关系:</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648559174(1).3l4p5n5gemm0.webp">

<h2 id="3、对象原型"><a href="#3、对象原型" class="headerlink" title="3、对象原型"></a>3、对象原型</h2><p><strong>什么是 proto</strong> : 每一个实例对象身上的一个属性,该属性是以对象的形式存在的(对象原型)</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648559283(1).30dukq6xfpa0.webp">

<p>*<strong>*proto</strong>作用:** <strong>proto</strong>指向了原型对象 prototype,可以让实例对象访问构造函数中的公共方法</p>
<p><strong>prototype 与 proto 之间的关系</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.2wfynnkwmyw0.webp">

<h2 id="4、原型链"><a href="#4、原型链" class="headerlink" title="4、原型链"></a>4、原型链</h2><p><strong>原型链:</strong> 多个原型对象之间形成的一个链状结构</p>
<p><strong>作用:</strong> 通过原型链可以确定方法的执行顺序</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片2.6v5blgn2wh40.webp">

<h2 id="5、继承"><a href="#5、继承" class="headerlink" title="5、继承"></a>5、继承</h2><p><strong>什么是继承:</strong> 子类中使用父类中的属性或方法</p>
<p><strong>继承的作用:</strong> 继承可以减少重复代码</p>
<p><strong>继承分类:</strong> 属性继承 + 方法继承</p>
<p><strong>属性继承语法:</strong> 构造函数.call(对象,参数 1,参数 2…)</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片3.58c1tmd10gg0.webp">
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX</title>
    <url>/blog/2021/09/11/JSX/</url>
    <content><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><h2 id="JSX-介绍和使用步骤"><a href="#JSX-介绍和使用步骤" class="headerlink" title="JSX 介绍和使用步骤"></a>JSX 介绍和使用步骤</h2><h3 id="JSX介绍"><a href="#JSX介绍" class="headerlink" title="JSX介绍"></a>JSX介绍</h3><p>JSX 是 XML-like 的 JS 语法拓展。</p>
<p>就是拓展了 JS 的语法，这个语法和 XML 的语法很像。</p>
<p>有的时候也被叫做 JavaScript XML。</p>
<blockquote>
<p>官方文档：</p>
<p><a class="link"   href="https://facebook.github.io/jsx/" >https://facebook.github.io/jsx/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://en.wikipedia.org/wiki/JSX_(JavaScript)" >https://en.wikipedia.org/wiki/JSX_(JavaScript)<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>JSX 语法的特点就是，让我们可以在 Javascript 代码中写 XML(HTML) 格式的代码</p>
<p>这种视图的构建模式一般称之为：声明式视图构建模式。问题：什么是命令式视图构建？</p>
<p>这种对于开发者来说，语法直观、学习成本低、开发效率高，大大减少了原生DOM操作。</p>
<p>以前 DOM 操作的效率、水平高低由开发者决定，现在是框架搞定。</p>
<p> <strong>JSX 是React声明式的视图构建模式的体现，是 React 最大的特点，也是现在流行的前端框架设计理念</strong></p>
<h3 id="JSX的使用"><a href="#JSX的使用" class="headerlink" title="JSX的使用"></a>JSX的使用</h3><p>直接在 .js 代码中声明一个标签，格式和html标签中相同。</p>
<pre><code class="jsx">import ReactDOM from &#39;react-dom&#39;

// 创建 react 元素
// 原来
// const h1 = React.createElement(&#39;h1&#39;, null, &#39;Hello React&#39;)
//现在
const h1 = &lt;h1&gt;Hello React&lt;/h1&gt;;

// 渲染 react 元素
ReactDOM.render(h1, document.getElementById(&#39;root&#39;));
</code></pre>
<p>使用 JSX 完成笔记开头的需求</p>
<pre><code class="html">&lt;div&gt;
    &lt;h1&gt;购物列表&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;华为&lt;/li&gt;
        &lt;li&gt;iPhone&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>使用 JSX 语法代码：</p>
<pre><code class="jsx">// 创建 react 元素
const el = (
  &lt;div&gt;
    &lt;h1&gt;购物列表&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li&gt;华为&lt;/li&gt;
      &lt;li&gt;iPhone&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
);

// 渲染 react 元素
ReactDOM.render(el, document.getElementById(&#39;root&#39;));
</code></pre>
<p> JSX 不是标准的 JS 语法，是 JS 的语法扩展。</p>
<p>之所以上面的代码没有报错，是因为我们的 React 脚手架项目中内置了 JSX 语法解析器，用来解析该语法。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>使用步骤总结</p>
<ol>
<li>导入ReactDOM包</li>
<li>使用 JSX 创建 react 元素</li>
<li>将 react 元素渲染到页面中</li>
</ol>
<p><strong>完整代码</strong></p>
<pre><code class="jsx">// import React from &#39;react&#39; // React 17之后无需再引入
import ReactDOM from &#39;react-dom&#39;

// 创建 react 元素
const h1 = &lt;h1&gt;Hello React&lt;/h1&gt;;

// 渲染 react 元素
ReactDOM.render(h1, document.getElementById(&#39;root&#39;));
</code></pre>
<pre><code class="jsx">// import React from &#39;react&#39; // React 17之后无需再引入
import ReactDOM from &#39;react-dom&#39;

// 创建 react 元素
const el = (
  &lt;div&gt;
    &lt;h1&gt;购物列表&lt;/h1&gt;
    &lt;ul&gt;
      &lt;li&gt;华为&lt;/li&gt;
      &lt;li&gt;iPhone&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
);

// 渲染 react 元素
ReactDOM.render(el, document.getElementById(&#39;root&#39;));
</code></pre>
<p><strong>说明：</strong></p>
<p>React 脚手架项目中 .js 文件中可以直接声明 html 标签的背后原因</p>
<p>在线环境：<a class="link"   href="https://www.babeljs.cn/" >https://www.babeljs.cn/<i class="fas fa-external-link-alt"></i></a></p>
<p>注意点：</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/jsx-compiler.png" alt="image-20220220233730589" style="zoom:80%;" />

<p>JSX语法转换的两种方式的差异点：</p>
<p>从 React 17 之后加入的，优点</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/jsx-good.png" alt="image-20220220234223353" style="zoom:80%;" />



<blockquote>
<p>官方说明</p>
<p><a class="link"   href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" >https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<hr>
<h3 id="JSX使用注意点"><a href="#JSX使用注意点" class="headerlink" title="JSX使用注意点"></a>JSX使用注意点</h3><ol>
<li>React17 版本之后，使用 JSX 不再需要额外导入 React</li>
<li>在 React 中所有标签都要闭合 &#x2F;&gt;，无论你是不是自闭和标签</li>
<li>声明的 JSX结构必须要有一个根节点， 如果没有根节点，可以使用<code>&lt;&gt;&lt;/&gt;</code>（幽灵节点）或者<code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code>包裹</li>
<li>JSX 结构中声明的标签，属性名使用驼峰命名法： onclick &#x3D;&gt; onClick、<code>class</code> &#x3D;&gt; <code>className</code>、<code>for</code> &#x3D;&gt;  <code>htmlFor</code></li>
<li>JSX可以换行，如果JSX有多行，推荐使用<code>()</code>包裹JSX，防止 JS 自动插入分号陷阱<ul>
<li><a class="link"   href="https://blog.csdn.net/qq_36391954/article/details/79366383" >https://blog.csdn.net/qq_36391954/article/details/79366383<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ol>
<hr>
<h2 id="JSX-中使用-JavaScript-表达式"><a href="#JSX-中使用-JavaScript-表达式" class="headerlink" title="JSX 中使用 JavaScript 表达式"></a>JSX 中使用 JavaScript 表达式</h2><p><strong>访问语法：</strong></p>
<p><code>&#123; JavaScript 表达式 &#125;</code></p>
<p>JS 表达式：数据类型和运算符的组合（可以单独出现数据类型，也可以数据类型+运算符的组合）</p>
<p>表达式就是一个值，一个可以在栈内存分配的值。</p>
<ul>
<li>字符串、数值、布尔值、null、undefined、object（ [] &#x2F; {} ）</li>
<li>1 + 2、’abc’.split(‘’)、[‘a’, ‘b’].join(‘-‘)</li>
<li>function fn() {}、 fn()</li>
</ul>
<p><strong>技巧：</strong></p>
<p>验证是不是 JS 表达式的技巧：看内容能不能作为方法的参数，比如，<code>console.log( 表达式 )</code></p>
<hr>
<p>代码举例：</p>
<p>在 JSX 结构中访问以下数据类型</p>
<ol>
<li>字符串类型</li>
<li>数字类型</li>
<li>数组类型</li>
<li>对象类型</li>
<li>三元表达式</li>
<li>函数类型</li>
<li>JSX表达式类型</li>
<li>渲染一张图片</li>
</ol>
<p>代码：</p>
<pre><code class="jsx">  // 字符串类型
  const name = &quot;Jack&quot;
  // 数字类型
  const age = 18
  // 数组类型
  const hobbies = [&#39;吃饭&#39;,&#39;睡觉&#39;,&#39;打豆豆&#39;]
  // 对象类型
  const obj = &#123;name: &#39;Rose&#39;, age: 18&#125;
  // 三元表达式
  // 问 1 &amp;gt; 0 吗？&#123;1&gt;0 ? &#39;是的&#39;: &#39;不是&#39;&#125;
  // 函数类型
  const fun = () =&gt; &#123;
    return (
      &lt;div&gt;我是函数返回的内容&lt;/div&gt;
    )
  &#125;
  // JSX表达式类型
  const jsx = (
    &lt;div&gt;我是jsx表达式&lt;/div&gt;
  )

// 创建 react 元素
const el = (
  &lt;div&gt;
    &lt;h1 className=&quot;title&quot;&gt;
      Hello &#123;name&#125;，我今年&#123;age&#125;岁
    &lt;/h1&gt;
    &lt;h1 style=&#123;&#123; color: 'red' &#125;&#125;&gt;&#123;hobbies.join(&#39;,&#39;)&#125;&lt;/h1&gt;
    &lt;h1&gt;
      &#123;obj.name&#125; 年龄：&#123;obj.age&#125;
    &lt;/h1&gt;
    &lt;h1&gt;问 1 &amp;gt; 0 吗？&#123;1 &gt; 0 ? &#39;是的&#39; : &#39;不是&#39;&#125;&lt;/h1&gt;
    &lt;h1&gt;&#123;fun()&#125;&lt;/h1&gt;
    &lt;h1&gt;&#123;jsx&#125;&lt;/h1&gt;
  &lt;/div&gt;
);
</code></pre>
<p>JSX中的注释</p>
<pre><code class="jsx">&#123;/* 快键键 ctrl + / */&#125;
</code></pre>
<p><strong>总结：</strong></p>
<ol>
<li>JSX 中的 {}内，可以出现任意的js表达式（除了object {}）</li>
<li>JSX 中的 {}内，不能出现 js 语句，比如<code>if</code>、<code>for</code>、<code>while</code>等</li>
<li>函数不能直接出现在标签内部的{}内，但是函数调用可以。</li>
<li>函数可以作为标签属性出现在{}内，比如：事件处理程序的绑定。</li>
</ol>
<hr>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>现有如下需求：</p>
<p>ajax 发起异步请求数据的过程中和数据返回后，页面渲染的UI不同。</p>
<p>在react中如何实现？</p>
<p><strong>代码</strong></p>
<ul>
<li>通过判断<code>if/else</code>控制</li>
</ul>
<pre><code class="jsx">// JSX 中的 条件 渲染

// 条件
const isLoading = true;

// 渲染（UI）
const loadingUI = &lt;h1&gt;数据加载中！&lt;/h1&gt;;
const successUI = &lt;h1&gt;数据请求成功！&lt;/h1&gt;;

// 函数
const loadData = () =&gt; &#123;
  // 条件和渲染结合在一起了（对比vue的条件和渲染的结合）
  if (isLoading) &#123;
    return loadingUI;
  &#125; else &#123;
    return successUI;
  &#125;
&#125;;

const jsx = &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;;
      
ReactDOM.render(jsx, document.getElementById(&#39;root&#39;));
</code></pre>
<ul>
<li>通过三元运算符控制</li>
</ul>
<pre><code class="jsx">// JSX 中的 条件 渲染

// 条件
const isLoading = true;

// 渲染（UI）
const loadingUI = &lt;h1&gt;数据加载中！&lt;/h1&gt;;
const successUI = &lt;h1&gt;数据请求成功！&lt;/h1&gt;;

// 三元表达式
const jsx = &lt;div&gt;&#123;isLoading ? loadingUI : successUI&#125;&lt;/div&gt;;

ReactDOM.render(jsx, document.getElementById(&#39;root&#39;));
</code></pre>
<ul>
<li>逻辑与（&amp;&amp;）运算符</li>
</ul>
<pre><code class="jsx">// JSX 中的 条件 渲染

// 条件
const isLoading = true;

// 渲染（UI）
const loadingUI = &lt;h1&gt;数据加载中！&lt;/h1&gt;;
const successUI = &lt;h1&gt;数据请求成功！&lt;/h1&gt;;

const isLoading = false
const jsx = &lt;div&gt;&#123;isLoading &amp;&amp; loadingUI&#125;&lt;/div&gt;
      
ReactDOM.render(jsx, document.getElementById(&#39;root&#39;));
</code></pre>
<hr>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>数组内容格式转换，使用数组的 map 方法</p>
<pre><code class="jsx">const books1 = [&#39;React&#39;, &#39;Vue&#39;, &#39;Angular&#39;]

const books2 = books1.map(book =&gt; &lt;li&gt;&#123;book&#125;&lt;/li&gt;)

const ul = &lt;ul&gt;&#123;books2&#125;&lt;/ul&gt;
</code></pre>
<p>或直接在 JSX 中渲染</p>
<pre><code class="jsx">const books1 = [&#39;React&#39;, &#39;Vue&#39;, &#39;Angular&#39;]

const ul = &lt;ul&gt;&#123;books1.map(book =&gt; &lt;li&gt;&#123;book&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;
</code></pre>
<p>最后在遍历时添加 key 属性</p>
<pre><code class="jsx">const books1 = [&#39;React&#39;, &#39;Vue&#39;, &#39;Angular&#39;]

const ul = &lt;ul&gt;&#123;books1.map((book, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;book&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>场景：重复生成相同的 HTML 结构，比如，歌曲列表、商品列表等</li>
<li>实现：使用数组的 <code>map</code> 方法进行格式转换</li>
<li>注意：需要为遍历项添加 <code>key</code> 属性<ul>
<li>key 在 HTML 结构中是看不到的，是 React 内部用来进行性能优化时使用的</li>
<li>key 在当前列表中要唯一</li>
<li>如果列表中有像 id 这种的唯一值，就用 id 来作为 key 值</li>
<li>如果列表中没有像 id 这种的唯一值，就可以使用 index（下标）来作为 key 值</li>
</ul>
</li>
</ul>
<p><strong>练习：</strong></p>
<pre><code class="jsx">// 列表渲染如下数据
const books = [&#123;id: 1, name: &#39;React&#39;&#125;, &#123;id: 2, name: &#39;Vue&#39;&#125;,&#123;id: 3, name: &#39;Angular&#39;&#125;]
</code></pre>
<hr>
<h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><p><strong>内容</strong>：</p>
<ol>
<li>行内样式 - style<ol>
<li>默认情况像 width&#x2F;height 等属性，可以省略 px，直接使用 <code>数值</code> 即可。如果有其它单位显示需求，直接在数值后跟单位即可<code>&#123;widht: &#39;10rem&#39;&#125;</code> ， <code>&#123;widht: &#39;10vw&#39;&#125;</code>。</li>
<li>如果是需要使用百分比的单位，此时，继续使用字符串的值即可（比如，<code>&quot;60%&quot;</code>）</li>
</ol>
</li>
<li>类名 - className【推荐】</li>
</ol>
<p><strong>核心代码：</strong></p>
<ul>
<li><p>行内样式-style</p>
<ul>
<li><p>浏览器需要的</p>
</li>
<li><pre><code class="html">&lt;h1 style=&quot;color: red; background-color: pink; width: 300px;&quot;&gt;Hello React&lt;/h1&gt;
</code></pre>
</li>
<li><p>React 中定义的</p>
</li>
<li><pre><code class="jsx">const h1 = &lt;h1 style=&#123;&#123; color: 'red', backgroundColor: 'pink', width: 300 &#125;&#125;&gt;Hello React&lt;/h1&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>类名-className</p>
<ul>
<li><p>浏览器需要的</p>
</li>
<li><pre><code class="html">&lt;h1 class=&quot;p-title&quot;&gt;Hello React&lt;/h1&gt;
</code></pre>
</li>
<li><p>React 中定义的</p>
</li>
<li><pre><code class="jsx">// 导入样式
import &#39;./base.css&#39;
const dv = &lt;div className=&#123;&quot;p-title&quot;&#125;&gt;style样式&lt;/div&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="JSX-总结"><a href="#JSX-总结" class="headerlink" title="JSX 总结"></a>JSX 总结</h2><ul>
<li>React 使用 JSX 来编写 UI（HTML）</li>
<li><strong>React 完全利用 JS 语言自身的能力来增强 UI 的编写</strong> - <strong>能用 JS 来实现的功能绝不会增加一个新的 API</strong></li>
<li>现在，就可以使用 React 来编写任意 UI 结构了</li>
</ul>
<pre><code class="jsx">// JSX
&lt;div&gt;&#123;JS 表达式&#125;&lt;/div&gt;
</code></pre>
<p><strong>一句话总结：</strong></p>
<p><strong>只要是在 JSX 结构中访问 JS 中的数据加上一个 {} 即可。React 后续所有的处理逻辑基本上都是在这个基础上延伸出来的。</strong></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 项目优化的解决方案</title>
    <url>/blog/2021/04/20/Vue%20%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="Vue-项目优化的解决方案"><a href="#Vue-项目优化的解决方案" class="headerlink" title="Vue 项目优化的解决方案"></a>Vue 项目优化的解决方案</h2><p><strong>1、使用mini-css-extract-plugin 插件抽离css</strong><br><strong>2、配置optimization 把公共的js 代码抽离出来</strong><br><strong>3、通过webpack 处理文件压缩</strong><br><strong>4、不打包框架、库文件，通过cdn 的方式引入</strong><br><strong>5、小图片使用base64</strong><br><strong>6、配置项目文件懒加载</strong><br><strong>7、UI 库配置按需加载</strong><br><strong>8、开启Gzip 压缩</strong></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 怎么实现跨域</title>
    <url>/blog/2021/03/12/Vue%20%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="Vue-怎么实现跨域"><a href="#Vue-怎么实现跨域" class="headerlink" title="Vue 怎么实现跨域"></a>Vue 怎么实现跨域</h2><p><strong>1、什么是跨域</strong><br>跨域指浏览器不允许当前页面的所在的源去请求另一个源的数据。源指协议，端口，域名。只要这个3 个中有一个不同就是跨域</p>
<p><strong>2、使用vue-cli 脚手架搭建项目时proxyTable 解决跨域问题</strong></p>
<p>打开config&#x2F;index.js,在proxyTable 中添写如下代码：</p>
<pre><code class="js">proxyTable: &#123;
&#39;/api&#39;: &#123; //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot;
target: &#39;http://f.apiplus.cn&#39;, //源地址
changeOrigin: true, //改变源
pathRewrite: &#123;
&#39;^/api&#39;: &#39;http://f.apiplus.cn&#39; //路径重写
&#125;
</code></pre>
<p><strong>3、使用CORS（跨域资源共享</strong></p>
<p>3.1）前端设置，vue 设置axios 允许跨域携带cookie（默认是不带cookie）axios.defaults.withCredentials &#x3D; true;</p>
<p>3,2）后端设置：<br>    3.2.1）跨域请求后的响应头中需要设置<br>    3.2.2）Access-Control-Allow-Origin 为发起请求的主机地址<br>    3.2.3）Access-Control-Allow-Credentials，当它被设置为true 时，允许跨域带cookie，但此时Access-Control- Allow-Origin 不能为                通配符*<br>    3.2.4）Access-Control-Allow-Headers，设置跨域请求允许的请求头<br>    3.2.5）Access-Control-Allow-Methods，设置跨域请求允许的请求方式</p>
<p><strong>4、使用jsonp方式</strong></p>
<p>原理：利用script标签中的src属性不受同源策略的影响</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router 怎么配置路由</title>
    <url>/blog/2020/11/17/Vue-router%20%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="Vue-router-怎么配置路由"><a href="#Vue-router-怎么配置路由" class="headerlink" title="Vue-router 怎么配置路由"></a>Vue-router 怎么配置路由</h2><p>vue 中配置路由分为5 个步骤，分别是：<br>1、安装</p>
<pre><code class="js">npm install --save vue-router
</code></pre>
<p>2、引用</p>
<pre><code class="vue">import VueRouter from &#39;vue-router&#39;
</code></pre>
<p>3、配置路由文件</p>
<pre><code class="vue">var router = new VueRouter(&#123;
routes:[
    &#123;
    path:&quot;/hello&quot;,
    component:HelloWorld
    &#125;,
    &#123;
    path:&quot;/wen&quot;,
    component:HelloWen
new Vue(&#123;
el: &#39;#app&#39;,
components: &#123; App &#125;,
router,
template: &#39;&lt;App/&gt;&#39;
&#125;)
</code></pre>
<p>4、视图加载的位置<br>默认App.vue 文件中加</p>
<pre><code class="vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
<p>5、跳转导航</p>
<pre><code class="vue">&lt;router-link to=&quot;/hello&quot;&gt;helloword&lt;/router-link&gt;（渲染出来的是a 标签）
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue最大的优势?</title>
    <url>/blog/2020/06/02/Vue%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="Vue最大的优势"><a href="#Vue最大的优势" class="headerlink" title="Vue最大的优势?"></a>Vue最大的优势?</h1><p> 根据我对于vue的理解，我总结的vue优势有以下五点：</p>
<pre><code>    一、vue作为一款轻量级框架，门槛低，上手快，简单易学。

    二、vue可以进行组件化开发，数据与结构相分离，使代码量减少，从而提升开发效率，易于理解

    三、vue最突出的优势在于对数据进行双向绑定，使用虚拟DOM

    四、相较于传统页面通过超链接实现页面跳转，vue会使用路由跳转不会刷新页面

    五、vue是单页面应用，页面局部刷新，不用每次跳转都请求数据，加快了访问速度，提升了用户体验
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>react-Hooks</title>
    <url>/blog/2021/10/26/react-Hooks/</url>
    <content><![CDATA[<h1 id="react-Hooks"><a href="#react-Hooks" class="headerlink" title="react-Hooks"></a>react-Hooks</h1><h2 id="State-Hooks"><a href="#State-Hooks" class="headerlink" title="State Hooks"></a>State Hooks</h2><h3 id="useState-介绍使用"><a href="#useState-介绍使用" class="headerlink" title="useState-介绍使用"></a>useState-介绍使用</h3><ul>
<li>State-“状态”，Hook-“钩子”，（有把 xxx 连接到 yyy 的含义）</li>
<li>当组件需要存储和管理状态时，可以使用一个“钩子”，将状态和管理状态的函数“钩入、连接”到当前组件中。</li>
<li>如何使用一个引入状态的钩子？通过调用 useState() 函数</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li><p>导入 useState</p>
<ul>
<li><pre><code class="jsx">import React, &#123; useState &#125; from &quot;react&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>调用 useState() 函数</p>
<ul>
<li>参数：状态的初始值</li>
<li>返回值：数组，包含两个元素。第一个是状态。第二个是修改状态的函数。</li>
</ul>
</li>
<li><p>解构 useState() 函数返回的数组</p>
<ul>
<li><pre><code class="jsx">// 钩入、链接，一个状态和修改状态的函数到当前组件中
const [count, setCount] = useState(0);

// 不推荐
const stateArray = useState(0);
const count = stateArray[0];
const setCount = stateArray[1];
</code></pre>
</li>
</ul>
</li>
<li><p>使用状态值，当前组件（函数）内可见。</p>
<ul>
<li><pre><code class="jsx">&lt;button onClick=&#123;handleCount&#125;&gt;按钮被点击了&#123;count&#125;次&lt;/button&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>使用修改组件状态的函数，当前组件内可见。</p>
<ul>
<li><pre><code class="jsx">const handleCount = () =&gt; &#123;
  setCount(count + 1);
&#125;;
return &lt;button onClick=&#123;handleCount&#125;&gt;按钮被点击了&#123;count&#125;次&lt;/button&gt;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="Effect-Hooks"><a href="#Effect-Hooks" class="headerlink" title="Effect Hooks"></a>Effect Hooks</h2><h3 id="useEffect-基本使用"><a href="#useEffect-基本使用" class="headerlink" title="useEffect-基本使用"></a>useEffect-基本使用</h3><ul>
<li>Effect-“效果、作用”，Hook-“钩子”。</li>
<li>当组件需要完成一个 “副作用” 操作时，需要启动一个钩子，将这个“副作用”操作勾入到当前组件中。<ul>
<li>这个<strong>“副作用”</strong>是指在组件每次渲染完成后，你想执行的操作。比如：<strong>DOM的操作</strong>、<strong>发起异步请求等</strong>。</li>
<li>任何在渲染完成之后的操作，都称之为<strong>“副作用”</strong></li>
</ul>
</li>
<li>如何执行一个 “副作用” 操作？<ul>
<li>使用 useEffect() 函数。</li>
</ul>
</li>
</ul>
<p><strong>需求：</strong></p>
<p>在前面已经完成的统计按钮点击次数的功能基础上，再添加一个新功能：</p>
<p><strong>就是将按钮的点击次数同步更新到浏览器 tab 栏上</strong>。</p>
<p>这是一个典型的可以使用 useEffect 来完成的需求，因为更新浏览器标题栏，不是组件的渲染可以完成的任务。</p>
<p>这就需要在组件渲染完成之后进行操作。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>导入 useEffect</p>
<ul>
<li><pre><code class="jsx">import React, &#123;useState, useEffect &#125; from &quot;react&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>useEffect说明</p>
<ul>
<li>useEffect是一个函数，要求传入的参数也是一个函数，在这个传入函数中进行“副作用”操作。</li>
</ul>
</li>
<li><p>传入执行具体业务操作的“副作用”函数</p>
<ul>
<li><pre><code class="jsx">useEffect(() =&gt; &#123;
  // DOM 操作修改浏览器标题栏
  document.title = `按钮被点击了$&#123;count&#125;次`;
&#125;);
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="useContext-使用"><a href="#useContext-使用" class="headerlink" title="useContext-使用"></a>useContext-使用</h3><p><strong>需求：</strong></p>
<ul>
<li>使用 useContext 实现跨级组件通讯</li>
</ul>
<p><strong>语法：</strong></p>
<ul>
<li>useContext 的参数：Context 对象，即：通过 createContext 函数创建的对象</li>
<li>useContext 的返回值：Context.Provider 中提供的 value 数据</li>
</ul>
<h2 id="其它-Hooks"><a href="#其它-Hooks" class="headerlink" title="其它 Hooks"></a>其它 Hooks</h2><h3 id="useRef-操作DOM"><a href="#useRef-操作DOM" class="headerlink" title="useRef-操作DOM"></a>useRef-操作DOM</h3><p><strong>需求：</strong></p>
<ul>
<li>在 React 中进行 DOM 操作</li>
<li>使用 useRef 获取和操作DOM</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li><p>导入 useRef</p>
</li>
<li><p>定一个变量，接收调用 useRef(null) 的返回值</p>
</li>
<li><p>在组件的 JSX 中通过 ref 属性关联你想获取DOM的元素</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code class="JSX">import &#123; useRef &#125; from &#39;react&#39;

const App = () =&gt; &#123;
  // 1 使用useRef能够创建一个ref对象 createRef
  const inputRef = useRef(null)

  const add = () =&gt; &#123;
    // 3 通过 inputRef.current 来访问对应的 DOM
    console.log(inputRef.current.value)
    inputRef.current.focus()
  &#125;
  
  return (
    &lt;section className=&quot;todoapp&quot;&gt;
      &#123;/* 2 将 ref 对象设置为 input 的 ref 属性值。目的：将 ref 对象关联到 input 对应的 DOM 对象上 */&#125;
      &lt;input type=&quot;text&quot; placeholder=&quot;请输入内容&quot; ref=&#123;inputRef&#125; /&gt;
      &lt;button onClick=&#123;add&#125;&gt;添加&lt;/button&gt;
    &lt;/section&gt;
  )
&#125;

export default App
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>参数：在获取 DOM 时，一般都设置为 null（获取 DOM 对象时，如果拿不到 DOM 对象，此时，获取到的值就是 null）<ul>
<li>因为关联原生 DOM 是在渲染后</li>
</ul>
</li>
<li>返回值：包含 current 属性的对象。</li>
<li>注意：只要在 React 中进行 DOM 操作，都可以通过 useRef Hook 来获取 DOM（比如，获取 DOM 的宽高等）</li>
<li>注意：useRef 不仅仅可以用于操作DOM，还可以操作组件（关联一个 React 组件）</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>route和router 的区别是什么</title>
    <url>/blog/2020/12/21/route%E5%92%8Crouter%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="route和router-的区别是什么"><a href="#route和router-的区别是什么" class="headerlink" title="route和router 的区别是什么"></a>route和router 的区别是什么</h2><p><strong>route</strong> 是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name 等路由<br>            信息参数</p>
<p><strong>router</strong> 为VueRouter 的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，<br>            例如history 对象，经常用的跳转链接就可以用this.router.push 会往history 栈中添加一个新的记<br>            录。返回上一个history 也是使用$router.go 方法</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>react-Redux</title>
    <url>/blog/2021/12/13/react-Redux/</url>
    <content><![CDATA[<h1 id="react-Redux"><a href="#react-Redux" class="headerlink" title="react-Redux"></a>react-Redux</h1><p>为什么要用 Redux?</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/with-redux.png" style="width: 800px" />

<ul>
<li>主要的区别：<strong>组件之间的通讯问题</strong></li>
<li>不使用 Redux (图左边) ：<ul>
<li>只能使用父子组件通讯、状态提升等 React 自带机制 </li>
<li>处理远房亲戚(非父子)关系的组件通讯时乏力</li>
<li>组件之间的数据流混乱，出现 Bug 时难定位</li>
</ul>
</li>
<li>使用 Redux (图右边)：<ul>
<li><strong>集中式存储和管理应用的状态</strong></li>
<li>处理组件通讯问题时，<strong>无视组件之间的层级关系</strong> </li>
<li>简化大型复杂应用中组件之间的通讯问题</li>
<li>数据流清晰，易于定位 Bug</li>
</ul>
</li>
</ul>
<h2 id="Redux-开发环境准备"><a href="#Redux-开发环境准备" class="headerlink" title="Redux 开发环境准备"></a>Redux 开发环境准备</h2><p><strong>内容：</strong></p>
<p>使用 React CLI 来创建项目，并安装 Redux 包即可：</p>
<ol>
<li><p>创建 React 项目：<code>npx create-react-app redux-basic</code></p>
</li>
<li><p>启动项目：<code>npm start</code> </p>
</li>
<li><p>安装 Redux 包：<code>npm i redux</code></p>
</li>
</ol>
<h2 id="Redux-核心概念-概述"><a href="#Redux-核心概念-概述" class="headerlink" title="Redux 核心概念-概述"></a>Redux 核心概念-概述</h2><p><strong>内容：</strong></p>
<p>在 Redux 的设计中，数据管理的实现，主要被分成了三个概念，分别是：</p>
<p><code>action</code> ，<code>reducer</code> ，<code>store</code></p>
<ul>
<li><p><strong>action</strong>（动作）：描述要做的事情</p>
</li>
<li><p><strong>reducer</strong>（函数）：更新状态</p>
</li>
<li><p><strong>store</strong>（仓库）：整合 action 和 reducer</p>
</li>
</ul>
<h2 id="Redux核心概念-action"><a href="#Redux核心概念-action" class="headerlink" title="Redux核心概念-action"></a>Redux核心概念-action</h2><p><strong>内容：</strong></p>
<p>action 行动（名词）、动作</p>
<p>action：描述要做的事情，对应于项目中的一次数据变化的操作，比如，</p>
<ul>
<li>计数器案例：计数器加1、减1</li>
<li>购物车案例：获取购物车数据、切换商品选中状态</li>
<li>项目：登录，退出等（token数据的保存删除）</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>只描述做什么</li>
<li>是一个 JS 对象，必须带有 <code>type</code> 属性，用于区分动作的类型（你要干啥）</li>
<li>根据完成功能的不同，通过<code>payload</code> 属性携带额外的数据（我要打印，把纸带上）</li>
</ul>
<pre><code class="js">// action

// 计数器案例
&#123; type： &#39;increment&#39; &#125; // +1
&#123; type： &#39;decrement&#39; &#125; // -1

&#123; type： &#39;increment&#39;, payload: 10 &#125; // +10
&#123; type： &#39;decrement&#39;, payload: 10 &#125; // -10

// 购物车案例
&#123; type: &#39;getGoodsList&#39; &#125;
&#123; type: &#39;changeGoodsState&#39;, payload: &#123; id: 1, goodsState: true &#125; &#125;
</code></pre>
<h2 id="Redux核心概念-action-creator"><a href="#Redux核心概念-action-creator" class="headerlink" title="Redux核心概念-action creator"></a>Redux核心概念-action creator</h2><p><strong>方法：</strong>：</p>
<ul>
<li>使用函数创建 action 对象，这种用来创建 action 的函数称之为<code>Action Creator</code></li>
</ul>
<p><strong>核心代码</strong>：</p>
<pre><code class="js">// 不使用 Action Creator
// 创建多个 action 时，需要重复手动创建 action 对象，很繁琐
&#123; type: &#39;decrement&#39;, payload: 2 &#125;
&#123; type: &#39;decrement&#39;, payload: 8 &#125;

// ---

// 使用 Action Creator
// 1 先创建 Action Creator 函数
const decrement = payload =&gt; &#123;
  return &#123; type: &#39;decrement&#39;, payload &#125;
&#125;

// 2 创建多个 action，只需要调用 Action Creator 函数即可
decrement(2) // =&gt; &#123; type: &#39;decrement&#39;, payload: 2 &#125;
decrement(8) // =&gt; &#123; type: &#39;decrement&#39;, payload: 8 &#125;

// 简化：
const decrement = payload =&gt; (&#123; type: &#39;decrement&#39;, payload &#125;)
</code></pre>
<hr>
<h2 id="Redux核心概念-reducer"><a href="#Redux核心概念-reducer" class="headerlink" title="Redux核心概念-reducer"></a>Redux核心概念-reducer</h2><p><strong>介绍：</strong></p>
<ul>
<li>reducer 来自于一个大数据的处理概念 MapReduce 中的 <code>Reduce-规约</code> </li>
<li>一个<code>Reduce-规约</code> 的具体实现叫 Reducer。是一个数据处理器，基于当前数据，处理输出一个新的数据，这个新的数据作为数据处理器下次处理数据的输入。依次不停的迭代下去的一种数据处理机制。</li>
<li>reducer 它是一个<strong>纯函数</strong>。接收两个参数：<strong>action（要干啥），和一个给定的状态</strong> 计算出一个新的状态。这个新的状态作为 reducer 下次处理数据（接收到action通知）的输入。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><p>函数签名为：<code>(state, action) =&gt; newState</code></p>
</li>
<li><p>接收一个的状态（数据）和 action 作为参数，根据 action 的类型，执行对应操作，返回一个新的状态（数据）</p>
</li>
<li><p>注意：<strong>该函数一定要有返回值</strong>，如果没有对应 action 的处理，则返回原来的状态。</p>
</li>
<li><p>约定：reducer 函数内不要直接修改参数 state 的值，而是根据当前状态 state 创建新的状态值。</p>
<pre><code class="js">// 当前 state 是一个对象
let state = &#123;name: &#39;Jack&#39;, age: 18&#125;
// 新状态要求将年龄修改为20
// 正确的做法：
let newState = &#123;...state, age: 20&#125;
// 错误的做法：
state.age = 20
let newState = state

// 同理数组
</code></pre>
</li>
</ul>
<p><strong>核心代码</strong>：</p>
<pre><code class="jsx">// 伪代码：
// state 传入的状态（当前）
// action 当前要执行的动作
const reducer = (state, action) =&gt; &#123;
  return newState
&#125;

// 示例：
// state 传入的状态
// action 当前要执行的动作
const reducer = (state, action) =&gt; &#123;
  switch (action.type) &#123;
    // 计数器增加
    case &#39;increment&#39;:
      // 返回新状态
      // return state + 1
      // 根据 action 中提供的 payload 来决定到底增加多少
      return state + action.payload
    // 注意：一定要有 default，如果将来 reducer 无法处理某个 action，就直接将原来的状态返回即可
    default:
      return state
  &#125;
&#125;

// 模拟 reducer 的调用
// 第一次调用 reducer
// reducer(0, &#123; type: &#39;increment&#39; &#125;) // 本次执行完成后，状态变为：1
// 再调用，会基于上一次调用处理后的state值处理
// reducer(1, &#123; type: &#39;increment&#39; &#125;) // 本次执行完成后，状态变为：2

// 基于传入的状态继续调用 reducer
// reducer(1, &#123; type: &#39;decrement&#39; &#125;) // 本次因为无法处理该 action，所以，直接返回原来的状态：1
</code></pre>
<h2 id="Redux核心概念-store"><a href="#Redux核心概念-store" class="headerlink" title="Redux核心概念-store"></a>Redux核心概念-store</h2><p><strong>Store：</strong></p>
<ul>
<li><p>创建 store 实例</p>
<ul>
<li><pre><code class="jsx">// 导入redux
import &#123; createStore &#125; from &#39;redux&#39;

// 创建 store, 参数为：reducer 函数(需要一个干活的)
const store = createStore(reducer)
</code></pre>
</li>
</ul>
</li>
<li><p>store 分发 action 修改数据（叫人干活）</p>
<ul>
<li><pre><code class="jsx">// 直接分发一个action
store.dispatch( &#123;type: &#39;increment&#39;, payload: 2&#125; )
// 调用action creator 返回一个action
store.dispatch( increment(2) )
</code></pre>
</li>
</ul>
</li>
<li><p>获取 store 中的状态</p>
<ul>
<li><pre><code class="jsx">// 获取状态（干完活，取成果）
const state = store.getState()
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="Redux代码执行流程"><a href="#Redux代码执行流程" class="headerlink" title="Redux代码执行流程"></a>Redux代码执行流程</h2><p><strong>流程</strong>：</p>
<ol>
<li>创建 store 时，Redux 就会先调用一次 reducer，给开发者设置 state 初始值的机会。</li>
<li>store 创建完毕后，调用 <code>store.dispatch(action) </code>  修改 state。</li>
<li>store 接收到 action 后，执行 reducer 函数，计算出新的state。</li>
<li>这个新的state是基于我们初始化的state的值，和 action 传来的 payload 计算出的。</li>
<li>调用 <code>store.getState()</code>获取 reducer 中存储的 state。这个 state 是下一次 action 到来之前最新的。</li>
</ol>
<h2 id="React-Redux介绍"><a href="#React-Redux介绍" class="headerlink" title="React-Redux介绍"></a>React-Redux介绍</h2><p><strong>说明：</strong></p>
<p>Redux 库实现的是一种数据管理模式，和UI界面库是没有关系的。</p>
<p>所以要想在React中使用Redux管理数据，就需要一个<strong>“中介”</strong>，将Redux中管理的数据注入到React组件中。</p>
<p>实现这个连接注入功能的库就是 “React-Redux”。</p>
<p><strong>内容</strong>：</p>
<p>文档：<a class="link"   href="https://react-redux.js.org/introduction/getting-started" >https://react-redux.js.org/introduction/getting-started<i class="fas fa-external-link-alt"></i></a></p>
<p>react-redux 的使用分为两大步：</p>
<ul>
<li>1 全局配置（只需要配置一次） </li>
<li>2 组件接入（获取状态或修改状态）是按需接入，有状态管理需求的组件接入。</li>
</ul>
<p><strong>全局配置步骤：</strong></p>
<ol>
<li>安装 react-redux：<code>npm i react-redux</code></li>
<li>从 react-redux 中导入 Provider 组件</li>
<li>创建 store 实例</li>
<li>使用 Provider 包裹整个应用</li>
<li>通过Provider 的 store 属性，将创建好的store实例注入的组件中</li>
</ol>
<h2 id="React-Redux-获取状态-useSelector"><a href="#React-Redux-获取状态-useSelector" class="headerlink" title="React-Redux-获取状态-useSelector"></a>React-Redux-获取状态-useSelector</h2><p><strong>说明：</strong></p>
<p>凡是被配 <code>&lt;Provider store=&#123;store&#125; /&gt;</code> 包裹的组件，都可以通过<code>useSelector</code>  这个 react-redux 提供的 hooks 函数，将 redux 中存储的状态数据，引入到组件中。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>导入 <code>useSelector</code></p>
<ul>
<li><pre><code class="jsx">import &#123; useSelector &#125; from &#39;react-redux&#39;
</code></pre>
</li>
</ul>
</li>
<li><p>调用 <code>useSelector</code> 函数，需要传入一个回调函数， <code>useSelector</code> 在调用这个回调函数的时候会把 state 作为形参传递给回调函数。 回调函数执行完毕后的返回值将作为  <code>useSelector</code> 的返回值返回。</p>
<ul>
<li><pre><code class="jsx">useSelector(state =&gt; state)
</code></pre>
</li>
</ul>
</li>
<li><p>定义变量接收这个返回值，在组件中就获取到了 store 中存储的数据</p>
<ul>
<li><pre><code class="jsx">const count = useSelector(state =&gt; state)
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="React-Redux-分发动作useDispatch"><a href="#React-Redux-分发动作useDispatch" class="headerlink" title="React-Redux-分发动作useDispatch"></a>React-Redux-分发动作useDispatch</h2><p><strong>说明：</strong></p>
<p>如何在 React 组件中分发 action</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>导入  <code>useDispatch</code></p>
<ul>
<li><pre><code class="jsx">import &#123; useDispatch &#125; from &#39;react-redux&#39;
</code></pre>
</li>
</ul>
</li>
<li><p>调用 <code>useDispatch</code> 获得 <code>dispatch</code> 函数</p>
<ul>
<li><pre><code class="jsx">const dispatch = useDispatch()
</code></pre>
</li>
</ul>
</li>
<li><p>调用  <code>dispatch</code> 分发 action</p>
<ul>
<li><pre><code class="jsx">dispatch( action )
</code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>Redux</tag>
        <tag>react-Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react-组件</title>
    <url>/blog/2021/09/11/react-%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="react-组件"><a href="#react-组件" class="headerlink" title="react-组件"></a>react-组件</h1><p>在 React 中，组件概念是由两部分组成，分别是：</p>
<ul>
<li><p>定义规则</p>
<ul>
<li>定义一个函数的规则。</li>
<li>定义一个类（class）的规则。</li>
</ul>
</li>
<li><p>使用规则</p>
<ul>
<li>如何使用这个函数或类（class）的规则。</li>
</ul>
</li>
</ul>
<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>顾名思义，就是以定义一个函数，满足特定规则的函数。</p>
<p><strong>定义规则：</strong></p>
<ul>
<li>符合 JS 的函数定义(函数定义、函数表达式、箭头函数)    </li>
<li><strong>函数名称必须以大写字母开头</strong>（React 以此区分组件和普通的 HTML标签，对应组件的使用规则）</li>
<li><strong>函数组件必须有返回值</strong>，表示该组件的 UI 结构。如果不需要渲染任何内容，则返回 <code>null</code></li>
</ul>
<p><strong>代码：</strong></p>
<pre><code class="jsx">// 函数定义组件
function Hello() &#123;
  return &lt;div&gt;我是函数定义组件&lt;/div&gt;
&#125;
// 函数表达式组件
const Button = function () &#123;
  return &lt;button&gt;我是函数表达式组件&lt;/button&gt;
&#125;

// 箭头函数组件
const Hello = () =&gt; &lt;div&gt;我是箭头函数组件&lt;/div&gt;
</code></pre>
<p><strong>使用规则：</strong></p>
<ul>
<li>使用函数名称作为组件标签名称，就是把函数名写在标签里即可<code>&lt;组件名（函数名）/&gt;</code> <code>&lt;Hello/&gt;</code> <code>&lt;Button/&gt;</code></li>
<li>交给<code>ReactDOM.render(&lt;组件名（函数名）/&gt;)</code>渲染即可。</li>
</ul>
<p>代码：</p>
<pre><code class="jsx">// 使用 双标签形式 渲染组件：
ReactDOM.render(&lt;Hello&gt;&lt;/Hello&gt;, document.getElementById(&#39;root&#39;))

// 使用 自闭和标签形式 渲染组件：
ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#39;root&#39;))
</code></pre>
<h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>顾名思义，就是定一个类，满足特定规则的类。</p>
<p><strong>定义规则：</strong></p>
<ul>
<li>符合 ES6 的 class 定义</li>
<li><strong>类名称必须以大写字母开头</strong>（React 以此区分组件和普通的 HTML标签，对应组件的使用规则）</li>
<li>类组件应该继承 React.Component 父类，从而可以使用父类中提供的方法或属性 </li>
<li>类组件必须提供 render 方法</li>
<li>render 方法必须有返回值，表示该组件的 UI 结构。如果不需要渲染任何内容，则返回 <code>null</code></li>
</ul>
<p><strong>代码：</strong></p>
<pre><code class="jsx">// 导入 React
import React from &#39;react&#39;

class Hello extends React.Component &#123;
  render() &#123;
    return &lt;div&gt;Hello Class Component!&lt;/div&gt; 
  &#125;
&#125;


// 解构导入 Component 的方式
import &#123; Component &#125; from &#39;react&#39;

class Hello extends Component &#123;
  render() &#123;
    return &lt;div&gt;Hello Class Component!&lt;/div&gt; 
  &#125;
&#125;
</code></pre>
<p><strong>使用规则：</strong></p>
<ul>
<li>使用类名称作为组件标签名称，就是把类名写在标签里即可<code>&lt;类名/&gt;</code>。</li>
</ul>
<h2 id="React-组件-事件处理"><a href="#React-组件-事件处理" class="headerlink" title="React 组件-事件处理"></a>React 组件-事件处理</h2><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>因为 JSX 语法的原因，就是我们的标签和 JS 代码在一起，所以React中事件处理函数绑定与 HTML 元素的属性事件绑定的语法非常像。</p>
<p>标签的属性事件绑定：</p>
<pre><code class="html">&lt;button onclick=&quot;btnClickHandler()&quot;&gt;
    按钮
&lt;/button&gt;
</code></pre>
<p>React中的事件绑定：</p>
<pre><code class="jsx">&lt;button onClick=&#123;btnClickHandler&#125;&gt;
  按钮
&lt;/button&gt;
</code></pre>
<p>不同点：</p>
<ul>
<li>React 事件采用驼峰命名法，比如 <code>onClick</code>，其它同理 <code>onMouseEnter</code> <code>onBlur</code> 等等</li>
<li>React 中传入的是一个 function 对象，而不是字符串</li>
</ul>
<p>那这个传入的 function 在 React 组件中是如何定义的呢？</p>
<p>接下来我们就分别来看一下。</p>
<p><strong>1-函数组件：</strong></p>
<pre><code class="jsx">// 1、匿名箭头函数形式
function App () &#123;
  return(
    &lt;div&gt;
        &lt;button onClick=&#123;() =&gt; console.log(&#39;按钮被点击了&#39;)&#125;&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
  )
&#125;
export default App


// 2、函数定义形式
function App () &#123;
    function handleClick()&#123;
    console.log(&#39;按钮被点击了&#39;)
  &#125;
  return(
    &lt;div&gt;
        &lt;button onClick=&#123;handleClick&#125;&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
  )
&#125;
export default App


// 具名箭头函数形式
const App = () =&gt; &#123;
  const handleClick = () =&gt; &#123;
    console.log(&#39;按钮被点击了&#39;)
  &#125;
  return(
    &lt;div&gt;
      &lt;button onClick=&#123;handleClick&#125;&gt;按钮2&lt;/button&gt;
    &lt;/div&gt;
  )
&#125;
export default App
</code></pre>
<p><strong>2-类组件：</strong></p>
<pre><code class="jsx">import React from &#39;react&#39;

// 匿名箭头函数
class App extends React.Component &#123;
  
  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;() =&gt; cosole.log(&#39;按钮被点击了&#39;)&#125;&gt;按钮&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

// 类的原型方法
class App extends React.Component &#123;
  // 事件处理函数
  handleClick() &#123;
    console.log(&#39;按钮被点击了&#39;)
  &#125;
  
  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
export default App
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li><p>类组件绑定事件处理函数的时候，需要通过this引用事件处理函数，并传递给 DOM 元素。而函数组件中则不需要这样做。</p>
</li>
<li><p>背后的原因是类组件需要一个实例化的过程，在类中这个具体的实例化对象是通过 this 代表的。</p>
</li>
<li><p>而函数组件是没有实例化过程的，直接函数运行返回对应的UI ，即我们的 React 元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-组件</tag>
      </tags>
  </entry>
  <entry>
    <title>react-组件通讯</title>
    <url>/blog/2021/10/20/react-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h1 id="react-组件通讯"><a href="#react-组件通讯" class="headerlink" title="react-组件通讯"></a>react-组件通讯</h1><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>还是基于一下几点来理解</p>
<ol>
<li>确定组件关系：即谁是父组件？</li>
<li>组件间通讯数据来自于哪里？（state、props）</li>
<li>通讯的数据类型是什么？</li>
</ol>
<p><strong>步骤：</strong></p>
<ul>
<li><p>确定组件的父子关系，父组件可以直接传递数据到子组件</p>
</li>
<li><p>父组件可以传递给子组件的数据：</p>
<ul>
<li>父组件 state 中定义的数据（父组件私有的、父组件自身的）</li>
<li>父组件 props 中的数据（父组件的父组件传递进来的）</li>
</ul>
</li>
<li><p>传递数据可以是：string, array, number, bool, object, function, jsx 等</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code class="jsx">import React from &#39;react&#39;;

class Parent extends React.Component &#123;
  state = &#123;
    lastName: &#39;王&#39;,
  &#125;;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;div&gt;我是父组件，我姓：&#123;this.state.lastName&#125;&lt;/div&gt;
        &lt;div&gt;我继承了：&#123;this.props.money&#125;块&lt;/div&gt;
        &lt;Child lastName=&#123;this.state.lastName&#125; /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

class Child extends React.Component &#123;
  render() &#123;
    return (
      // 显示父组件传递的数据
      &lt;div&gt;
        &lt;hr /&gt;
        &lt;div&gt;我是子组件,我姓&#123;this.props.lastName&#125;&lt;/div&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default Parent;
</code></pre>
<h4 id="父传子练习"><a href="#父传子练习" class="headerlink" title="父传子练习"></a>父传子练习</h4><p><strong>目标：</strong>能够通过父到子组件通讯实现该案例效果</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/demo-父到子.png" style="width: 600px; zoom: 60%;" />

<p><strong>步骤：</strong></p>
<ul>
<li>定义父组件、父组件数据</li>
<li>将数据传递到子组件</li>
<li>子组件渲染数据</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code class="jsx">// 父组件数据
state = &#123;
  list: [
    &#123;
      id: 1,
      name: &#39;超级好吃的棒棒糖&#39;,
      price: 18.8,
      info: &#39;开业大酬宾，全场8折&#39;,
    &#125;,
    &#123;
      id: 2,
      name: &#39;超级好吃的大鸡腿&#39;,
      price: 34.2,
      info: &#39;开业大酬宾，全场8折&#39;,
    &#125;,
    &#123;
      id: 3,
      name: &#39;超级无敌的冰激凌&#39;,
      price: 14.2,
      info: &#39;开业大酬宾，全场8折&#39;,
    &#125;,
  ],
&#125;;

// 父组件UI结构
render() &#123;
  return (
    // 父组件
    &lt;div className=&quot;parent&quot;&gt;
      &lt;h1&gt;父组件&lt;/h1&gt;
      &#123;/* 把下面UI抽离为子组件 */&#125;
      &lt;div className=&quot;child&quot;&gt;
        &lt;div className=&quot;product&quot;&gt;
          &lt;h3&gt;标题：&lt;/h3&gt;
          &lt;div&gt;价格：&lt;/div&gt;
          &lt;div&gt;开业大酬宾&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<p><strong>组件样式：</strong></p>
<pre><code class="css">.parent &#123;
  width: 80%;
  padding: 10px;
  border: 2px solid black;
&#125;
.child &#123;
  margin: 10px 0;
  padding: 10px;
  border: 2px solid skyblue;
&#125;
.product &#123;
  padding: 20px;
  border: 2px solid #000;
  border-radius: 5px;
  margin: 10px;
&#125;
</code></pre>
<p><strong>总结：</strong></p>
<p>抽离子组件时，是抽离成函数组件还是类组件？</p>
<p>一般规则：如果子组件子负责显示则抽离成函数组件，如果子组件还要自身的状态管理需求，则抽离为类组件。</p>
<p>实际开发中，一律类组件开头，因为后期类组件改函数组件代码变动小，函数组件改为类组件代码变动大</p>
<hr>
<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>还是基于以下几点来理解</p>
<ol>
<li>确定组件关系：即谁是父组件？谁是子？</li>
<li>组件间通讯数据来自于哪里？（state、props）</li>
<li>通讯的数据类型是什么？</li>
</ol>
<p><strong>思路</strong>：</p>
<p>父组件传递一个函数给子组件，子组件调用这个函数。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>父组件提供一个回调函数，供子组件调用</li>
<li>将该函数，传递给子组件</li>
<li>子组件调用这个函数</li>
<li>父组件就会执行这个函数，函数参数就是子组件调用时指定的参数</li>
<li>这样就实现了子组件向父组件传递数据</li>
</ol>
<p><strong>案例：</strong></p>
<p>实现一个子组件向父组件要钱的案例</p>
<p><strong>核心代码</strong>：</p>
<pre><code class="jsx">import React from &#39;react&#39;;

class Parent extends React.Component &#123;
  state = &#123;
    lastName: &#39;王&#39;,
    money: 100,
  &#125;;

  // 回调函数
  giveMoney = (money) =&gt; &#123;
    this.setState(&#123;
      money: money,
    &#125;);
  &#125;;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;div&gt;我是父组件，我姓：&#123;this.state.lastName&#125;&lt;/div&gt;
        &lt;div&gt;我继承了：&#123;this.props.money&#125;块&lt;/div&gt;
        &lt;Child
          lastName=&#123;this.state.lastName&#125;
          money=&#123;this.state.money&#125;
          giveMoney=&#123;this.giveMoney&#125;
        /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

class Child extends React.Component &#123;
  handleClick = () =&gt; &#123;
    // 子组件调用父组件传递过来的回调函数
    this.props.giveMoney(300);
  &#125;;
  render() &#123;
    return (
      // 显示父组件传递的数据
      &lt;div&gt;
        &lt;hr /&gt;
        &lt;div&gt;我是子组件,我姓&#123;this.props.lastName&#125;&lt;/div&gt;
        &lt;div&gt;我收到的：&#123;this.props.money&#125;&lt;/div&gt;
        &lt;button onClick=&#123;this.handleClick&#125;&gt;giveMoney&lt;/button&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;

export default Parent;
</code></pre>
<p><strong>总结</strong>：</p>
<ol>
<li><p>父组件如何接收子组件传递过来的数据？ 回调函数的参数</p>
</li>
<li><p>子组件如何传递数据给父组件？ 调用回调时传入参数</p>
</li>
<li><p>父组件拿到子组件传递的消息后，可以通过修改 state 触发组件重新渲染，来实现类似收到子组件消息后回复子组件消息的需求</p>
</li>
</ol>
<hr>
<h4 id="子传父练习"><a href="#子传父练习" class="headerlink" title="子传父练习"></a>子传父练习</h4><img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/demo-子到父.png" alt="demo-子到父" style="zoom:50%;" />



<p><strong>步骤：</strong></p>
<ul>
<li>在子组件渲染时添加一个砍价按钮。</li>
<li>父组件定义砍价函数并传递给子组件</li>
<li>这个砍价按钮点击时，调用父组件提供的函数，将砍价信息传回给父组件</li>
<li>父组件修改列表数据，页面重新渲染</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code class="jsx">// 父组件定义一个函数
kan = (id, money) =&gt; &#123;
  console.log(&#39;砍了&#39;, money);
  const newList = this.state.list.map((item) =&gt; &#123;
    if (item.id === id) &#123;
      return &#123; ...item, price: parseFloat((item.price - 1).toFixed(2)) &#125;;
    &#125; else &#123;
      return item;
    &#125;
  &#125;);
  console.log(newList);
  this.setState(&#123;
    list: newList,
  &#125;);
&#125;;

// 将这个函数传递到子组件
&#123;this.state.list.map((item) =&gt; (
  &lt;Child item=&#123;item&#125; key=&#123;item.id&#125; kan=&#123;this.kan&#125; /&gt;
))&#125;

// 子组件调用这个函数
clickHandler = (id) =&gt; &#123;
  console.log(&#39;开始砍&#39;, id);
  this.props.kan(id, 1);
&#125;;
</code></pre>
<h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><p>还是基于以下几点来理解</p>
<ol>
<li><p>确定组件关系：即谁是兄组件？谁是弟组件？</p>
</li>
<li><p>组件间通讯数据来自于哪里？（state、props）</p>
</li>
<li><p>通讯的数据类型是什么？</p>
</li>
<li><p>谁给谁发消息，兄&#x3D;&gt;弟，还是，弟&#x3D;&gt;兄</p>
</li>
</ol>
<p>什么是兄弟组件？</p>
<p>平级关系组件，有前后关系，但是没有上下关系。</p>
<pre><code class="jsx">render() &#123;
  return (
    // 父组件
    &lt;div className=&quot;parent&quot;&gt;
      &lt;Child1 name=&#123;&quot;大毛&quot;&#125; /&gt;
      &lt;Child2 name=&#123;&quot;二毛&quot;&#125; /&gt;
    &lt;/div&gt;
  );
&#125;
</code></pre>
<p>兄弟组件通讯，是父到子和子到父通讯的结合使用，父组件是中介。</p>
<p><strong>实现思想：状态提升</strong></p>
<ul>
<li>提供一个数据存储中介，这个中介就是离兄弟组件最近的公共父组件中的 state 。</li>
<li>在公共的父组件中：<ol>
<li>定义共享状态数据（定义在 state 中，用来接收子组件中发送过来的数据，通过调用 setState 发送给准备接收数据的子组件） </li>
<li>定义操作共享状态数据的函数（用来传递给兄弟组件，准备发送数据的组件）</li>
</ol>
</li>
</ul>
<p>状态提升前</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/image-20211016171150589.png" style="width: 800px; zoom: 67%;" />

<p>状态提升之后</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/image-20211016171158651.png" style="width: 800px; zoom: 67%;" />

<p><strong>核心代码</strong></p>
<ul>
<li><code>App.js</code></li>
</ul>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;
import &#39;./App.css&#39;;

// 导入两个子组件
import Child1 from &#39;./Child1&#39;;
import Child2 from &#39;./Child2&#39;;

// App 是父组件
export default class App extends Component &#123;
  state = &#123;
    // 数据中介（状态提升到父组件）
    msg: &#39;&#39;,
  &#125;;

  // 消息传递工具
  setMsg = (msg) =&gt; &#123;
    console.log(msg);
    this.setState(&#123;
      msg: msg,
    &#125;);
  &#125;;

  render() &#123;
    return (
      &lt;div className=&quot;app&quot;&gt;
        &lt;h1&gt;我是App（爹）组件&lt;/h1&gt;
        &#123;/* 兄弟组件1，接收消息 */&#125;
        &lt;Child1 msg=&#123;this.state.msg&#125;&gt;&lt;/Child1&gt;
        &#123;/* 兄弟组件2，发送消息 */&#125;
        &lt;Child2 setMsg=&#123;this.setMsg&#125;&gt;&lt;/Child2&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<ul>
<li><code>Child1.js</code></li>
</ul>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;

export default class Child1 extends Component &#123;
  render() &#123;
    return (
      &lt;div className=&quot;child1&quot;&gt;
        &#123;/* 接收消息 */&#125;
        &lt;h3&gt;我是Child1（哥）组件&lt;/h3&gt;
        &lt;div&gt;我弟说&#123;this.props.msg&#125;&lt;/div&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<ul>
<li><code>Child2.js</code></li>
</ul>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;

export default class Child2 extends Component &#123;
  clickHandler = () =&gt; &#123;
    this.props.setMsg(&#39;弟弟挨打了&#39;);
  &#125;;

  render() &#123;
    return (
      &lt;div className=&quot;child2&quot;&gt;
        &lt;h3&gt;我是Child2（弟）组件&lt;/h3&gt;
        &#123;/* 发送消息 */&#125;
        &lt;button onClick=&#123;this.clickHandler&#125;&gt;说：我挨打了&lt;/button&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<p><strong>总结：</strong></p>
<p>“状态提升”这种设计思想除了用在兄弟组件之间传递数据，还有一个经典应用场景是，若干组件都需要对同样的数据改变作出响应。</p>
<hr>
<h3 id="跨组件通讯"><a href="#跨组件通讯" class="headerlink" title="跨组件通讯"></a>跨组件通讯</h3><p>当出现组件传递数据需要跨越多个组件这种需求时，状态提升，父传子实现就效率比较低了。</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/props层层传递.png" style="width: 800px; zoom: 80%;" />



<p>为了解决这种数组件跨越层级较多的数据传递需求，React 提供了跨组件通讯的 API，就是：<strong>createContext</strong> 。</p>
<img src="D:/前端_资料/就业班/react/React-基础/React-基础/01-笔记/01-笔记/images/跨组件传递.png" style="width: 800px; zoom: 70%;" />



<p>Context 上下文，可以理解一个范围，只要在这个范围内，就可以直接跨组件传递数据。</p>
<p>步骤：</p>
<ul>
<li><p>调用 React.createContext() 创建 Provider（提供数据） 和 Consumer（消费数据） 两个组件</p>
<ul>
<li><pre><code class="jsx">const &#123; Provider, Consumer &#125; = React.createContext()
</code></pre>
</li>
</ul>
</li>
<li><p>使用 Provider 组件作为父节点（范围包裹节点），并设置 value 属性，表示要传递的数据</p>
<ul>
<li><pre><code class="jsx">&lt;Provider value=&#123;&quot;pink&quot;&#125;&gt;
    &lt;div className=&quot;App&quot;&gt;
        &lt;Child1 /&gt;
    &lt;/div&gt;
&lt;/Provider&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>调用 Consumer 组件消费（接收）数据（组件内定义一个函数，函数的形参就是Provider中 value属性的值）</p>
<ul>
<li><pre><code class="jsx">&lt;Consumer&gt;
    &#123;value =&gt; &lt;span&gt;value参数表示接收到的数据：&#123;value&#125;&lt;/span&gt;&#125;
&lt;/Consumer&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;;
import &#39;./App.css&#39;;

const ThemeContext = React.createContext();

const Node = () =&gt; (
  &lt;div className=&quot;node&quot;&gt;
    Node
    &lt;SubNode /&gt;
  &lt;/div&gt;
);
const SubNode = () =&gt; (
  &lt;div className=&quot;sub-node&quot;&gt;
    SubNode
    &lt;Child /&gt;
  &lt;/div&gt;
);

const Child = () =&gt; (
  &lt;div className=&quot;child&quot;&gt;
    Child
    &lt;ThemeContext.Consumer&gt;
      &#123;(value) =&gt; &lt;div style=&#123;&#123; color: value &#125;&#125;&gt;xxx&lt;/div&gt;&#125;
    &lt;/ThemeContext.Consumer&gt;
  &lt;/div&gt;
);

export default class App extends Component &#123;
  render() &#123;
    return (
      &lt;ThemeContext.Provider value=&#123;&#39;red&#39;&#125;&gt;
        &lt;div className=&quot;app&quot;&gt;
          &lt;h1&gt;我是App组件&lt;/h1&gt;
          &lt;Node /&gt;
        &lt;/div&gt;
      &lt;/ThemeContext.Provider&gt;
    );
  &#125;
&#125;
</code></pre>
<p>说明：</p>
<p>跨组件传值，也可以传 JSX、传函数</p>
<pre><code class="jsx">// &lt;ThemeContext.Provider value=&#123;&lt;h1&gt;跨组件传递的标签&lt;/h1&gt;&#125;&gt;
&lt;ThemeContext.Provider value=&#123;() =&gt; &lt;h1&gt;跨组件传递的标签&lt;/h1&gt;&#125;&gt;
  &lt;div className=&quot;parent&quot;&gt;
    &lt;h1&gt;父组件&lt;/h1&gt;
    &lt;Child1 /&gt;
  &lt;/div&gt;
&lt;/ThemeContext.Provider&gt;

&lt;ThemeContext.Consumer&gt;
  &#123;/* &#123;(value) =&gt; &lt;div&gt;&#123;value&#125;&lt;/div&gt;&#125; */&#125;
  &#123;(value) =&gt; &lt;div&gt;&#123;value()&#125;&lt;/div&gt;&#125; 
&lt;/ThemeContext.Consumer&gt;
</code></pre>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-组件通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>style 上加scoped 属性的原理</title>
    <url>/blog/2021/05/06/style%20%E4%B8%8A%E5%8A%A0scoped%20%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="style-上加scoped-属性的原理"><a href="#style-上加scoped-属性的原理" class="headerlink" title="style 上加scoped 属性的原理"></a>style 上加scoped 属性的原理</h2><p><strong>1、什么是scoped</strong><br>        在Vue 组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style 标签上添加scoped 属性以表示它的只属于当下的模块，局部有效。如果一个项目中的所有vue 组件style 标签全部加上了scoped，相当于实现了样式的私有化。如果引用了第三方组件，需要在当前组件中局部修改第三方组件的样式，而又不想去除scoped 属性造成组件之间的样式污染。此时只能通过穿透scoped 的方式来解决，选择器。<br><strong>2、scoped 的实现原理</strong></p>
<p>Vue 中的scoped 属性的效果主要通过PostCSS 转译实现，如下是转译前的Vue 代码：</p>
<pre><code class="vue">&lt;template&gt;&lt;div&gt;Vue.js scoped&lt;/div&gt;&lt;/template&gt;
&lt;style scoped&gt;.scoped &#123;font-size:14px;&#125;&lt;/style&gt;
</code></pre>
<p>浏览器渲染后的代码</p>
<pre><code class="vue">&lt;div data-v-fed36922&gt;Vue.js scoped&lt;/div&gt;
.scoped[data-v-fed36922]&#123;font-size:14px;&#125;
</code></pre>
<p>说明：PostCSS 给所有dom 添加了一个唯一不重复的动态属性，然后，给CSS 选择器额外添加一个<br>对应的属性选择器来选择该组件中dom，这种做法使得样式私有化</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>v-show和v-if指令的共同点和不同点</title>
    <url>/blog/2020/08/11/v-show%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9/</url>
    <content><![CDATA[<h2 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="headerlink" title="v-show和v-if指令的共同点和不同点"></a>v-show和v-if指令的共同点和不同点</h2><p> <strong>一，相同点：</strong></p>
<p>两者都是控制元素的显示和隐藏，</p>
<p>初始值都是false</p>
<p><strong>二，不同点：</strong></p>
<p>​    <strong>1，实现本质方法本质不同</strong></p>
<ul>
<li><p>v-show本质就是通过设置css中的display设置为none,控制隐藏</p>
</li>
<li><p>v-if是动态向DOM树添加和删除DOM元素</p>
</li>
</ul>
<p>​    <strong>2，编译的区别</strong></p>
<ul>
<li><p>v-show 就是控制CSS</p>
</li>
<li><p>v-if 切换有一个局部编译和卸载的过程，切换过程中合适地销毁和重建内部事件</p>
</li>
</ul>
<p>​    <strong>3，编译的条件</strong></p>
<ul>
<li><p>v-show 会编译，但是只编译一次，后面其实就是控制css，注意点：当css本身就有dislpay：none时，v-show无法显示</p>
</li>
<li><p>v-if 就不会编译，就是不停的销毁和创建</p>
</li>
</ul>
<p>​    <strong>4，总结使用场景</strong></p>
<p>​        如果要频繁切换某节点时，使用v-show(无论是true还是false初始值都会进行渲染，因此通过css来控制显示隐藏，因此切换开销比较小，初始值开销比较大)，如果不需要频繁切换某个节点时，使用v-if（因此懒加载，初始值为false时，不会渲染，但是因为它是通过添加和删除dom元素来控制显示和隐藏的，因此初始渲染开销比较小，切换开销比较大）</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>v-if</tag>
        <tag>v-show</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的key值的作用是什么</title>
    <url>/blog/2020/08/28/vue%E4%B8%AD%E7%9A%84key%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="vue中的key值的作用是什么"><a href="#vue中的key值的作用是什么" class="headerlink" title="vue中的key值的作用是什么"></a>vue中的key值的作用是什么</h2><p>当Vue.js 用v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据<br>项的顺序被改变，Vue 将不会移动DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元<br>素，并且确保它在特定索引下显示已被渲染过的每个元素，key 的作用主要是为了高效的更新虚<br>拟DOM（增强diff算法）</p>
<pre><code class="vue">diff算法
两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。
同一层级的一组节点，他们可以通过唯一的id进行区分。
当页面的数据发生变化时，diff算法只会比较同一成次的节点：

如果节点类型不同，直接干掉前面的节点，在创建并插入新的节点，不会再比较这个节点以后的子节点了
如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新
当某一层有很多相同的节点时，也就是列节点时，diff算法的更新过程默认的遵循以上原则
所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>key</tag>
      </tags>
  </entry>
  <entry>
    <title>vue和react区别</title>
    <url>/blog/2020/06/10/vue%E5%92%8Creact%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="vue和react区别"><a href="#vue和react区别" class="headerlink" title="vue和react区别"></a>vue和react区别</h1><h2 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a><strong>共同点：</strong></h2><p><strong>Vue和React存在着很多的共同点：</strong></p>
<ul>
<li><strong>数据驱动视图</strong></li>
<li><strong>组件化</strong></li>
<li><strong>都使用 Virtual DOM</strong></li>
</ul>
<ol>
<li><p><strong>数据驱动视图</strong><br>在jquery时代，我们需要频繁的操作DOM来实现页面效果与交互；而Vue和React 解决了这一痛点，采用数据驱动视图方式，隐藏操作DOM的频繁操作。所以我们在开发时，只需要关注数据变化即可，但是二者实现方式不尽相同。</p>
</li>
<li><p><strong>组件化</strong><br>React与Vue都遵循组件化思想，它们把注意力放在UI层，将页面分成一些细块，这些块就是组件，组件之间的组合嵌套就形成最后的网页界面。</p>
</li>
</ol>
<p>所以在开发时都有相同的套路，比如都有父子组件传递， 都有数据状态管理、前端路由、插槽等。</p>
<ol start="3">
<li><strong>Virtual DOM</strong><br>Vue与React都使用了 Virtual DOM + Diff算法， 不管是Vue的Template模板+options api 写法， 还是React的Class或者Function写法,最后都是生成render函数，而render函数执行返回VNode(虚拟DOM的数据结构，本质上是棵树)。</li>
</ol>
<p>当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM（虚拟DOM是JS对象结构，同样在JS引擎中，而真实DOM在浏览器渲染引擎中，所以操作虚拟DOM比操作真实DOM开销要小的多）</p>
<h2 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><strong>不同点：</strong></h2><p><strong>1.核心思想不同</strong><br>Vue早期开发就尤雨溪大佬，所以定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。这就有了vue的主要特点：灵活易用的渐进式框架，进行数据拦截&#x2F;代理，它对侦测数据的变化更敏感、更精确。</p>
<p>React 从一开始的定位就是提出 UI 开发的新思路。背靠大公司Facebook 的React，从开始起就不缺关注和用户，而且React想要做的是用更好的方式去颠覆前端开发方式。所以React推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助onChange和setState来实现。</p>
<p><strong>2.组件写法差异</strong><br>React推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js; Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue也支持JSX写法)</p>
<p>这个差异一定程度上也是由于二者核心思想不同而导致的。</p>
<p><strong>3.响应式原理不同</strong><br>Vue</p>
<ul>
<li><p>Vue依赖收集，自动优化，数据可变。</p>
</li>
<li><p>Vue递归监听data的所有属性,直接修改。</p>
</li>
<li><p>当数据改变时，自动找到引用组件重新渲染。</p>
</li>
</ul>
<p>React</p>
<ul>
<li>React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的slot的使用方法</title>
    <url>/blog/2020/07/13/vue%E4%B8%AD%E7%9A%84slot%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="vue中的slot的使用方法"><a href="#vue中的slot的使用方法" class="headerlink" title="vue中的slot的使用方法"></a>vue中的slot的使用方法</h2><p><strong>个人理解：</strong><br>是对组件的扩展，通过slot插槽向组件内部指定位置传递内容，通过slot可以父子传参；<br>正常情况下,<Child><span style="color:red;">hello world</span></Child>在组件标签Child中的span标签会被组件模板template内容替换掉，当想让组件标签Child中内容传递给组件时需要使用slot插槽；</p>
<p><strong>Slot的通俗理解</strong></p>
<p>是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中<slot>位置），当插槽也就是坑&lt;slot name&#x3D; ” mySlot ” &gt;有命名时，组件标签中使用属性slot&#x3D; ” mySlot ” 的元素就会替换该对应位置内容；</p>
<p>Slot使用</p>
<p>1、（匿名插槽）组件中有单个或多个未命名slot标签时，如下：</p>
<pre><code class="vue">&lt;Child&gt;hello world&lt;/Child&gt;   
&lt;template&gt;    

      &lt;div&gt;

        &lt;slot&gt;&lt;/slot&gt;

        &lt;slot  style=&quot;color:blue;&quot; &gt;这是在slot上添加了样式&lt;/slot&gt;

        &lt;slot  name=&quot;mySlot&quot;&gt;这是拥有命名的slot的默认内容&lt;/slot&gt;

    &lt;/div&gt;

&lt;/template&gt;
</code></pre>
<p>会输出：两个红色的hello world，以及一个使用slot的默认内容</p>
<p>注意：在slot标签添加样式无效。拥有命名的插槽不能被不含slot属性的标签内容替换，会显示slot的默认值（具名slot具有对应性）；</p>
<p>2、 （具名插槽） 组件中有多个命名的slot 插槽时，可以实现父组件对子组件的指定位置显示内容或传参，如下：</p>
<pre><code class="vue">&lt;Child&gt;

    hello world

    hello world

    hello world

    &#123;&#123;otherData&#125;&#125;

&lt;/Child&gt;

 

&lt;template&gt;

    &lt;div&gt;

        &lt;slot  name=&quot;header&quot;&gt;这是拥有命名的slot的默认内容&lt;/slot&gt;

        &lt;slot  name=&quot;main&quot;&gt;这是拥有命名的slot的默认内容&lt;/slot&gt;

        &lt;slot  name=&quot;footer&quot;&gt;这是拥有命名的slot的默认内容&lt;/slot&gt;

        &lt;slot  name=&quot;other&quot;&gt;这是拥有命名的slot的默认内容&lt;/slot&gt;

    &lt;/div&gt;

&lt;/template&gt;
</code></pre>
<p>3、作用域插槽！！：<br>使用时候子组件标签<Child>中要有<template slot-scope=”scopeName”>标签，再通过scopeName.childProp就可以调用子组件模板中的childProp绑定的数据，所以作用域插槽是一种子传父传参的方式，解决了普通slot在parent中无法访问child数据的去问题；</p>
<p>作用域插槽代表性的用例是列表组件，允许在parent父组件上对列表项进行自定义显示，如下该items的所有列表项都可以通过slot定义后传递给父组件使用，也就是说数据是相同的，不同的场景页面可以有不同的展示方式：</p>
   <ul>

<pre><code class="vue">&lt;ul&gt;
   &lt;slot name=&quot;item&quot; v-for=&quot;item in items&quot; :text=&quot;item.text&quot; :myname=&quot;item.myname&quot; &gt;
      slot的默认内容
   &lt;/slot&gt;
&lt;/ul&gt;
 
&lt;Child&gt;
  &lt;template slot=&quot;item&quot; slot-scope=&quot;props&quot;&gt;
    &lt;li&gt;&#123;undefined&#123;props.myname&#125;&#125;&lt;/li&gt;
  &lt;/template&gt;
&lt;/Child&gt;
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-slot</tag>
      </tags>
  </entry>
  <entry>
    <title>vue常用的指令</title>
    <url>/blog/2020/07/27/vue%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="vue常用的指令"><a href="#vue常用的指令" class="headerlink" title="vue常用的指令"></a>vue常用的指令</h2><pre><code class="vue"> v-model=&#39;xx&#39;：一般是用在表单元素上，input框内容发生改变，所有用到这个变量的地方都会自动更新
     v-text=&#39;xx&#39;：相当于 innerText，不能识别结构
     v-html=&#39;xx&#39;：相当于 innerHTML，能识别结构
 v-cloak：专门用来提供解决小胡子的显示问题，需要搭配css使用
          当vue编译完成之后，会把这个属性删掉，这是css样式就不起作用了
 v-once：有这个指令的标签只会编译一次，后期数据再变，它也不会变
 v-pre：有这个指令的标签及其后代元素，vue都不做处理（不经过vue处理），可以用来提升vue的编译效率

 v-if=&#39;true/false&#39;：控制元素或者组件是否加载，有比较大的切换开销
 v-else：跟 v-if 或者 v-eles-if 搭配只用，且中间不能插入其他无关标签或者组件
 v-show=true/false：用来控制元素或者组件显示不显示（控制diaplay的属性），有比较大的初始加载开销

 v-for=&#39;xx in yy&#39;：用来循环的，可以循环数组、数字、字符串、对象等。与v-if同时使用的时候，v-for的优先级要高于v-if的
    key 对vue来说，是元素的身份标识，有利于vue的diff计算
    key 在同一个for中不能重复。同一个页面或组件中想要使用相同的key值，那么key值所处的v-for不能为兄弟元素

 v-bind:prop=&#39;value&#39;：用来处理行内属性的一个指令，简写是一个冒号 :
    行内属性中 class 和 style 是经常操作的属性，所以vue对这两个属性专门做了加强
    :class=&#39;&#123;类名1：布尔值，类名2：布尔值，...&#125;&#39; 只有值为true的类才会加上
    :style=&quot;&#123;css属性名:css属性值&#125;&quot;

 v-on:事件名=&#39;方法名&#39;：专门用来绑定事件的指令，简写是：@
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue数据双向绑定原理</title>
    <url>/blog/2020/06/15/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="vue数据双向绑定原理"><a href="#vue数据双向绑定原理" class="headerlink" title="vue数据双向绑定原理"></a>vue数据双向绑定原理</h1><p><strong>一、原理：</strong><br>1.vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；</p>
<p>2.核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法；</p>
<p>3.介绍一下Object.defineProperty()方法<br>（1）Object.defineProperty(obj, prop, descriptor) ，这个语法内有三个参数，分别为 obj （要定义其上属性的对象） prop （要定义或修改的属性） descriptor （具体的改变方法）<br>（2）简单地说，就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法，当我们给这个属性赋值时，又用到了它里面的set方法；</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/blog/2020/06/22/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><h2 id="生命周期的三个阶段"><a href="#生命周期的三个阶段" class="headerlink" title="生命周期的三个阶段"></a>生命周期的三个阶段</h2><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化阶段、运行中阶段、销毁阶段。</p>
<p><strong>初始化阶段钩子函数</strong>（beforeCreate,created,beforeMount,mounted）<br><strong>运行中阶段钩子函数</strong>（beforeUpdate,updated）<br><strong>销毁阶段钩子函数</strong>（beforeDestroy,destroyed）<br>一个组件或者实例的生命周期都是通过new开始的<br><img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/20171026193015421.5oaajcp224k0.webp"></p>
<h2 id="生命周期各阶段说明"><a href="#生命周期各阶段说明" class="headerlink" title="生命周期各阶段说明"></a>生命周期各阶段说明</h2><p>beforeCreate () {} 创建实例以前, 此时的 DOM 还是语法, data 内的数据还没有</p>
<p>created () {} 创建实例以后, 此时 DOM 还是语法, data 内已经有数据了</p>
<p>beforeMount () {} 挂载以前, 渲染页面以前, 此时 DOM 还是语法, data 内已经有数据了</p>
<p>mounted () {} 挂载以后, 渲染页面以后, 此时 DOM 正常了, data 内的数据正常</p>
<p>beforeUpdate () {} 更新以前, 该组件内容修改之前, data 内的数据是修改前的数据</p>
<p>undated () {} 更新以后, 该组件内容修改之后, data 内的数据就是修改后的数据</p>
<p>beforeDestroy () {} 销毁前, 当你需要销毁该组件的时候, 销毁之前使用</p>
<p>destroyed () {} 销毁后, 组件完全销毁完毕</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue，vue生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件中的data必须是函数</title>
    <url>/blog/2020/07/05/vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="vue组件中的data必须是函数"><a href="#vue组件中的data必须是函数" class="headerlink" title="vue组件中的data必须是函数"></a>vue组件中的data必须是函数</h2><p>类比引用数据类型<br>Object是引用数据类型,如果不用function 返回,每个组件的data 都是<a class="link"   href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020" >内存<i class="fas fa-external-link-alt"></i></a>的同一个地址,一个数据改变了其他也改变了;</p>
<p>javascipt只有函数构成<a class="link"   href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020" >作用域<i class="fas fa-external-link-alt"></i></a>(注意理解作用域,只有<code>函数的&#123;&#125;</code>构成作用域,<code>对象的&#123;&#125;</code>以及 <code>if()&#123;&#125;</code>都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响</p>
<pre><code class="js">const MyComponent = function() &#123;&#125;;
MyComponent.prototype.data = &#123;
    a: 1,
    b: 2,
&#125;
const component1 = new MyComponent();
const component2 = new MyComponent();
 
component1.data.a === component2.data.a; // true;
component1.data.b = 5;
component2.data.b // 5
</code></pre>
<p>如果两个实例同时引用一个对象,那么当你修改其中一个属性的时候,另外一个实例也会跟着改;</p>
<p>两个实例应该有自己各自的域才对,需要通过下面的方法来进行处理</p>
<pre><code class="js">const MyComponent = function() &#123;
　　this.data = this.data();
&#125;;
MyComponent.prototype.data = function() &#123;
　　return &#123;
　　　　a: 1,
　　　　b: 2,
　　&#125;
&#125;;
var c1=new MyComponent();
var c2=new MyComponent();
c2.data.a=5;
console.log(c1.data);//&#123; a: 1, b: 2 &#125;
console.log(c2.data);//&#123; a: 5, b: 2 &#125;
</code></pre>
<p>这样么一个实例的data属性都是独立的,不会相互影响了.</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-data</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件之间传值</title>
    <url>/blog/2020/06/29/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h1 id="vue组件之间传值"><a href="#vue组件之间传值" class="headerlink" title="vue组件之间传值"></a>vue组件之间传值</h1><p><strong>1、父组件向子组件传递数据</strong><br>        父组件内设置要传的数据，在父组件中引用的子组件上绑定一个自定义属性并把数据<br>        绑定在自定义属性上，在子组件添加参数props 接收即可<br><strong>2、子组件向父组件传递数据</strong><br>        子组件通过vue 实例方法$emit 进行触发并且可以携带参数，父组件监听使用@（v-on）<br>        进行监听，然后进行方法处理<br><strong>3、非父子组件之间传递数据</strong></p>
<p>​        3.1 引入第三方new vue 定义为eventBus</p>
<p>​        3.2）在组件中created 中订阅方法eventBus.$on(“自定义事件名”,methods 中的方法名)</p>
<p>​        3.3) 在另一个兄弟组件中的methods 中写函数，在函数中发布eventBus 订阅的方法eventBus.$emit(“自定义事件名”)</p>
<p>​        3.4) 在组件的template 中绑定事件(比如click)</p>
<p><strong>4、使用依赖注入</strong></p>
<p>​        父组件根据<strong>provide</strong>进行设置，子组件根据<strong>inject</strong>来获取值进行使用</p>
<p>​        <strong>缺点：</strong>太灵活，不受管制</p>
<p><strong>5、使用vuex进行组件之间的通信</strong></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue，vue组件传值</tag>
      </tags>
  </entry>
  <entry>
    <title>watch、methods、computed的区边</title>
    <url>/blog/2020/08/19/watch%E3%80%81methods%E3%80%81computed%E7%9A%84%E5%8C%BA%E8%BE%B9/</url>
    <content><![CDATA[<h2 id="watch、methods、computed的区边"><a href="#watch、methods、computed的区边" class="headerlink" title="watch、methods、computed的区边"></a>watch、methods、computed的区边</h2><p><strong>methods</strong></p>
<p>中定义的是具体的方法，根据一些特定的触发条件，调用一次执行一次，每次调用都需重新加载没有缓存，比如说点击事件</p>
<p><strong>computed</strong></p>
<p>computed是vue中独有的计算属性，它是基于数据，然后进行依赖后进行缓存的，只有依赖发生改变，才会重新计算<br>就算在data中没有直接声明出要计算的变量，也可以在computed中写入<br>计算属性默认只有getter 需要的时候可以自己设置setter方法 setter默认传递一个参数，这个参数就是当前对象</p>
<p><strong>watch</strong></p>
<p>watch的作用是监听一个值的变化，并调用因变化需要执行的方法。<br>它用于观察vue实例上的数据变动，对应一个对象，键是表达观察式，值是回调，也可以是方法名，或者一个对象。</p>
<p>数据量大，需要缓存使用computed，每次都需要加载不需要缓存使用methods<br>computed 和 watch 都可以观察页面的数据变化。computed的依赖是多个的，watch的依赖只能是单个的</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>watch</tag>
        <tag>methods</tag>
        <tag>computed</tag>
      </tags>
  </entry>
</search>
