<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/blog/2019/12/07/hello-world/</url>
    <content><![CDATA[<!-- category 文章分类 -->
<!-- tag 文章标签 -->

<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM-获取DOM元素、修改属性</title>
    <url>/blog/2020/01/16/DOM-%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E3%80%81%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="·DOM-获取-DOM-元素、修改属性"><a href="#·DOM-获取-DOM-元素、修改属性" class="headerlink" title="·DOM-获取 DOM 元素、修改属性"></a>·DOM-获取 DOM 元素、修改属性</h1><h1 id="一、Web-API-的基本认识"><a href="#一、Web-API-的基本认识" class="headerlink" title="一、Web API 的基本认识"></a>一、Web API 的基本认识</h1><h2 id="1、作用和分类"><a href="#1、作用和分类" class="headerlink" title="1、作用和分类"></a>1、作用和分类</h2><p>​ <strong>作用:</strong> 就是使用 JS 去操作 html 和浏览器</p>
<p>​ <strong>分类：</strong>DOM (文档对象模型)、BOM（浏览器对象模型）</p>
<h2 id="2、什么是-DOM"><a href="#2、什么是-DOM" class="headerlink" title="2、什么是 DOM"></a>2、什么是 DOM</h2><p>​ <strong>DOM</strong>（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 文档交互的 API</p>
<p>​ <strong>白话文：</strong>DOM 是浏览器提供的一套专门用来 <strong>操作**<strong>网页*</strong>*内容</strong> 的功能</p>
<p>​ <strong>DOM 作用:</strong> 开发网页内容特效和实现用户交互</p>
<h2 id="3、DOM-树"><a href="#3、DOM-树" class="headerlink" title="3、DOM 树"></a>3、DOM 树</h2><p><strong>lDOM 树是什么</strong>?</p>
<p>​ a：将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树</p>
<p>​ b：描述网页内容关系的名词</p>
<p>​ c：作用：文档树直观的体现了标签与标签之间的关系</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.ev61ukot49s.webp">

<h2 id="4、DOM-对象"><a href="#4、DOM-对象" class="headerlink" title="4、DOM 对象"></a>4、DOM 对象</h2><p><strong>lDOM 对象：浏览器根据 html 标签生成的 JS 对象</strong></p>
<ol>
<li>所有的标签属性都可以在这个对象上面找到</li>
<li>修改这个对象的属性会自动映射到标签身上</li>
</ol>
<p><strong>lDOM 的核心思想</strong></p>
<ol>
<li>把网页内容当做对象来处理</li>
</ol>
<p><strong>ldocument 对象</strong></p>
<ol>
<li><p>是 DOM 里提供的一个<strong>对象</strong></p>
</li>
<li><p>所以它提供的属性和方法都是<strong>用来访问和操作网页内容的</strong></p>
</li>
<li><p>网页所有内容都在 document 里面</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/2.39cbhcf08220.webp"></li>
</ol>
<h1 id="二、获取-DOM-对象"><a href="#二、获取-DOM-对象" class="headerlink" title="二、获取 DOM 对象"></a>二、获取 DOM 对象</h1><h2 id="1、根据-CSS-选择器来获取-DOM-元素"><a href="#1、根据-CSS-选择器来获取-DOM-元素" class="headerlink" title="1、根据 CSS 选择器来获取 DOM 元素"></a>1、根据 CSS 选择器来获取 DOM 元素</h2><h3 id="1-1-选择匹配的第一个元素"><a href="#1-1-选择匹配的第一个元素" class="headerlink" title="1.1 选择匹配的第一个元素"></a><strong>1.1 选择匹配的第一个元素</strong></h3><p><strong>语法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/3.6vdlcn8lhg00.webp">

<p><strong>参数</strong></p>
<ol>
<li>包含一个或多个有效的 CSS 选择器 <strong>字符串</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>CSS 选择器匹配的第一个元素,一个 HTMLElement 对象。</li>
<li>如果没有匹配到，则返回 null。</li>
</ol>
<h3 id="1-2-选择匹配的多个元素"><a href="#1-2-选择匹配的多个元素" class="headerlink" title="1.2 选择匹配的多个元素"></a><strong>1.2 选择匹配的多个元素</strong></h3><p><strong>语法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/4.1585wrbzbtts.webp">

<p><strong>参数</strong></p>
<ol>
<li>包含一个或多个有效的 CSS 选择器 <strong>字符串</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>CSS 选择器匹配的 NodeList 对象集合</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>该方法得到的是一个<strong>伪数组</strong>：</li>
<li>有长度有索引号的数组</li>
<li>但是没有 pop() push() 等数组方法</li>
<li>想要得到里面的每一个对象，则需要遍历（for）的方式获得。</li>
</ul>
<p><strong>例如：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/3-1.2k59o0n4a2g0.webp">

<h3 id="1-3-其他获取-DOM-元素方法"><a href="#1-3-其他获取-DOM-元素方法" class="headerlink" title="1.3 其他获取 DOM 元素方法"></a>1.3 其他获取 DOM 元素方法</h3><img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/5.5rwr9qe1ass0.webp">

<h1 id="三、设置-x2F-修改-DOM-元素内容"><a href="#三、设置-x2F-修改-DOM-元素内容" class="headerlink" title="三、设置&#x2F;修改 DOM 元素内容"></a>三、设置&#x2F;修改 DOM 元素内容</h1><h2 id="1、设置-x2F-修改-DOM-元素内容"><a href="#1、设置-x2F-修改-DOM-元素内容" class="headerlink" title="1、设置&#x2F;修改 DOM 元素内容"></a>1、设置&#x2F;修改 DOM 元素内容</h2><h3 id="1-1document-write"><a href="#1-1document-write" class="headerlink" title="1.1document.write()"></a>1.1document.write()</h3><ul>
<li>只能将文本内容追加到 </body> 前面的位置</li>
<li>文本中包含的标签会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-1.69swq3hv2qc0.webp">

<h3 id="1-2-元素-innerText-属性"><a href="#1-2-元素-innerText-属性" class="headerlink" title="1.2 元素 innerText 属性"></a>1.2 元素 innerText 属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>文本中包含的标签不会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-2.5wxmw3vy4fw0.webp">

<h3 id="1-3-元素-innerHTML-属性"><a href="#1-3-元素-innerHTML-属性" class="headerlink" title="1.3 元素 innerHTML 属性"></a>1.3 元素 innerHTML 属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>文本中包含的标签会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-3.4y46t382rhc0.webp">

<h1 id="四、设置-x2F-修改-DOM-元素属性"><a href="#四、设置-x2F-修改-DOM-元素属性" class="headerlink" title="四、设置&#x2F;修改 DOM 元素属性"></a>四、设置&#x2F;修改 DOM 元素属性</h1><h3 id="1-设置-x2F-修改元素常用属性"><a href="#1-设置-x2F-修改元素常用属性" class="headerlink" title="1. 设置&#x2F;修改元素常用属性"></a><strong>1.</strong> <strong>设置&#x2F;修改元素常用属性</strong></h3><ul>
<li>还可以通过 JS 设置&#x2F;修改标签元素属性，比如通过 src 更换 图片</li>
<li>最常见的属性比如： href、title、src 等</li>
</ul>
<pre><code class="js">语法：
对象.属性 = 值
</code></pre>
<h3 id="2-设置-x2F-修改元素样式属性"><a href="#2-设置-x2F-修改元素样式属性" class="headerlink" title="2.设置&#x2F;修改元素样式属性"></a>2.设置&#x2F;修改元素<strong>样式</strong>属性</h3><p><strong>方法：</strong></p>
<ul>
<li>通过 style 属性操作 CSS</li>
<li>操作类名(className) 操作 CSS</li>
<li>通过 classList 操作类控制 CSS</li>
</ul>
<h3 id="3-通过-设置-style-属性操作-CSS"><a href="#3-通过-设置-style-属性操作-CSS" class="headerlink" title="3.通过 设置 style 属性操作 CSS"></a>3.通过 设置 style 属性操作 CSS</h3><pre><code class="js">语法：
对象.style.样式属性 = 值
</code></pre>
<h3 id="4-操作类名-className-操作-CSS"><a href="#4-操作类名-className-操作-CSS" class="headerlink" title="4.操作类名(className) 操作 CSS"></a>4.操作类名(className) 操作 CSS</h3><p>说明：如果修改的样式比较多，直接通过 style 属性修改比较繁琐，我们可以通过借助于 css 类名的形式。</p>
<pre><code class="js">语法：
元素.className = &#39;active&#39;   // active是一个类名
</code></pre>
<p><strong>注意：</strong></p>
<p>1.由于 class 是关键字, 所以使用 className 去代替</p>
<p>2.className 是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名</p>
<h3 id="5-通过-classList-操作类控制-CSS"><a href="#5-通过-classList-操作类控制-CSS" class="headerlink" title="5.通过( classList) 操作类控制 CSS"></a>5.通过( classList) 操作类控制 CSS</h3><p>说明：为了解决 className 容易覆盖以前的类名，我们可以通过 classList 方式追加和删除类名</p>
<pre><code class="js">语法：
//  追加一个类
元素.classList.add(&#39;类名&#39;)
//  删除一个类
元素.classList.remove(&#39;类名&#39;)
//  切换一个类
元素.classList.toggle(&#39;类名&#39;)
</code></pre>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>className</tag>
        <tag>classList</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环语法|数组|对象</title>
    <url>/blog/2019/12/23/for-%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h1><h3 id="语法结构："><a href="#语法结构：" class="headerlink" title="语法结构："></a>语法结构：</h3><pre><code class="tex">for（循环条件初始化；循环条件判断；循环迭代）&#123;
  循环体；
&#125;
</code></pre>
<h3 id="执行规则："><a href="#执行规则：" class="headerlink" title="执行规则："></a>执行规则：</h3><pre><code class="tex">第一步：循环条件的初始化（只在最开始执行一次）
第二步：循环条件判断
1》若判断条件结果为真：则执行循环体；
2》若不成立：结束循环；
第三步：循环迭代
第四步：回到第二步
</code></pre>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><h4 id="1、打印-5-行-5-列的星星"><a href="#1、打印-5-行-5-列的星星" class="headerlink" title="1、打印 5 行 5 列的星星"></a>1、打印 5 行 5 列的星星</h4><pre><code class="js">//  打印5行5列的星星

let star = &#39;&#39;
for (var i = 0; i &lt; 5; i++) &#123;
  for (var j = 0; j &lt; 5; j++) &#123;
    star += &#39;*&#39;
  &#125;
  star += &#39;\n&#39;
&#125;
console.log(star)
</code></pre>
<h4 id="2、打印三角形星星"><a href="#2、打印三角形星星" class="headerlink" title="2、打印三角形星星"></a>2、打印三角形星星</h4><pre><code class="js">//  打印三角形星星

let num = Number(prompt(&#39;请输入行数：&#39;))
// 正五角
// for (let i = 1; i &lt;= num; i++) &#123;
//     for (let j = 1; j &lt;= i; j++) &#123;
//         document.write(&#39;⭐&#39;)
//     &#125;
//     document.write(&#39;&lt;br&gt;&#39;)
// &#125;

// 倒五角
for (let i = 1; i &lt;= num; i++) &#123;
  for (let j = i; j &lt;= num; j++) &#123;
    document.write(&#39;⭐&#39;)
  &#125;
  document.write(&#39;&lt;br&gt;&#39;)
&#125;
</code></pre>
<h4 id="3、乘法表"><a href="#3、乘法表" class="headerlink" title="3、乘法表"></a>3、乘法表</h4><pre><code class="js">//  乘法表

let num = Number(prompt(&#39;请输入一个数字：&#39;))
// for (let i = 1; i &lt;= num; i++) &#123;
//     for (let j = 1; j &lt;= i; j++) &#123;
//         document.write(`$&#123;j&#125; x $&#123;i&#125; = $&#123;i * j&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`);
//     &#125;
//     document.write(&#39;&lt;br&gt;&lt;br&gt;&#39;)
// &#125;

for (let i = 1; i &lt;= num; i++) &#123;
  for (let j = i; j &lt;= 9; j++) &#123;
    document.write(`&lt;span&gt;$&#123;i&#125; x $&#123;j&#125; = $&#123;i * j&#125;&lt;/span&gt;`)
  &#125;
  document.write(&#39;&lt;br&gt;&lt;br&gt;&#39;)
&#125;
</code></pre>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1.数组的创建"></a>1.数组的创建</h2><p>1） 字面量创建</p>
<pre><code class="js">let arr = [1, true, &#39;zhaimin&#39;, [1, 2]]

let Arr2 = [, ,] //undefined,undefined
</code></pre>
<p>2）利用 array 构造器创建数组</p>
<pre><code class="js">let arr = new Array()
</code></pre>
<h2 id="2-遍历数组"><a href="#2-遍历数组" class="headerlink" title="2.遍历数组"></a>2.遍历数组</h2><pre><code class="js">let arr = [1, 2, 3, 4, 5, 6]
for (var i = 0; i &lt; arr.length; i++) &#123;
  console.log(arr[i])
&#125;

// 1 2 3 4 5 6
</code></pre>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h2><p>1）字面量创建</p>
<pre><code class="js">let obj = &#123;
  name: &#39;我是一个对象&#39;,
  age: 21
&#125;
</code></pre>
<p>2）使用 Object 构造器创建对象</p>
<pre><code class="js">let obj = new Object()
</code></pre>
<p>3）使用构造函数创建对象</p>
<pre><code class="js">function Obj(name,age)&#123;
    this.name = name
    this.age = age
&#125;

// 创建构造函数
const fn = new Obj(&#39;小红&#39;,21)
console.log(fn);  &#123; name:&#39;小红&#39;,age:21 &#125;
</code></pre>
<h2 id="2-使用-for…in-遍历对象"><a href="#2-使用-for…in-遍历对象" class="headerlink" title="2.使用 for…in 遍历对象"></a>2.使用 for…in 遍历对象</h2><pre><code class="js">let obj = &#123; a: 1, b: 2 &#125;
for (let i in obj) &#123;
  console(&#39;key:&#39; + i + &#39;, value:&#39; + obj[i])
&#125;
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>for</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM-事件基础</title>
    <url>/blog/2020/01/06/DOM-%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="DOM-事件基础"><a href="#DOM-事件基础" class="headerlink" title="DOM-事件基础"></a>DOM-事件基础</h1><h2 id="一、事件"><a href="#一、事件" class="headerlink" title="一、事件"></a>一、事件</h2><p><strong>什么是事件？</strong></p>
<ul>
<li>事件是在编程时系统内发生的<strong>动作</strong>或者发生的事情</li>
<li>比如用户在网页上<strong>单击</strong>一个按钮</li>
</ul>
<p><strong>什么是事件监听？</strong></p>
<ul>
<li>​ 就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code class="js">//  之前的语法
// 注意：该方法对同一个dom元素使用时，只能绑定一个事件，若绑定多个则后者覆盖前者
元素.onclick = function()&#123;逻辑代码&#125;

//  es6语法
// 注意：该方法可以给同一个dom元素绑定多个事件，之间互不影响
元素.addEventListener(&#39;事件&#39;，要执行的函数)
</code></pre>
<p><strong>事件监听三要素：</strong></p>
<ul>
<li><strong>事件源：</strong> 那个 dom 元素被事件触发了，要获取 dom 元素</li>
<li><strong>事件：</strong> 用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等</li>
<li><strong>事件调用的函数</strong>： 要做什么事</li>
</ul>
<p><strong>举例说明：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/11.2qxr6165m0e0.webp">

<p><strong>注意：</strong></p>
<p>1.事件类型要加引号</p>
<p>2.函数是点击之后再去执行，每次点击都会执行一次</p>
<h2 id="二、高阶函数"><a href="#二、高阶函数" class="headerlink" title="二、高阶函数"></a>二、高阶函数</h2><p>说明：可以被简单理解为函数的高级应用，JavaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用。</p>
<h3 id="1-函数表达式"><a href="#1-函数表达式" class="headerlink" title="1.函数表达式"></a>1.函数表达式</h3><p>函数表达式和普通函数并无本质上的区别：</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648398044(1).41nbmi30vqq0.webp">

<p><strong>注意 ：</strong></p>
<ul>
<li>普通函数的声明与调用无顺序限制，推荐做法先声明再调用</li>
<li><strong>函数表达式必须要先声明再调用</strong></li>
</ul>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>把函数当做另外一个函数的参数传递，这个函数就叫回调函数</p>
<p>回调函数本质还是函数，只不过把它当成参数使用</p>
<p>使用匿名函数做为回调函数比较常见</p>
<p>例如：</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/xx.50hr5m42gyo0.webp">

<h2 id="三、编程思想"><a href="#三、编程思想" class="headerlink" title="三、编程思想"></a>三、编程思想</h2><p><strong>说明：</strong>当前元素为 A 状态,其他元素为 B 状态</p>
<p><strong>使用：</strong></p>
<ol>
<li><p>干掉所有人</p>
<pre><code>使用for循环
</code></pre>
</li>
<li><p>复活他自己</p>
<pre><code>通过this或者下标找到自己或者对应的元素
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的变量和数据类型</title>
    <url>/blog/2019/12/08/js%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JavaScript-的变量和数据类型"><a href="#JavaScript-的变量和数据类型" class="headerlink" title="JavaScript 的变量和数据类型"></a>JavaScript 的变量和数据类型</h1><h2 id="1-变量的含义和存储"><a href="#1-变量的含义和存储" class="headerlink" title="1.变量的含义和存储"></a>1.变量的含义和存储</h2><p>变量就是用来存放数据的容器，可以通过变量名获取数据，也可以修改数据；</p>
<p>在内存中存储的本质：变量是程序在内存中申请的一块用来存放数据的空间；</p>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><p>变量的声明：使用 var 或者 let (ES6 语法) 进行声明<br>var 声明的变量会进行变量提升（可以先使用，后定义）<br>let 声明的变量不会变量提升（先定义，后使用）</p>
<p>变量的命名规范：</p>
<p>1.由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成， 2.严格区分大小写。 3.不能 以数字开头。 4.不能 是关键字。 5.变量名必须有意义。 6.遵守驼峰命名法。首字母小写，后面单词的首字母需要大写</p>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h3 id="3-1-数据类型的种类"><a href="#3-1-数据类型的种类" class="headerlink" title="3.1 数据类型的种类"></a>3.1 数据类型的种类</h3><h4 id="1-简单的数据类型："><a href="#1-简单的数据类型：" class="headerlink" title="1.简单的数据类型："></a>1.简单的数据类型：</h4><p>Number: 数字型，包含整型和浮点型；</p>
<p>String：字符串类型（用引号引起来）；</p>
<p>Boolean：布尔值类型（true 和 false）；</p>
<p>Undefined ：声明一个变量但是未赋值，就是 undefined；</p>
<p>Null：空值；</p>
<h4 id="2-复杂的数据类型：Object"><a href="#2-复杂的数据类型：Object" class="headerlink" title="2.复杂的数据类型：Object"></a>2.复杂的数据类型：Object</h4><pre><code class="js">typeof Object //&quot;function&quot;
typeof typeof Object //string类型
</code></pre>
<p><strong>01.数字型进制：</strong>二进制、八进制、十进制、十六进制</p>
<p>02.数字型的范围：</p>
<p>最大值：(Number.MAX_VALUE)&#x3D;1.7976931348623157e+308；</p>
<p>最小值：（Number.MIN_VALUE)&#x3D;5e-324;</p>
<p>03.三个特殊值：</p>
<p>infinity:无穷大，大于任何值；</p>
<p>-infinity:无穷小，小于任何值；</p>
<p>NaN:Not a number 非数值；</p>
<p>04.判断一个变量是否为非数字类型返回 true 或 false：</p>
<p>isNaN(a):a 是数字返回 false；a 不是数字返回 true</p>
<pre><code class="js">//数字
console.log(3.14) //3.14
//八进制 0-7 数字前边加0表示8进制
console.log(015) //13
//十六进制 0-9 a-f 数字前边加0x 表示十六进制
console.log(0xa) //10
console.log(0x2a) //42
//数字型的最大值和最小值
console.log(Number.MAX_VALUE) //1.7976931348623157e+308
console.log(Number.MIN_VALUE) //5e-324
//无穷大和无穷小 最大值乘以大于1的数就是无穷大，前边加一个负号就是负无穷
console.log(Number.MAX_VALUE * 1.1) // infinity 无穷大
console.log(-Number.MIN_VALUE * 1.1) // -infinity 无穷小
//NaN 非数字
console.log(0 / 0) //NaN
console.log(10 - &#39;a&#39;) //NaN
</code></pre>
<h3 id="3-3-字符串型-String"><a href="#3-3-字符串型-String" class="headerlink" title="3.3 字符串型 String"></a>3.3 字符串型 String</h3><pre><code class="js">typeof string //&quot;undefined&quot;
typeof typeof string //string类型
typeof (10 + &#39;5&#39;) //string
</code></pre>
<p>字符串是引号中的任意文本，用双引号或者单引号；</p>
<p><strong>引号的嵌套</strong>(外双内单，外单内双)：1.单引号嵌套双引号；2.双引号嵌套单引号；</p>
<pre><code class="js">\n :换行符；
\\ :单斜杠\;
\&#39; :&#39;单引号;
\&quot; :” 双引号;
\t :tab缩进；
\b ：空格
</code></pre>
<p><strong>字符串拼接</strong>：</p>
<p>多个字符串之间使用 z：字符串 + 任何类型 &#x3D; 新的字符串；</p>
<p>拼接前会把与字符串相加的任何类型转换成字符串，在拼接一个新的字符串</p>
<pre><code class="js">//Boolean
typeof Boolean //&quot;function&quot;
typeof typeof Boolean //string类型
typeof true //Boolean
typeof false //Boolean
</code></pre>
<h3 id="3-5undefined-和-null"><a href="#3-5undefined-和-null" class="headerlink" title="3.5undefined 和 null"></a>3.5undefined 和 null</h3><pre><code class="js">//null
typeof null //&quot;object&quot;
typeof typeof null //string类型
//undefined
typeof undefined //&quot;undefined&quot;
typeof typeof undefined //string类型
</code></pre>
<p>特殊情况：<br>undefined &gt; 0 false;<br>undefined &lt; 0 false;<br>undefined &#x3D;&#x3D; 0 false;<br>undefined&#x3D;&#x3D;null true;</p>
<p>（1）一个声明后没有被赋值的变量会有一个默认值 undefined;</p>
<p>（2) 调用函数时，应该提供的参数没有提供，为 undefined;</p>
<p>（3）函数没有返回值时，默认返回 undefined;</p>
<p>（4）对象没有赋值的属性，该属性的值为 undefined;</p>
<p>(5)一个声明变量给 null 值，里面存的值为空;</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串引号|do while|while</title>
    <url>/blog/2019/12/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%95%E5%8F%B7-for%E5%90%8C%E7%B1%BB-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="一、字符串引号"><a href="#一、字符串引号" class="headerlink" title="一、字符串引号"></a>一、字符串引号</h1><h2 id="1、类别"><a href="#1、类别" class="headerlink" title="1、类别"></a>1、类别</h2><p>字符串的字面量表达方式——用引号包起来：</p>
<pre><code class="js">单引号（ ‘’）
双引号（ “”）
反引号 ( `` )
</code></pre>
<p>注意事项：</p>
<pre><code class="js">1、无论单引号或是双引号必须成对使用
2、单引号或双引号可以互相嵌套，但是不以自已嵌套自已（口诀：外双内单，或者外单内双）
3、也可以使用转义符 \ 来输出单引号或双引号
</code></pre>
<h1 id="二、for-同类"><a href="#二、for-同类" class="headerlink" title="二、for 同类"></a>二、for 同类</h1><h2 id="1、while-循环"><a href="#1、while-循环" class="headerlink" title="1、while 循环"></a>1、while 循环</h2><p>说明：循环重复执行一段代码，直到某个条件不再满足。<br>结构：</p>
<pre><code class="js">while（条件表达式）&#123;
  只要条件表达式结果为true,循环一直执行，当条件表达式结果为false的时候，循环终止
&#125;
</code></pre>
<p>注意：条件表达式即为判断表达式</p>
<h3 id="案例一-将-1-10-打印到控制台"><a href="#案例一-将-1-10-打印到控制台" class="headerlink" title="案例一 将 1-10 打印到控制台"></a>案例一 <strong>将 1-10 打印到控制台</strong></h3><pre><code class="js">let n1=1;
while(n1&gt;=1 &amp;&amp; n1&lt;=10)&#123;    // n1满足条件
    console.log(n1);       // 若没有n1++，控制台会一直循环1这个数字
    n1++;
// 当代码执行到console.log(n1)；时为1，继续执行到n1++；此时结果为2。然后继续循环这执行 console.log(n1)； // console.log(n1);此时结果为2+1=3，会一直循环执行这两行代码，直到条件不满足条件式 (n1&gt;=1 &amp;&amp; n1&lt;=10)时终止。
</code></pre>
<h3 id="案例二-求-1-到-100-之间的数字和-在控制台输出"><a href="#案例二-求-1-到-100-之间的数字和-在控制台输出" class="headerlink" title="案例二 求 1 到 100 之间的数字和,在控制台输出"></a>案例二 求 1 到 100 之间的数字和,在控制台输出</h3><pre><code class="js">let n1 = 1
let sum = 0
while (n1 &gt;= 1 &amp;&amp; n1 &lt;= 100) &#123;
  sum = sum + n1
  n1++
&#125;
console.log(sum)
</code></pre>
<h3 id="案例二-将-1-100-之间-3-的倍数找出来，在控制台输出"><a href="#案例二-将-1-100-之间-3-的倍数找出来，在控制台输出" class="headerlink" title="案例二 将 1-100 之间 3 的倍数找出来，在控制台输出"></a>案例二 将 1-100 之间 3 的倍数找出来，在控制台输出</h3><pre><code class="js">let n1=1;
while(n1&gt;=1 &amp;&amp; n1&lt;=100)&#123;
    if(n1%3==0)&#123;
        console.log(n1);     当n1=1时不满足条件式if(n1%3==0)，所以不在控制台输出，但是满足主条件式(n1&gt;=1 &amp;&amp; n1&lt;=100)，所以继续执行下面代码n1++;由此循环。
    &#125;else&#123;
    &#125;
    n1++;
&#125;
</code></pre>
<h2 id="2、do-while-循环"><a href="#2、do-while-循环" class="headerlink" title="2、do while 循环"></a>2、do while 循环</h2><p>结构：</p>
<pre><code class="js">do&#123;
    循环体代码，首先这行该循环体代码一次，如果while后面的表达式结果为true,该循环体会一直循环，如果结果为false,该循环体终止。
&#125;while(条件表达式）
</code></pre>
<p>注意：do while 比 while 多循环一次</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="js">let n1 = 1
let n2 = 5
do &#123;
  alert(&#39;n1&gt;n2&#39;) // 循环一次显示的结果
&#125; while (n1 &gt; n2) // while表达式为false,循环终止。
</code></pre>
<h1 id="三、术语解释"><a href="#三、术语解释" class="headerlink" title="三、术语解释"></a>三、术语解释</h1><pre><code class="js">(关键字)
    说明
        在javascript中有特殊意义的词汇
    举例
        let   var   function    if   else    switch    case    break........
(保留字)
    说明
        在目前的javascript中没意义，但未来可能具有特殊意义的词汇
    举例
        int   short   long   char
标识（标识符）
    说明
        变量名、函数名的另一种叫法
(表达式)
    说明
        能产生值的代码，一般配合运算符出现
    举例
        10+3  、  age&gt;=18.....
(语句)
    说明
        一句代码也称为一条语句，一般按用途还会分类：输出语句、声明语句、分支语句
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>while</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/blog/2019/12/15/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>运算符：算术运算符，赋值运算符，比较运算符，逻辑运算符，三目运算符</li>
<li>表达式：算术表示式，赋值表达式，判断表达式，逻辑表达式</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><pre><code class="js">+  -   *   /  %取余      自增++    自减--
</code></pre>
<ul>
<li><p>数据在进行运算的时候，会尽量转为数字在进行运算（内置帮我们去转的，属于隐式转换）符合 Number 的规律</p>
</li>
<li><p>+ :一旦遇到字符串表示拼接 将另一边数据也转为字符串</p>
</li>
<li><pre><code class="js">console.log(10 + 10)
console.log(10 + &#39;10&#39;) //&quot;10&quot; + &quot;10&quot; =&gt;&quot;1010&quot;
console.log(10 + 20 + &#39;100&#39;) //30 + &quot;100&quot; =&gt; &quot;30&quot; + &quot;100&quot; =&gt; &quot;30100&quot;
console.log(true + 100) // 1 + 100 =&gt;101
console.log(false + null) // 0 + 0 =&gt; 0
console.log(&#39;&#39; + 100) // &quot;&quot; + &quot;100&quot; =&gt; &quot;100&quot;

console.log(10 - &#39;5&#39;) // 10 - 5 = &gt;5
console.log(10 - &#39;5px&#39;) // 10 - NaN =&gt;NaN
console.log(10 - null) // 10 - 0 =&gt; 10
console.log(10 - true) // 10 - 1 =&gt; 9

console.log(10 * null) // 10 * 0 =&gt; 0
console.log(10 * true) // 10 * 1 =&gt; 10

console.log(100 / &#39;&#39;) // 100 / 0 =&gt; Infinity

// % 取余（取模）
console.log(100 % &#39;5&#39;) //0
console.log(100 % &#39;3&#39;) //1
</code></pre>
</li>
<li><p>++ ：不管++在前还是++在后都表示自身加 1，++在前表示先自身加 1，然后再进行运算，++在后表示先进行运算然后再自身加 1</p>
</li>
<li><p>– ：不管–在前还是–在后都表示自身减 1，–在前表示先自身减 1，然后再进行运算，–在后表示先进行运算然后再自身减 1</p>
<pre><code class="js">let a = 5
// a++;
++a
console.log(a) //6
let b = 3
// var c = ++b;
// console.log(c,b); //4 4

// var c = 3;
// console.log(c, b); //3 4
let e = 2 //10
//          2   +  3  +  5 + 5   +  7  -  7  -  9   + 9
console.log(e++ + e++ + ++e + e++ + ++e - e++ - ++e + e++) //15
console.log(e) //10
let f = 3 //5
//          3  +  4  +  6  -  5  - 5  +  4   -  5  -  4  +  4   + 4
console.log(f++ + f++ + ++f - --f - f-- + f++ - f-- - f-- + ++f + f++) //6
console.log(f) //5
// ++ -- 同样存在隐式转换
let test1 = &#39;10&#39;
--test1
console.log(test1) //9
</code></pre>
</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code class="js">let a = 10
console.log(a)

// 在a的基础上增加 5
// 给a重新赋值
// a = 15;
// console.log(a);

// a = a + 5;
a += 5 //相当于 a = a + 5；
console.log(a)

let b = 100
b -= 50 //&lt;=&gt; b = b - 50;
console.log(b)
</code></pre>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id="普通比较"><a href="#普通比较" class="headerlink" title="普通比较"></a>普通比较</h3><pre><code class="js">// 1.数据在进行比较的时候，会尽量转为数字进行比较（内置帮我们去转的，属于隐式转换）符合Number的规律
console.log(10 &gt; 5) //true
console.log(10 &gt; &#39;5&#39;) // 10 &gt; 5 true
console.log(true &gt; false) //1 &gt; 0 =&gt; true
console.log(&#39;100px&#39; &gt; 100) // NaN &gt; 100 =&gt; false
console.log(null &gt; &#39;&#39;) // 0 &gt; 0 =&gt;false
console.log(null &gt;= &#39;&#39;) // 0 &gt; 0 =&gt;true
console.log(10 != &#39;20&#39;) //10 != 20 =&gt; true

// 2.null等于undefined 但是null和undefined与其它数据类型都不相等
//null == 0  =&gt;false
console.log(null == &#39;&#39;) //false
console.log(null == undefined) //true
console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
console.log(undefined == undefined) //true
console.log(undefined == 0) //false
console.log(null == undefined) //true
console.log(4 == &#39;abc&#39;) //false
console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
console.log(null == null) //true
console.log(null !== undefined) //true
console.log(3 !== &#39;3&#39;) //true
console.log(null &gt;= 0)
true
console.log(null &lt;= 0)
true
// 3.字符串比较是按照ASCII（Unicode编码）值进行比较的，并且是按位进行比较的一旦某一位比较出结果，就不再比了
console.log(&#39;158&#39; &gt; &#39;1399999999999931231&#39;) //false
// 0 - 9 :48 - 57
// A - Z: 65 - 90
// a - z: 97 - 122
</code></pre>
<h3 id="绝对比较"><a href="#绝对比较" class="headerlink" title="绝对比较"></a>绝对比较</h3><pre><code class="text">=== 绝对等于   !== 绝对不等于

1.不同数据类型一定不相等
  === 绝对等于 （不仅要值相等，数据类型也要一样）
  !==    10 !== &quot;10&quot;   10 != &quot;10&quot;
</code></pre>
<pre><code class="js">console.log(0 == &#39;&#39;) // true
console.log(0 === &#39;&#39;) // false
console.log(9 === &#39;9&#39;) // false
console.log(null === undefined) // false
console.log(&#39;10&#39; !== 10) //true
</code></pre>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><pre><code class="text">&amp;&amp;与  || 或   ! 非
</code></pre>
<pre><code class="js">// &amp;&amp; 与  || 或
console.log(true &amp;&amp; true) //true
console.log(true &amp;&amp; false &amp;&amp; true) //false
console.log(true || false) //true
// 逻辑运算符会自动检测当前数据类型的真假 符合Boolean的规律
// 根据自身的规律返回对应位置的值
// 短路运算
var res = 66 &amp;&amp; &#39;10&#39; &amp;&amp; &#39;哈哈&#39; &amp;&amp; 100
console.log(res) //100
var res1 = 66 &amp;&amp; null &amp;&amp; &#39;哈哈&#39; &amp;&amp; 100
console.log(res1) //null
var res2 = &#39;aa&#39; || &#39;bb&#39; || &#39;&#39;
console.log(res2) //&quot;aa&quot;
var res3 = &#39;&#39; || null || undefined || NaN
console.log(res3) //NaN
</code></pre>
<h3 id="非：取反"><a href="#非：取反" class="headerlink" title="! 非：取反"></a>! 非：取反</h3><pre><code class="js">// 先将当前数据转为布尔值符合Number的规律，然后再进行取反
console.log(!10) // true - &gt; false
console.log(!20) //true -&gt; false
console.log(!&#39;哈哈&#39;) //true -&gt; false
console.log(!&#39;&#39;) //false -&gt; true
</code></pre>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><img src="https://raw.githubusercontent.com/3-ygd/image-hosting/master/运算符优先级.6svw4j0gciw0.webp">

<h2 id="三目运算符-三元表达式"><a href="#三目运算符-三元表达式" class="headerlink" title="三目运算符(三元表达式)"></a>三目运算符(三元表达式)</h2><pre><code class="txt">条件 ? 条件成立执行的代码段 : 条件不成立执行的代码段; (三目运算符又称之为问号冒号表达式，一般应用于简单的判断相当于if..else)
</code></pre>
<pre><code class="js">// 条件  ? 条件成立执行的代码段 : 条件不成立执行的代码段; (三目运算符又称之为问号冒号表达式，一般应用于简单的判断相当于if..else)
// 条件为真执行的是问号后边的代码段  条件为假执行的是冒号后边的代码段
let score = 50
score &gt;= 60 ? console.log(&#39;中午吃点好的&#39;) : console.log(&#39;中午不吃了~~~&#39;)

// 单个数据会自动检测真假
&#39;&#39; ? console.log(&#39;真的&#39;) : console.log(&#39;假的&#39;)
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/blog/2022/03/28/DOM%20%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a>DOM 节点操作</h1><h2 id="一、节点操作"><a href="#一、节点操作" class="headerlink" title="一、节点操作"></a>一、节点操作</h2><h3 id="1-DOM节点"><a href="#1-DOM节点" class="headerlink" title="1.DOM节点"></a>1.DOM节点</h3><p><strong>概念</strong>：DOM树里每一个内容都称之为节点</p>
<p>​    <strong>节点类型</strong>：</p>
<p>​        <strong>元素节点</strong>   ：所有的标签 比如 body、 div   |    html 是根节点</p>
<p>​        <strong>属性节点</strong>   ：所有的属性 比如 href</p>
<p>​        <strong>文本节点</strong>   ：所有的文本 </p>
<p>​        <strong>其他</strong></p>
<h3 id="2-查找节点"><a href="#2-查找节点" class="headerlink" title="2.查找节点"></a>2.查找节点</h3><p><strong>父节点查找</strong>：</p>
<p> 语法：</p>
<pre><code class="js">子元素.parentNode
</code></pre>
<p>注意：该方式会返回最近一级的父节点 找不到返回为null</p>
<p><strong>子节点查找：</strong></p>
<p>语法：</p>
<pre><code class="js">父元素.children
</code></pre>
<p>注意：该方式可以获得所有元素节点，并且返回的还是一个伪数组</p>
<p><strong>兄弟关系查找</strong></p>
<p>语法：</p>
<pre><code class="js">// 下一个兄弟元素节点
dom元素.nextElementSibling

// 获取上一个兄弟元素节点
dom元素.previousElementSibling
</code></pre>
<h3 id="3-增加节点"><a href="#3-增加节点" class="headerlink" title="3.增加节点"></a>3.增加节点</h3><p><strong>创建节点</strong></p>
<p>语法：</p>
<pre><code class="js">document.createElement(&#39;标签名&#39;)
</code></pre>
<p>说明：即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点</p>
<p><strong>追加节点</strong></p>
<p>语法：</p>
<pre><code class="js">// 插入到父元素的最后一个子元素
父元素.appendChild(要插入的元素)

// 插入到父元素中某个子元素的前面
父元素.insertBefore(要插入的元素，在那个元素前面)
</code></pre>
<p><strong>克隆节点</strong></p>
<p>语法：</p>
<pre><code class="js">// 克隆一个已有的元素节点
dom元素.cloneNode(布尔值)
</code></pre>
<p>说明：该方法会克隆出一个跟原标签一样的元素，括号内传入布尔值</p>
<p>​            若为true，则代表克隆时会包含后代节点一起克隆</p>
<p>​            若为false, 则代表克隆时不好含后代节点</p>
<p>​            默认为false</p>
<h3 id="4-删除节点"><a href="#4-删除节点" class="headerlink" title="4.删除节点"></a>4.删除节点</h3><p>语法：</p>
<pre><code class="js">父元素.removeChild(要删除的元素)
</code></pre>
<p>注意：</p>
<p>​        如不存在父子关系则删除不成功</p>
<p>​        删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点</p>
<h2 id="二、时间对象"><a href="#二、时间对象" class="headerlink" title="二、时间对象"></a>二、时间对象</h2><h3 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1.实例化"></a>1.实例化</h3><p>说明：</p>
<p>​        在代码中发现了 new 关键字时，一般将这个操作称为<strong>实例化</strong></p>
<p>​        创建一个时间对象并获取时间</p>
<p>语法：</p>
<pre><code class="js">// 获取当前的时间
let date = new Date()

// 获取指定时间
let date = new Date(&#39;1966-10-01&#39;)
</code></pre>
<h3 id="2-时间对象方法"><a href="#2-时间对象方法" class="headerlink" title="2.时间对象方法"></a>2.时间对象方法</h3><p>说明： 因为时间对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式</p>
<p><strong>以下为常用的一些方法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648481367(1).vkvql1yec2o.webp">



<h3 id="3-时间戳"><a href="#3-时间戳" class="headerlink" title="3.时间戳"></a>3.时间戳</h3><p>概念：是指1970年01月01日00时00分00秒起至现在的毫秒数，它是一种特殊的计量时间的方式</p>
<p><strong>使用 getTime() 方法</strong>  获取</p>
<pre><code class="js">// 实例化时间对象
let date = new Date()
// 获取时间戳
console.log(date.getTime())
</code></pre>
<p><strong>简写 + new Date()</strong>  获取</p>
<pre><code class="js">// 获取时间戳
console.log( +new Date() )
</code></pre>
<p><strong>使用 Date.now()</strong>   获取</p>
<pre><code class="js">// 获取时间戳
console.log( Date.now() )

// 注意：
// 该方法无需实例化
// 该方法只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>BOM- 操作浏览器</title>
    <url>/blog/2020/02/20/BOM-%20%E6%93%8D%E4%BD%9C%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="BOM-操作浏览器"><a href="#BOM-操作浏览器" class="headerlink" title="BOM- 操作浏览器"></a>BOM- 操作浏览器</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><h3 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM(浏览器对象模型)"></a>BOM(浏览器对象模型)</h3><p>BOM(Browser Object Model ) 是浏览器对象模型</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.2m9rwhel15q0.webp">

<p>window 是浏览器内置中的全局对象，我们所学习的所有 Web APIs 的知识内容都是基于 window 对象实现的</p>
<p>window 对象下包含了 navigator、location、document、history、screen 5 个属性，即所谓的 BOM （浏览器对象模型）</p>
<p>document 是实现 DOM 的基础，它其实是依附于 window 的属性。</p>
<p>注：依附于 window 对象的所有属性和方法，使用时可以省略 window</p>
<h3 id="定时器-延时函数"><a href="#定时器-延时函数" class="headerlink" title="定时器-延时函数"></a>定时器-延时函数</h3><p>JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout</p>
<pre><code class="js">// 语法：
setTimeout(回调函数，等待的毫秒数)
</code></pre>
<p>setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略 window</p>
<p><strong>清除延时函数</strong>：</p>
<pre><code class="js">// 语法：
let timer = setTimeout(回调函数，等待的毫秒数)
clearTimeout(timer) // 清除操作
</code></pre>
<p><strong>结合递归函数可以使用 setTimeout 实现 setInterval 一样的功能</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484053(1).11f3ojnjbrgw.webp">

<p><strong>两种定时器对比：</strong></p>
<ul>
<li>setInterval 的特征是重复执行，首次执行会延时</li>
<li>setTimeout 的特征是延时执行，只执行 1 次</li>
<li>setTimeout 结合递归函数，能模拟 setInterval 重复执行</li>
<li>clearTimeout 清除由 setTimeout 创建的定时任务</li>
</ul>
<h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分</p>
<p><strong>常用属性和方法：</strong></p>
<ul>
<li>href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484228(1).28dyzfbpmqtc.webp">

<ul>
<li>reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484291(1).1y7oon8x7fts.webp">

<h3 id="histroy-对象"><a href="#histroy-对象" class="headerlink" title="histroy 对象"></a>histroy 对象</h3><p>history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等</p>
<p><strong>常用属性和方法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484385(1).3ybl9j8q6h40.webp">

<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>1、生命周期永久生效，除非手动删除 否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3、以键值对的形式存储使用</p>
<pre><code class="js">// 存储数据
localStorage.setItem(key, value)

// 获取数据
localStorage.getItem(key)

// 删除数据
localStorage.removeItem(key)
</code></pre>
<p><strong>存储复杂</strong> 数据类型存储</p>
<p>本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成 JSON 字符串,在存储到本地</p>
<p><strong>JSON.stringify</strong>(复杂数据类型)</p>
<p>​ 将复杂数据转换成 JSON 字符串 <strong>存储</strong> 本地存储中</p>
<p><strong>JSON.parse</strong>(JSON 字符串)</p>
<p>​ 将 JSON 字符串转换成对象 <strong>取出</strong> 时候使用</p>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>window</tag>
        <tag>setTimeout</tag>
        <tag>histroy对象</tag>
      </tags>
  </entry>
  <entry>
    <title>获取元素大小和位置</title>
    <url>/blog/2020/02/13/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="获取元素大小和位置"><a href="#获取元素大小和位置" class="headerlink" title="获取元素大小和位置"></a>获取元素大小和位置</h1><h2 id="一、scroll-家族"><a href="#一、scroll-家族" class="headerlink" title="一、scroll 家族"></a>一、scroll 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的<strong>内容</strong>总宽高（不包含滚动条）返回值不带单位</li>
<li>scrollWidth 和 scrollHeight</li>
</ul>
<p>获取位置:</p>
<ul>
<li><p>获取元素内容往左、往上滚出去看不到的距离</p>
</li>
<li><p><strong>scrollLeft</strong>和<strong>scrollTop</strong></p>
</li>
<li><p>这两个属性是可以<strong>修改</strong>的</p>
<pre><code class="js">// 例如
div.addEventListener(&#39;scroll&#39;, function () &#123;
  console.log(this.scrollTop)
&#125;)
</code></pre>
</li>
</ul>
<p>注意：开发中，我们经常检测页面滚动的距离，比如页面滚动 100 像素，就可以显示一个元素，或者固定一个元素</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648483445(1).blsri7mcqqw.webp">

<h2 id="二、offset-家族"><a href="#二、offset-家族" class="headerlink" title="二、offset 家族"></a>二、offset 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的自身宽高、包含元素自身设置的宽高、padding、border</li>
<li>offsetWidth 和 offsetHeight</li>
</ul>
<p>获取位置：</p>
<ul>
<li>获取元素距离自己<strong>定位父级</strong>元素的左、上距离</li>
<li><strong>offsetLeft</strong>和<strong>offsetTop</strong> 注意是只读属性</li>
</ul>
<h2 id="三、client-家族"><a href="#三、client-家族" class="headerlink" title="三、client 家族"></a>三、client 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的可见部分宽高（不包含边框，滚动条等）</li>
<li>clientWidth 和 clientHeight</li>
</ul>
<p>获取位置：</p>
<ul>
<li>获取左边框和上边框宽度</li>
<li>clientLeft 和 clientTop 注意是只读属性</li>
</ul>
<p>触发时机：会在窗口尺寸改变的时候触发事件 | 检测屏幕宽度</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.offset 家族</p>
<ul>
<li><p>获取元素自身大小：包括自身设置的宽高、padding、border</p>
</li>
<li><p>获取元素距离定位父级的左和上距离 只读属性</p>
<p>2.client 家族</p>
</li>
<li><p>获取元素可见区域的大小</p>
</li>
<li><p>获取元素左、上边框距离 只读属性</p>
<p>3.scroll 家族</p>
</li>
<li><p>获取元素内容的总大小</p>
</li>
<li><p><strong>获取元素向左向上滚出去看不见的</strong>距离 可读写属性</p>
</li>
</ul>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>scroll</tag>
        <tag>offset</tag>
        <tag>client</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动事件和加载事件</title>
    <url>/blog/2020/02/06/%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="滚动事件和加载事件"><a href="#滚动事件和加载事件" class="headerlink" title="滚动事件和加载事件"></a>滚动事件和加载事件</h1><h2 id="一、滚动事件"><a href="#一、滚动事件" class="headerlink" title="一、滚动事件"></a>一、滚动事件</h2><p>触发时机：当页面进行滚动时触发的事件</p>
<p>为什么要使用？</p>
<p>​ 因为很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部</p>
<p>事件名：scroll</p>
<pre><code class="js">// 语法
window.addEventListener(&#39;scroll&#39;, function () &#123;
  // 执行的操作
&#125;)

// 给 window 或 document 添加 scroll 事件
</code></pre>
<p>监听那个元素的内部滚动直接给某个元素加即可</p>
<h2 id="二、加载事件"><a href="#二、加载事件" class="headerlink" title="二、加载事件"></a>二、加载事件</h2><p>触发时机：加载外部资源（如图片、外联 CSS 和 JavaScript 等）加载完毕时触发的事件</p>
<p>为什么要使用？</p>
<ul>
<li>有些时候需要等页面资源全部处理完了做一些事情</li>
<li>老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到</li>
</ul>
<p>事件名：load</p>
<p>例如：给 window 添加 load 事件</p>
<pre><code class="js">// 语法
// 页面加载事件
window.addEventListener(&#39;load&#39;, function () &#123;
  // 执行的操作
&#125;)

// 给 window 添加 load 事件
</code></pre>
<p>注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定 load 事件</p>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>滚动事件</tag>
        <tag>加载事件</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM- 事件对象、事件流、事件委托</title>
    <url>/blog/2020/01/27/DOM-%20%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%B5%81%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h1 id="DOM-事件对象、事件流、事件委托"><a href="#DOM-事件对象、事件流、事件委托" class="headerlink" title="**DOM- 事件对象、事件流、事件委托"></a>**DOM- 事件对象、事件流、事件委托</h1><h2 id="一、事件对象"><a href="#一、事件对象" class="headerlink" title="一、事件对象"></a>一、事件对象</h2><h3 id="1-获取事件对象"><a href="#1-获取事件对象" class="headerlink" title="1.获取事件对象"></a>1.获取事件对象</h3><p><strong>事件对象是什么：</strong></p>
<ul>
<li>也是个对象，这个对象里有事件触发时的相关信息</li>
<li>例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息</li>
</ul>
<p><strong>如何获取：</strong></p>
<ul>
<li>在事件绑定的回调函数的第一个参数就是事件对象</li>
<li>一般命名为 event、ev、e</li>
</ul>
<pre><code class="js">// 例如
元素.addEventListener(&#39;click&#39;, function (e) &#123;&#125;) //  这里的e就是事件对象参数
</code></pre>
<h3 id="2-事件对象常用属性"><a href="#2-事件对象常用属性" class="headerlink" title="2.事件对象常用属性"></a>2.事件对象常用属性</h3><p><strong>部分常用属性：</strong></p>
<ul>
<li>type：获取当前的事件类型</li>
<li>clientX&#x2F;clientY：获取光标相对于浏览器可见窗口左上角的位置</li>
<li>offsetX&#x2F;offsetY：获取光标相对于当前 DOM 元素左上角的位置</li>
<li>key：用户按下的键盘键的值</li>
</ul>
<p>注意：现在不提倡使用 keyCode</p>
<h3 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h3><h3 id="1-事件流与两个阶段说明"><a href="#1-事件流与两个阶段说明" class="headerlink" title="1.事件流与两个阶段说明"></a>1.事件流与两个阶段说明</h3><p>事件流：指的是事件完整执行过程中的流动路径</p>
<p>简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父</p>
<h3 id="2-事件捕获和事件冒泡"><a href="#2-事件捕获和事件冒泡" class="headerlink" title="2.事件捕获和事件冒泡"></a>2.事件捕获和事件冒泡</h3><p><strong>事件冒泡</strong></p>
<ul>
<li>概念：当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡</li>
<li>简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件</li>
<li>注意：事件冒泡是默认存在的</li>
</ul>
<p><strong>事件捕获</strong></p>
<ul>
<li><p>概念： 从 DOM 的根元素开始去执行对应的事件 (从外到里)</p>
</li>
<li><p>说明：addEventListener 第三个参数传入 true 代表是捕获阶段触发（很少使用）</p>
<p>​ 若传入 false 代表冒泡阶段触发，默认就是 false</p>
<p>​ 若是用 L0 事件监听，则只有冒泡阶段，没有捕获</p>
</li>
</ul>
<p><strong>阻止事件流动的方式</strong></p>
<p>语法：</p>
<pre><code class="js">事件对象.stopPropagation()

// 注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效
</code></pre>
<p><strong>阻止默认行为</strong></p>
<p>使用场景：l 比如链接点击不跳转，表单域的不提交</p>
<p>语法：</p>
<pre><code class="js">e.preveentDefault()
</code></pre>
<p><strong>两种注册事件的区别：</strong></p>
<p>传统 on 注册（L0）</p>
<ul>
<li>同一个对象,后面注册的事件会覆盖前面注册(同一个事件)</li>
<li>直接使用 null 覆盖偶就可以实现事件的解绑</li>
<li>都是冒泡阶段执行的</li>
</ul>
<p>事件监听注册（L2）</p>
<ul>
<li>语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获)</li>
<li>后面注册的事件不会覆盖前面注册的事件(同一个事件)</li>
<li>可以通过第三个参数去确定是在冒泡或者捕获阶段执行</li>
<li>必须使用 removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)</li>
<li>匿名函数无法被解绑</li>
</ul>
<h3 id="3-阻止事件流动"><a href="#3-阻止事件流动" class="headerlink" title="3.阻止事件流动"></a>3.阻止事件流动</h3><h3 id="三、事件委托"><a href="#三、事件委托" class="headerlink" title="三、事件委托"></a>三、事件委托</h3><p><strong>原理：</strong>事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发</p>
<p><strong>使用场景：</strong>当子元素是动态创建并且需要注册事件的时候，推荐使用事件委托</p>
<p><strong>优点：</strong>给父级元素加事件（可以提高性能）</p>
<p><strong>实现：</strong>事件对象.target 可以获得真正触发事件的元素</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648482711(1).2qvzd2cnol40.webp">
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>事件对象</tag>
        <tag>事件流</tag>
        <tag>事件委托</tag>
      </tags>
  </entry>
</search>
