<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/blog/2019/12/07/hello-world/</url>
    <content><![CDATA[<!-- category 文章分类 -->
<!-- tag 文章标签 -->

<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM-获取DOM元素、修改属性</title>
    <url>/blog/2020/01/16/DOM-%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E3%80%81%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="·DOM-获取-DOM-元素、修改属性"><a href="#·DOM-获取-DOM-元素、修改属性" class="headerlink" title="·DOM-获取 DOM 元素、修改属性"></a>·DOM-获取 DOM 元素、修改属性</h1><h1 id="一、Web-API-的基本认识"><a href="#一、Web-API-的基本认识" class="headerlink" title="一、Web API 的基本认识"></a>一、Web API 的基本认识</h1><h2 id="1、作用和分类"><a href="#1、作用和分类" class="headerlink" title="1、作用和分类"></a>1、作用和分类</h2><p>​ <strong>作用:</strong> 就是使用 JS 去操作 html 和浏览器</p>
<p>​ <strong>分类：</strong>DOM (文档对象模型)、BOM（浏览器对象模型）</p>
<h2 id="2、什么是-DOM"><a href="#2、什么是-DOM" class="headerlink" title="2、什么是 DOM"></a>2、什么是 DOM</h2><p>​ <strong>DOM</strong>（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 文档交互的 API</p>
<p>​ <strong>白话文：</strong>DOM 是浏览器提供的一套专门用来 <strong>操作**<strong>网页*</strong>*内容</strong> 的功能</p>
<p>​ <strong>DOM 作用:</strong> 开发网页内容特效和实现用户交互</p>
<h2 id="3、DOM-树"><a href="#3、DOM-树" class="headerlink" title="3、DOM 树"></a>3、DOM 树</h2><p><strong>lDOM 树是什么</strong>?</p>
<p>​ a：将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树</p>
<p>​ b：描述网页内容关系的名词</p>
<p>​ c：作用：文档树直观的体现了标签与标签之间的关系</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.ev61ukot49s.webp">

<h2 id="4、DOM-对象"><a href="#4、DOM-对象" class="headerlink" title="4、DOM 对象"></a>4、DOM 对象</h2><p><strong>lDOM 对象：浏览器根据 html 标签生成的 JS 对象</strong></p>
<ol>
<li>所有的标签属性都可以在这个对象上面找到</li>
<li>修改这个对象的属性会自动映射到标签身上</li>
</ol>
<p><strong>lDOM 的核心思想</strong></p>
<ol>
<li>把网页内容当做对象来处理</li>
</ol>
<p><strong>ldocument 对象</strong></p>
<ol>
<li><p>是 DOM 里提供的一个<strong>对象</strong></p>
</li>
<li><p>所以它提供的属性和方法都是<strong>用来访问和操作网页内容的</strong></p>
</li>
<li><p>网页所有内容都在 document 里面</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/2.39cbhcf08220.webp"></li>
</ol>
<h1 id="二、获取-DOM-对象"><a href="#二、获取-DOM-对象" class="headerlink" title="二、获取 DOM 对象"></a>二、获取 DOM 对象</h1><h2 id="1、根据-CSS-选择器来获取-DOM-元素"><a href="#1、根据-CSS-选择器来获取-DOM-元素" class="headerlink" title="1、根据 CSS 选择器来获取 DOM 元素"></a>1、根据 CSS 选择器来获取 DOM 元素</h2><h3 id="1-1-选择匹配的第一个元素"><a href="#1-1-选择匹配的第一个元素" class="headerlink" title="1.1 选择匹配的第一个元素"></a><strong>1.1 选择匹配的第一个元素</strong></h3><p><strong>语法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/3.6vdlcn8lhg00.webp">

<p><strong>参数</strong></p>
<ol>
<li>包含一个或多个有效的 CSS 选择器 <strong>字符串</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>CSS 选择器匹配的第一个元素,一个 HTMLElement 对象。</li>
<li>如果没有匹配到，则返回 null。</li>
</ol>
<h3 id="1-2-选择匹配的多个元素"><a href="#1-2-选择匹配的多个元素" class="headerlink" title="1.2 选择匹配的多个元素"></a><strong>1.2 选择匹配的多个元素</strong></h3><p><strong>语法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/4.1585wrbzbtts.webp">

<p><strong>参数</strong></p>
<ol>
<li>包含一个或多个有效的 CSS 选择器 <strong>字符串</strong></li>
</ol>
<p><strong>返回值：</strong></p>
<ol>
<li>CSS 选择器匹配的 NodeList 对象集合</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>该方法得到的是一个<strong>伪数组</strong>：</li>
<li>有长度有索引号的数组</li>
<li>但是没有 pop() push() 等数组方法</li>
<li>想要得到里面的每一个对象，则需要遍历（for）的方式获得。</li>
</ul>
<p><strong>例如：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/3-1.2k59o0n4a2g0.webp">

<h3 id="1-3-其他获取-DOM-元素方法"><a href="#1-3-其他获取-DOM-元素方法" class="headerlink" title="1.3 其他获取 DOM 元素方法"></a>1.3 其他获取 DOM 元素方法</h3><img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/5.5rwr9qe1ass0.webp">

<h1 id="三、设置-x2F-修改-DOM-元素内容"><a href="#三、设置-x2F-修改-DOM-元素内容" class="headerlink" title="三、设置&#x2F;修改 DOM 元素内容"></a>三、设置&#x2F;修改 DOM 元素内容</h1><h2 id="1、设置-x2F-修改-DOM-元素内容"><a href="#1、设置-x2F-修改-DOM-元素内容" class="headerlink" title="1、设置&#x2F;修改 DOM 元素内容"></a>1、设置&#x2F;修改 DOM 元素内容</h2><h3 id="1-1document-write"><a href="#1-1document-write" class="headerlink" title="1.1document.write()"></a>1.1document.write()</h3><ul>
<li>只能将文本内容追加到 </body> 前面的位置</li>
<li>文本中包含的标签会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-1.69swq3hv2qc0.webp">

<h3 id="1-2-元素-innerText-属性"><a href="#1-2-元素-innerText-属性" class="headerlink" title="1.2 元素 innerText 属性"></a>1.2 元素 innerText 属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>文本中包含的标签不会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-2.5wxmw3vy4fw0.webp">

<h3 id="1-3-元素-innerHTML-属性"><a href="#1-3-元素-innerHTML-属性" class="headerlink" title="1.3 元素 innerHTML 属性"></a>1.3 元素 innerHTML 属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>文本中包含的标签会被解析</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/6-3.4y46t382rhc0.webp">

<h1 id="四、设置-x2F-修改-DOM-元素属性"><a href="#四、设置-x2F-修改-DOM-元素属性" class="headerlink" title="四、设置&#x2F;修改 DOM 元素属性"></a>四、设置&#x2F;修改 DOM 元素属性</h1><h3 id="1-设置-x2F-修改元素常用属性"><a href="#1-设置-x2F-修改元素常用属性" class="headerlink" title="1. 设置&#x2F;修改元素常用属性"></a><strong>1.</strong> <strong>设置&#x2F;修改元素常用属性</strong></h3><ul>
<li>还可以通过 JS 设置&#x2F;修改标签元素属性，比如通过 src 更换 图片</li>
<li>最常见的属性比如： href、title、src 等</li>
</ul>
<pre><code class="js">语法：
对象.属性 = 值
</code></pre>
<h3 id="2-设置-x2F-修改元素样式属性"><a href="#2-设置-x2F-修改元素样式属性" class="headerlink" title="2.设置&#x2F;修改元素样式属性"></a>2.设置&#x2F;修改元素<strong>样式</strong>属性</h3><p><strong>方法：</strong></p>
<ul>
<li>通过 style 属性操作 CSS</li>
<li>操作类名(className) 操作 CSS</li>
<li>通过 classList 操作类控制 CSS</li>
</ul>
<h3 id="3-通过-设置-style-属性操作-CSS"><a href="#3-通过-设置-style-属性操作-CSS" class="headerlink" title="3.通过 设置 style 属性操作 CSS"></a>3.通过 设置 style 属性操作 CSS</h3><pre><code class="js">语法：
对象.style.样式属性 = 值
</code></pre>
<h3 id="4-操作类名-className-操作-CSS"><a href="#4-操作类名-className-操作-CSS" class="headerlink" title="4.操作类名(className) 操作 CSS"></a>4.操作类名(className) 操作 CSS</h3><p>说明：如果修改的样式比较多，直接通过 style 属性修改比较繁琐，我们可以通过借助于 css 类名的形式。</p>
<pre><code class="js">语法：
元素.className = &#39;active&#39;   // active是一个类名
</code></pre>
<p><strong>注意：</strong></p>
<p>1.由于 class 是关键字, 所以使用 className 去代替</p>
<p>2.className 是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名</p>
<h3 id="5-通过-classList-操作类控制-CSS"><a href="#5-通过-classList-操作类控制-CSS" class="headerlink" title="5.通过( classList) 操作类控制 CSS"></a>5.通过( classList) 操作类控制 CSS</h3><p>说明：为了解决 className 容易覆盖以前的类名，我们可以通过 classList 方式追加和删除类名</p>
<pre><code class="js">语法：
//  追加一个类
元素.classList.add(&#39;类名&#39;)
//  删除一个类
元素.classList.remove(&#39;类名&#39;)
//  切换一个类
元素.classList.toggle(&#39;类名&#39;)
</code></pre>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>className</tag>
        <tag>classList</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环语法|数组|对象</title>
    <url>/blog/2019/12/23/for-%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h1><h3 id="语法结构："><a href="#语法结构：" class="headerlink" title="语法结构："></a>语法结构：</h3><pre><code class="tex">for（循环条件初始化；循环条件判断；循环迭代）&#123;
  循环体；
&#125;
</code></pre>
<h3 id="执行规则："><a href="#执行规则：" class="headerlink" title="执行规则："></a>执行规则：</h3><pre><code class="tex">第一步：循环条件的初始化（只在最开始执行一次）
第二步：循环条件判断
1》若判断条件结果为真：则执行循环体；
2》若不成立：结束循环；
第三步：循环迭代
第四步：回到第二步
</code></pre>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><h4 id="1、打印-5-行-5-列的星星"><a href="#1、打印-5-行-5-列的星星" class="headerlink" title="1、打印 5 行 5 列的星星"></a>1、打印 5 行 5 列的星星</h4><pre><code class="js">//  打印5行5列的星星

let star = &#39;&#39;
for (var i = 0; i &lt; 5; i++) &#123;
  for (var j = 0; j &lt; 5; j++) &#123;
    star += &#39;*&#39;
  &#125;
  star += &#39;\n&#39;
&#125;
console.log(star)
</code></pre>
<h4 id="2、打印三角形星星"><a href="#2、打印三角形星星" class="headerlink" title="2、打印三角形星星"></a>2、打印三角形星星</h4><pre><code class="js">//  打印三角形星星

let num = Number(prompt(&#39;请输入行数：&#39;))
// 正五角
// for (let i = 1; i &lt;= num; i++) &#123;
//     for (let j = 1; j &lt;= i; j++) &#123;
//         document.write(&#39;⭐&#39;)
//     &#125;
//     document.write(&#39;&lt;br&gt;&#39;)
// &#125;

// 倒五角
for (let i = 1; i &lt;= num; i++) &#123;
  for (let j = i; j &lt;= num; j++) &#123;
    document.write(&#39;⭐&#39;)
  &#125;
  document.write(&#39;&lt;br&gt;&#39;)
&#125;
</code></pre>
<h4 id="3、乘法表"><a href="#3、乘法表" class="headerlink" title="3、乘法表"></a>3、乘法表</h4><pre><code class="js">//  乘法表

let num = Number(prompt(&#39;请输入一个数字：&#39;))
// for (let i = 1; i &lt;= num; i++) &#123;
//     for (let j = 1; j &lt;= i; j++) &#123;
//         document.write(`$&#123;j&#125; x $&#123;i&#125; = $&#123;i * j&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`);
//     &#125;
//     document.write(&#39;&lt;br&gt;&lt;br&gt;&#39;)
// &#125;

for (let i = 1; i &lt;= num; i++) &#123;
  for (let j = i; j &lt;= 9; j++) &#123;
    document.write(`&lt;span&gt;$&#123;i&#125; x $&#123;j&#125; = $&#123;i * j&#125;&lt;/span&gt;`)
  &#125;
  document.write(&#39;&lt;br&gt;&lt;br&gt;&#39;)
&#125;
</code></pre>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1.数组的创建"></a>1.数组的创建</h2><p>1） 字面量创建</p>
<pre><code class="js">let arr = [1, true, &#39;zhaimin&#39;, [1, 2]]

let Arr2 = [, ,] //undefined,undefined
</code></pre>
<p>2）利用 array 构造器创建数组</p>
<pre><code class="js">let arr = new Array()
</code></pre>
<h2 id="2-遍历数组"><a href="#2-遍历数组" class="headerlink" title="2.遍历数组"></a>2.遍历数组</h2><pre><code class="js">let arr = [1, 2, 3, 4, 5, 6]
for (var i = 0; i &lt; arr.length; i++) &#123;
  console.log(arr[i])
&#125;

// 1 2 3 4 5 6
</code></pre>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h2><p>1）字面量创建</p>
<pre><code class="js">let obj = &#123;
  name: &#39;我是一个对象&#39;,
  age: 21
&#125;
</code></pre>
<p>2）使用 Object 构造器创建对象</p>
<pre><code class="js">let obj = new Object()
</code></pre>
<p>3）使用构造函数创建对象</p>
<pre><code class="js">function Obj(name,age)&#123;
    this.name = name
    this.age = age
&#125;

// 创建构造函数
const fn = new Obj(&#39;小红&#39;,21)
console.log(fn);  &#123; name:&#39;小红&#39;,age:21 &#125;
</code></pre>
<h2 id="2-使用-for…in-遍历对象"><a href="#2-使用-for…in-遍历对象" class="headerlink" title="2.使用 for…in 遍历对象"></a>2.使用 for…in 遍历对象</h2><pre><code class="js">let obj = &#123; a: 1, b: 2 &#125;
for (let i in obj) &#123;
  console(&#39;key:&#39; + i + &#39;, value:&#39; + obj[i])
&#125;
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>for</tag>
        <tag>Array</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM-事件基础</title>
    <url>/blog/2020/01/06/DOM-%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="DOM-事件基础"><a href="#DOM-事件基础" class="headerlink" title="DOM-事件基础"></a>DOM-事件基础</h1><h2 id="一、事件"><a href="#一、事件" class="headerlink" title="一、事件"></a>一、事件</h2><p><strong>什么是事件？</strong></p>
<ul>
<li>事件是在编程时系统内发生的<strong>动作</strong>或者发生的事情</li>
<li>比如用户在网页上<strong>单击</strong>一个按钮</li>
</ul>
<p><strong>什么是事件监听？</strong></p>
<ul>
<li>​ 就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件</li>
</ul>
<p><strong>语法：</strong></p>
<pre><code class="js">//  之前的语法
// 注意：该方法对同一个dom元素使用时，只能绑定一个事件，若绑定多个则后者覆盖前者
元素.onclick = function()&#123;逻辑代码&#125;

//  es6语法
// 注意：该方法可以给同一个dom元素绑定多个事件，之间互不影响
元素.addEventListener(&#39;事件&#39;，要执行的函数)
</code></pre>
<p><strong>事件监听三要素：</strong></p>
<ul>
<li><strong>事件源：</strong> 那个 dom 元素被事件触发了，要获取 dom 元素</li>
<li><strong>事件：</strong> 用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等</li>
<li><strong>事件调用的函数</strong>： 要做什么事</li>
</ul>
<p><strong>举例说明：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/11.2qxr6165m0e0.webp">

<p><strong>注意：</strong></p>
<p>1.事件类型要加引号</p>
<p>2.函数是点击之后再去执行，每次点击都会执行一次</p>
<h2 id="二、高阶函数"><a href="#二、高阶函数" class="headerlink" title="二、高阶函数"></a>二、高阶函数</h2><p>说明：可以被简单理解为函数的高级应用，JavaScript 中函数可以被当成【值】来对待，基于这个特性实现函数的高级应用。</p>
<h3 id="1-函数表达式"><a href="#1-函数表达式" class="headerlink" title="1.函数表达式"></a>1.函数表达式</h3><p>函数表达式和普通函数并无本质上的区别：</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648398044(1).41nbmi30vqq0.webp">

<p><strong>注意 ：</strong></p>
<ul>
<li>普通函数的声明与调用无顺序限制，推荐做法先声明再调用</li>
<li><strong>函数表达式必须要先声明再调用</strong></li>
</ul>
<h3 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h3><p>把函数当做另外一个函数的参数传递，这个函数就叫回调函数</p>
<p>回调函数本质还是函数，只不过把它当成参数使用</p>
<p>使用匿名函数做为回调函数比较常见</p>
<p>例如：</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/xx.50hr5m42gyo0.webp">

<h2 id="三、编程思想"><a href="#三、编程思想" class="headerlink" title="三、编程思想"></a>三、编程思想</h2><p><strong>说明：</strong>当前元素为 A 状态,其他元素为 B 状态</p>
<p><strong>使用：</strong></p>
<ol>
<li><p>干掉所有人</p>
<pre><code>使用for循环
</code></pre>
</li>
<li><p>复活他自己</p>
<pre><code>通过this或者下标找到自己或者对应的元素
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的变量和数据类型</title>
    <url>/blog/2019/12/08/js%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JavaScript-的变量和数据类型"><a href="#JavaScript-的变量和数据类型" class="headerlink" title="JavaScript 的变量和数据类型"></a>JavaScript 的变量和数据类型</h1><h2 id="1-变量的含义和存储"><a href="#1-变量的含义和存储" class="headerlink" title="1.变量的含义和存储"></a>1.变量的含义和存储</h2><p>变量就是用来存放数据的容器，可以通过变量名获取数据，也可以修改数据；</p>
<p>在内存中存储的本质：变量是程序在内存中申请的一块用来存放数据的空间；</p>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><p>变量的声明：使用 var 或者 let (ES6 语法) 进行声明<br>var 声明的变量会进行变量提升（可以先使用，后定义）<br>let 声明的变量不会变量提升（先定义，后使用）</p>
<p>变量的命名规范：</p>
<p>1.由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成， 2.严格区分大小写。 3.不能 以数字开头。 4.不能 是关键字。 5.变量名必须有意义。 6.遵守驼峰命名法。首字母小写，后面单词的首字母需要大写</p>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h3 id="3-1-数据类型的种类"><a href="#3-1-数据类型的种类" class="headerlink" title="3.1 数据类型的种类"></a>3.1 数据类型的种类</h3><h4 id="1-简单的数据类型："><a href="#1-简单的数据类型：" class="headerlink" title="1.简单的数据类型："></a>1.简单的数据类型：</h4><p>Number: 数字型，包含整型和浮点型；</p>
<p>String：字符串类型（用引号引起来）；</p>
<p>Boolean：布尔值类型（true 和 false）；</p>
<p>Undefined ：声明一个变量但是未赋值，就是 undefined；</p>
<p>Null：空值；</p>
<h4 id="2-复杂的数据类型：Object"><a href="#2-复杂的数据类型：Object" class="headerlink" title="2.复杂的数据类型：Object"></a>2.复杂的数据类型：Object</h4><pre><code class="js">typeof Object //&quot;function&quot;
typeof typeof Object //string类型
</code></pre>
<p><strong>01.数字型进制：</strong>二进制、八进制、十进制、十六进制</p>
<p>02.数字型的范围：</p>
<p>最大值：(Number.MAX_VALUE)&#x3D;1.7976931348623157e+308；</p>
<p>最小值：（Number.MIN_VALUE)&#x3D;5e-324;</p>
<p>03.三个特殊值：</p>
<p>infinity:无穷大，大于任何值；</p>
<p>-infinity:无穷小，小于任何值；</p>
<p>NaN:Not a number 非数值；</p>
<p>04.判断一个变量是否为非数字类型返回 true 或 false：</p>
<p>isNaN(a):a 是数字返回 false；a 不是数字返回 true</p>
<pre><code class="js">//数字
console.log(3.14) //3.14
//八进制 0-7 数字前边加0表示8进制
console.log(015) //13
//十六进制 0-9 a-f 数字前边加0x 表示十六进制
console.log(0xa) //10
console.log(0x2a) //42
//数字型的最大值和最小值
console.log(Number.MAX_VALUE) //1.7976931348623157e+308
console.log(Number.MIN_VALUE) //5e-324
//无穷大和无穷小 最大值乘以大于1的数就是无穷大，前边加一个负号就是负无穷
console.log(Number.MAX_VALUE * 1.1) // infinity 无穷大
console.log(-Number.MIN_VALUE * 1.1) // -infinity 无穷小
//NaN 非数字
console.log(0 / 0) //NaN
console.log(10 - &#39;a&#39;) //NaN
</code></pre>
<h3 id="3-3-字符串型-String"><a href="#3-3-字符串型-String" class="headerlink" title="3.3 字符串型 String"></a>3.3 字符串型 String</h3><pre><code class="js">typeof string //&quot;undefined&quot;
typeof typeof string //string类型
typeof (10 + &#39;5&#39;) //string
</code></pre>
<p>字符串是引号中的任意文本，用双引号或者单引号；</p>
<p><strong>引号的嵌套</strong>(外双内单，外单内双)：1.单引号嵌套双引号；2.双引号嵌套单引号；</p>
<pre><code class="js">\n :换行符；
\\ :单斜杠\;
\&#39; :&#39;单引号;
\&quot; :” 双引号;
\t :tab缩进；
\b ：空格
</code></pre>
<p><strong>字符串拼接</strong>：</p>
<p>多个字符串之间使用 z：字符串 + 任何类型 &#x3D; 新的字符串；</p>
<p>拼接前会把与字符串相加的任何类型转换成字符串，在拼接一个新的字符串</p>
<pre><code class="js">//Boolean
typeof Boolean //&quot;function&quot;
typeof typeof Boolean //string类型
typeof true //Boolean
typeof false //Boolean
</code></pre>
<h3 id="3-5undefined-和-null"><a href="#3-5undefined-和-null" class="headerlink" title="3.5undefined 和 null"></a>3.5undefined 和 null</h3><pre><code class="js">//null
typeof null //&quot;object&quot;
typeof typeof null //string类型
//undefined
typeof undefined //&quot;undefined&quot;
typeof typeof undefined //string类型
</code></pre>
<p>特殊情况：<br>undefined &gt; 0 false;<br>undefined &lt; 0 false;<br>undefined &#x3D;&#x3D; 0 false;<br>undefined&#x3D;&#x3D;null true;</p>
<p>（1）一个声明后没有被赋值的变量会有一个默认值 undefined;</p>
<p>（2) 调用函数时，应该提供的参数没有提供，为 undefined;</p>
<p>（3）函数没有返回值时，默认返回 undefined;</p>
<p>（4）对象没有赋值的属性，该属性的值为 undefined;</p>
<p>(5)一个声明变量给 null 值，里面存的值为空;</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串引号|do while|while</title>
    <url>/blog/2019/12/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%95%E5%8F%B7-for%E5%90%8C%E7%B1%BB-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="一、字符串引号"><a href="#一、字符串引号" class="headerlink" title="一、字符串引号"></a>一、字符串引号</h1><h2 id="1、类别"><a href="#1、类别" class="headerlink" title="1、类别"></a>1、类别</h2><p>字符串的字面量表达方式——用引号包起来：</p>
<pre><code class="js">单引号（ ‘’）
双引号（ “”）
反引号 ( `` )
</code></pre>
<p>注意事项：</p>
<pre><code class="js">1、无论单引号或是双引号必须成对使用
2、单引号或双引号可以互相嵌套，但是不以自已嵌套自已（口诀：外双内单，或者外单内双）
3、也可以使用转义符 \ 来输出单引号或双引号
</code></pre>
<h1 id="二、for-同类"><a href="#二、for-同类" class="headerlink" title="二、for 同类"></a>二、for 同类</h1><h2 id="1、while-循环"><a href="#1、while-循环" class="headerlink" title="1、while 循环"></a>1、while 循环</h2><p>说明：循环重复执行一段代码，直到某个条件不再满足。<br>结构：</p>
<pre><code class="js">while（条件表达式）&#123;
  只要条件表达式结果为true,循环一直执行，当条件表达式结果为false的时候，循环终止
&#125;
</code></pre>
<p>注意：条件表达式即为判断表达式</p>
<h3 id="案例一-将-1-10-打印到控制台"><a href="#案例一-将-1-10-打印到控制台" class="headerlink" title="案例一 将 1-10 打印到控制台"></a>案例一 <strong>将 1-10 打印到控制台</strong></h3><pre><code class="js">let n1=1;
while(n1&gt;=1 &amp;&amp; n1&lt;=10)&#123;    // n1满足条件
    console.log(n1);       // 若没有n1++，控制台会一直循环1这个数字
    n1++;
// 当代码执行到console.log(n1)；时为1，继续执行到n1++；此时结果为2。然后继续循环这执行 console.log(n1)； // console.log(n1);此时结果为2+1=3，会一直循环执行这两行代码，直到条件不满足条件式 (n1&gt;=1 &amp;&amp; n1&lt;=10)时终止。
</code></pre>
<h3 id="案例二-求-1-到-100-之间的数字和-在控制台输出"><a href="#案例二-求-1-到-100-之间的数字和-在控制台输出" class="headerlink" title="案例二 求 1 到 100 之间的数字和,在控制台输出"></a>案例二 求 1 到 100 之间的数字和,在控制台输出</h3><pre><code class="js">let n1 = 1
let sum = 0
while (n1 &gt;= 1 &amp;&amp; n1 &lt;= 100) &#123;
  sum = sum + n1
  n1++
&#125;
console.log(sum)
</code></pre>
<h3 id="案例二-将-1-100-之间-3-的倍数找出来，在控制台输出"><a href="#案例二-将-1-100-之间-3-的倍数找出来，在控制台输出" class="headerlink" title="案例二 将 1-100 之间 3 的倍数找出来，在控制台输出"></a>案例二 将 1-100 之间 3 的倍数找出来，在控制台输出</h3><pre><code class="js">let n1=1;
while(n1&gt;=1 &amp;&amp; n1&lt;=100)&#123;
    if(n1%3==0)&#123;
        console.log(n1);     当n1=1时不满足条件式if(n1%3==0)，所以不在控制台输出，但是满足主条件式(n1&gt;=1 &amp;&amp; n1&lt;=100)，所以继续执行下面代码n1++;由此循环。
    &#125;else&#123;
    &#125;
    n1++;
&#125;
</code></pre>
<h2 id="2、do-while-循环"><a href="#2、do-while-循环" class="headerlink" title="2、do while 循环"></a>2、do while 循环</h2><p>结构：</p>
<pre><code class="js">do&#123;
    循环体代码，首先这行该循环体代码一次，如果while后面的表达式结果为true,该循环体会一直循环，如果结果为false,该循环体终止。
&#125;while(条件表达式）
</code></pre>
<p>注意：do while 比 while 多循环一次</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="js">let n1 = 1
let n2 = 5
do &#123;
  alert(&#39;n1&gt;n2&#39;) // 循环一次显示的结果
&#125; while (n1 &gt; n2) // while表达式为false,循环终止。
</code></pre>
<h1 id="三、术语解释"><a href="#三、术语解释" class="headerlink" title="三、术语解释"></a>三、术语解释</h1><pre><code class="js">(关键字)
    说明
        在javascript中有特殊意义的词汇
    举例
        let   var   function    if   else    switch    case    break........
(保留字)
    说明
        在目前的javascript中没意义，但未来可能具有特殊意义的词汇
    举例
        int   short   long   char
标识（标识符）
    说明
        变量名、函数名的另一种叫法
(表达式)
    说明
        能产生值的代码，一般配合运算符出现
    举例
        10+3  、  age&gt;=18.....
(语句)
    说明
        一句代码也称为一条语句，一般按用途还会分类：输出语句、声明语句、分支语句
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>while</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/blog/2019/12/15/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>运算符：算术运算符，赋值运算符，比较运算符，逻辑运算符，三目运算符</li>
<li>表达式：算术表示式，赋值表达式，判断表达式，逻辑表达式</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><pre><code class="js">+  -   *   /  %取余      自增++    自减--
</code></pre>
<ul>
<li><p>数据在进行运算的时候，会尽量转为数字在进行运算（内置帮我们去转的，属于隐式转换）符合 Number 的规律</p>
</li>
<li><p>+ :一旦遇到字符串表示拼接 将另一边数据也转为字符串</p>
</li>
<li><pre><code class="js">console.log(10 + 10)
console.log(10 + &#39;10&#39;) //&quot;10&quot; + &quot;10&quot; =&gt;&quot;1010&quot;
console.log(10 + 20 + &#39;100&#39;) //30 + &quot;100&quot; =&gt; &quot;30&quot; + &quot;100&quot; =&gt; &quot;30100&quot;
console.log(true + 100) // 1 + 100 =&gt;101
console.log(false + null) // 0 + 0 =&gt; 0
console.log(&#39;&#39; + 100) // &quot;&quot; + &quot;100&quot; =&gt; &quot;100&quot;

console.log(10 - &#39;5&#39;) // 10 - 5 = &gt;5
console.log(10 - &#39;5px&#39;) // 10 - NaN =&gt;NaN
console.log(10 - null) // 10 - 0 =&gt; 10
console.log(10 - true) // 10 - 1 =&gt; 9

console.log(10 * null) // 10 * 0 =&gt; 0
console.log(10 * true) // 10 * 1 =&gt; 10

console.log(100 / &#39;&#39;) // 100 / 0 =&gt; Infinity

// % 取余（取模）
console.log(100 % &#39;5&#39;) //0
console.log(100 % &#39;3&#39;) //1
</code></pre>
</li>
<li><p>++ ：不管++在前还是++在后都表示自身加 1，++在前表示先自身加 1，然后再进行运算，++在后表示先进行运算然后再自身加 1</p>
</li>
<li><p>– ：不管–在前还是–在后都表示自身减 1，–在前表示先自身减 1，然后再进行运算，–在后表示先进行运算然后再自身减 1</p>
<pre><code class="js">let a = 5
// a++;
++a
console.log(a) //6
let b = 3
// var c = ++b;
// console.log(c,b); //4 4

// var c = 3;
// console.log(c, b); //3 4
let e = 2 //10
//          2   +  3  +  5 + 5   +  7  -  7  -  9   + 9
console.log(e++ + e++ + ++e + e++ + ++e - e++ - ++e + e++) //15
console.log(e) //10
let f = 3 //5
//          3  +  4  +  6  -  5  - 5  +  4   -  5  -  4  +  4   + 4
console.log(f++ + f++ + ++f - --f - f-- + f++ - f-- - f-- + ++f + f++) //6
console.log(f) //5
// ++ -- 同样存在隐式转换
let test1 = &#39;10&#39;
--test1
console.log(test1) //9
</code></pre>
</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code class="js">let a = 10
console.log(a)

// 在a的基础上增加 5
// 给a重新赋值
// a = 15;
// console.log(a);

// a = a + 5;
a += 5 //相当于 a = a + 5；
console.log(a)

let b = 100
b -= 50 //&lt;=&gt; b = b - 50;
console.log(b)
</code></pre>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id="普通比较"><a href="#普通比较" class="headerlink" title="普通比较"></a>普通比较</h3><pre><code class="js">// 1.数据在进行比较的时候，会尽量转为数字进行比较（内置帮我们去转的，属于隐式转换）符合Number的规律
console.log(10 &gt; 5) //true
console.log(10 &gt; &#39;5&#39;) // 10 &gt; 5 true
console.log(true &gt; false) //1 &gt; 0 =&gt; true
console.log(&#39;100px&#39; &gt; 100) // NaN &gt; 100 =&gt; false
console.log(null &gt; &#39;&#39;) // 0 &gt; 0 =&gt;false
console.log(null &gt;= &#39;&#39;) // 0 &gt; 0 =&gt;true
console.log(10 != &#39;20&#39;) //10 != 20 =&gt; true

// 2.null等于undefined 但是null和undefined与其它数据类型都不相等
//null == 0  =&gt;false
console.log(null == &#39;&#39;) //false
console.log(null == undefined) //true
console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
console.log(undefined == undefined) //true
console.log(undefined == 0) //false
console.log(null == undefined) //true
console.log(4 == &#39;abc&#39;) //false
console.log(NaN == NaN) //false
console.log(NaN != NaN) //true
console.log(null == null) //true
console.log(null !== undefined) //true
console.log(3 !== &#39;3&#39;) //true
console.log(null &gt;= 0)
true
console.log(null &lt;= 0)
true
// 3.字符串比较是按照ASCII（Unicode编码）值进行比较的，并且是按位进行比较的一旦某一位比较出结果，就不再比了
console.log(&#39;158&#39; &gt; &#39;1399999999999931231&#39;) //false
// 0 - 9 :48 - 57
// A - Z: 65 - 90
// a - z: 97 - 122
</code></pre>
<h3 id="绝对比较"><a href="#绝对比较" class="headerlink" title="绝对比较"></a>绝对比较</h3><pre><code class="text">=== 绝对等于   !== 绝对不等于

1.不同数据类型一定不相等
  === 绝对等于 （不仅要值相等，数据类型也要一样）
  !==    10 !== &quot;10&quot;   10 != &quot;10&quot;
</code></pre>
<pre><code class="js">console.log(0 == &#39;&#39;) // true
console.log(0 === &#39;&#39;) // false
console.log(9 === &#39;9&#39;) // false
console.log(null === undefined) // false
console.log(&#39;10&#39; !== 10) //true
</code></pre>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><pre><code class="text">&amp;&amp;与  || 或   ! 非
</code></pre>
<pre><code class="js">// &amp;&amp; 与  || 或
console.log(true &amp;&amp; true) //true
console.log(true &amp;&amp; false &amp;&amp; true) //false
console.log(true || false) //true
// 逻辑运算符会自动检测当前数据类型的真假 符合Boolean的规律
// 根据自身的规律返回对应位置的值
// 短路运算
var res = 66 &amp;&amp; &#39;10&#39; &amp;&amp; &#39;哈哈&#39; &amp;&amp; 100
console.log(res) //100
var res1 = 66 &amp;&amp; null &amp;&amp; &#39;哈哈&#39; &amp;&amp; 100
console.log(res1) //null
var res2 = &#39;aa&#39; || &#39;bb&#39; || &#39;&#39;
console.log(res2) //&quot;aa&quot;
var res3 = &#39;&#39; || null || undefined || NaN
console.log(res3) //NaN
</code></pre>
<h3 id="非：取反"><a href="#非：取反" class="headerlink" title="! 非：取反"></a>! 非：取反</h3><pre><code class="js">// 先将当前数据转为布尔值符合Number的规律，然后再进行取反
console.log(!10) // true - &gt; false
console.log(!20) //true -&gt; false
console.log(!&#39;哈哈&#39;) //true -&gt; false
console.log(!&#39;&#39;) //false -&gt; true
</code></pre>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><img src="https://raw.githubusercontent.com/3-ygd/image-hosting/master/运算符优先级.6svw4j0gciw0.webp">

<h2 id="三目运算符-三元表达式"><a href="#三目运算符-三元表达式" class="headerlink" title="三目运算符(三元表达式)"></a>三目运算符(三元表达式)</h2><pre><code class="txt">条件 ? 条件成立执行的代码段 : 条件不成立执行的代码段; (三目运算符又称之为问号冒号表达式，一般应用于简单的判断相当于if..else)
</code></pre>
<pre><code class="js">// 条件  ? 条件成立执行的代码段 : 条件不成立执行的代码段; (三目运算符又称之为问号冒号表达式，一般应用于简单的判断相当于if..else)
// 条件为真执行的是问号后边的代码段  条件为假执行的是冒号后边的代码段
let score = 50
score &gt;= 60 ? console.log(&#39;中午吃点好的&#39;) : console.log(&#39;中午不吃了~~~&#39;)

// 单个数据会自动检测真假
&#39;&#39; ? console.log(&#39;真的&#39;) : console.log(&#39;假的&#39;)
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM 节点操作</title>
    <url>/blog/2020/01/27/DOM%20%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a>DOM 节点操作</h1><h2 id="一、节点操作"><a href="#一、节点操作" class="headerlink" title="一、节点操作"></a>一、节点操作</h2><h3 id="1-DOM-节点"><a href="#1-DOM-节点" class="headerlink" title="1.DOM 节点"></a>1.DOM 节点</h3><p><strong>概念</strong>：DOM 树里每一个内容都称之为节点</p>
<p>​ <strong>节点类型</strong>：</p>
<p>​ <strong>元素节点</strong> ：所有的标签 比如 body、 div | html 是根节点</p>
<p>​ <strong>属性节点</strong> ：所有的属性 比如 href</p>
<p>​ <strong>文本节点</strong> ：所有的文本</p>
<p>​ <strong>其他</strong></p>
<h3 id="2-查找节点"><a href="#2-查找节点" class="headerlink" title="2.查找节点"></a>2.查找节点</h3><p><strong>父节点查找</strong>：</p>
<p>语法：</p>
<pre><code class="js">子元素.parentNode
</code></pre>
<p>注意：该方式会返回最近一级的父节点 找不到返回为 null</p>
<p><strong>子节点查找：</strong></p>
<p>语法：</p>
<pre><code class="js">父元素.children
</code></pre>
<p>注意：该方式可以获得所有元素节点，并且返回的还是一个伪数组</p>
<p><strong>兄弟关系查找</strong></p>
<p>语法：</p>
<pre><code class="js">// 下一个兄弟元素节点
dom元素.nextElementSibling

// 获取上一个兄弟元素节点
dom元素.previousElementSibling
</code></pre>
<h3 id="3-增加节点"><a href="#3-增加节点" class="headerlink" title="3.增加节点"></a>3.增加节点</h3><p><strong>创建节点</strong></p>
<p>语法：</p>
<pre><code class="js">document.createElement(&#39;标签名&#39;)
</code></pre>
<p>说明：即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点</p>
<p><strong>追加节点</strong></p>
<p>语法：</p>
<pre><code class="js">// 插入到父元素的最后一个子元素
父元素.appendChild(要插入的元素)

// 插入到父元素中某个子元素的前面
父元素.insertBefore(要插入的元素，在那个元素前面)
</code></pre>
<p><strong>克隆节点</strong></p>
<p>语法：</p>
<pre><code class="js">// 克隆一个已有的元素节点
dom元素.cloneNode(布尔值)
</code></pre>
<p>说明：该方法会克隆出一个跟原标签一样的元素，括号内传入布尔值</p>
<p>​ 若为 true，则代表克隆时会包含后代节点一起克隆</p>
<p>​ 若为 false, 则代表克隆时不好含后代节点</p>
<p>​ 默认为 false</p>
<h3 id="4-删除节点"><a href="#4-删除节点" class="headerlink" title="4.删除节点"></a>4.删除节点</h3><p>语法：</p>
<pre><code class="js">父元素.removeChild(要删除的元素)
</code></pre>
<p>注意：</p>
<p>​ 如不存在父子关系则删除不成功</p>
<p>​ 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从 html 中删除节点</p>
<h2 id="二、时间对象"><a href="#二、时间对象" class="headerlink" title="二、时间对象"></a>二、时间对象</h2><h3 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1.实例化"></a>1.实例化</h3><p>说明：</p>
<p>​ 在代码中发现了 new 关键字时，一般将这个操作称为<strong>实例化</strong></p>
<p>​ 创建一个时间对象并获取时间</p>
<p>语法：</p>
<pre><code class="js">// 获取当前的时间
let date = new Date()

// 获取指定时间
let date = new Date(&#39;1966-10-01&#39;)
</code></pre>
<h3 id="2-时间对象方法"><a href="#2-时间对象方法" class="headerlink" title="2.时间对象方法"></a>2.时间对象方法</h3><p>说明： 因为时间对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式</p>
<p><strong>以下为常用的一些方法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648481367(1).vkvql1yec2o.webp">

<h3 id="3-时间戳"><a href="#3-时间戳" class="headerlink" title="3.时间戳"></a>3.时间戳</h3><p>概念：是指 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的毫秒数，它是一种特殊的计量时间的方式</p>
<p><strong>使用 getTime() 方法</strong> 获取</p>
<pre><code class="js">// 实例化时间对象
let date = new Date()
// 获取时间戳
console.log(date.getTime())
</code></pre>
<p><strong>简写 + new Date()</strong> 获取</p>
<pre><code class="js">// 获取时间戳
console.log(+new Date())
</code></pre>
<p><strong>使用 Date.now()</strong> 获取</p>
<pre><code class="js">// 获取时间戳
console.log(Date.now())

// 注意：
// 该方法无需实例化
// 该方法只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳
</code></pre>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>节点操作</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM- 操作浏览器</title>
    <url>/blog/2020/02/26/BOM-%20%E6%93%8D%E4%BD%9C%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h1 id="BOM-操作浏览器"><a href="#BOM-操作浏览器" class="headerlink" title="BOM- 操作浏览器"></a>BOM- 操作浏览器</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><h3 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM(浏览器对象模型)"></a>BOM(浏览器对象模型)</h3><p>BOM(Browser Object Model ) 是浏览器对象模型</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.2m9rwhel15q0.webp">

<p>window 是浏览器内置中的全局对象，我们所学习的所有 Web APIs 的知识内容都是基于 window 对象实现的</p>
<p>window 对象下包含了 navigator、location、document、history、screen 5 个属性，即所谓的 BOM （浏览器对象模型）</p>
<p>document 是实现 DOM 的基础，它其实是依附于 window 的属性。</p>
<p>注：依附于 window 对象的所有属性和方法，使用时可以省略 window</p>
<h3 id="定时器-延时函数"><a href="#定时器-延时函数" class="headerlink" title="定时器-延时函数"></a>定时器-延时函数</h3><p>JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout</p>
<pre><code class="js">// 语法：
setTimeout(回调函数，等待的毫秒数)
</code></pre>
<p>setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略 window</p>
<p><strong>清除延时函数</strong>：</p>
<pre><code class="js">// 语法：
let timer = setTimeout(回调函数，等待的毫秒数)
clearTimeout(timer) // 清除操作
</code></pre>
<p><strong>结合递归函数可以使用 setTimeout 实现 setInterval 一样的功能</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484053(1).11f3ojnjbrgw.webp">

<p><strong>两种定时器对比：</strong></p>
<ul>
<li>setInterval 的特征是重复执行，首次执行会延时</li>
<li>setTimeout 的特征是延时执行，只执行 1 次</li>
<li>setTimeout 结合递归函数，能模拟 setInterval 重复执行</li>
<li>clearTimeout 清除由 setTimeout 创建的定时任务</li>
</ul>
<h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分</p>
<p><strong>常用属性和方法：</strong></p>
<ul>
<li>href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484228(1).28dyzfbpmqtc.webp">

<ul>
<li>reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484291(1).1y7oon8x7fts.webp">

<h3 id="histroy-对象"><a href="#histroy-对象" class="headerlink" title="histroy 对象"></a>histroy 对象</h3><p>history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等</p>
<p><strong>常用属性和方法：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648484385(1).3ybl9j8q6h40.webp">

<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>1、生命周期永久生效，除非手动删除 否则关闭页面也会存在</p>
<p>2、可以多窗口（页面）共享（同一浏览器可以共享）</p>
<p>3、以键值对的形式存储使用</p>
<pre><code class="js">// 存储数据
localStorage.setItem(key, value)

// 获取数据
localStorage.getItem(key)

// 删除数据
localStorage.removeItem(key)
</code></pre>
<p><strong>存储复杂</strong> 数据类型存储</p>
<p>本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成 JSON 字符串,在存储到本地</p>
<p><strong>JSON.stringify</strong>(复杂数据类型)</p>
<p>​ 将复杂数据转换成 JSON 字符串 <strong>存储</strong> 本地存储中</p>
<p><strong>JSON.parse</strong>(JSON 字符串)</p>
<p>​ 将 JSON 字符串转换成对象 <strong>取出</strong> 时候使用</p>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>window</tag>
        <tag>setTimeout</tag>
        <tag>histroy对象</tag>
      </tags>
  </entry>
  <entry>
    <title>获取元素大小和位置</title>
    <url>/blog/2020/02/20/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="获取元素大小和位置"><a href="#获取元素大小和位置" class="headerlink" title="获取元素大小和位置"></a>获取元素大小和位置</h1><h2 id="一、scroll-家族"><a href="#一、scroll-家族" class="headerlink" title="一、scroll 家族"></a>一、scroll 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的<strong>内容</strong>总宽高（不包含滚动条）返回值不带单位</li>
<li>scrollWidth 和 scrollHeight</li>
</ul>
<p>获取位置:</p>
<ul>
<li><p>获取元素内容往左、往上滚出去看不到的距离</p>
</li>
<li><p><strong>scrollLeft</strong>和<strong>scrollTop</strong></p>
</li>
<li><p>这两个属性是可以<strong>修改</strong>的</p>
<pre><code class="js">// 例如
div.addEventListener(&#39;scroll&#39;, function () &#123;
  console.log(this.scrollTop)
&#125;)
</code></pre>
</li>
</ul>
<p>注意：开发中，我们经常检测页面滚动的距离，比如页面滚动 100 像素，就可以显示一个元素，或者固定一个元素</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648483445(1).blsri7mcqqw.webp">

<h2 id="二、offset-家族"><a href="#二、offset-家族" class="headerlink" title="二、offset 家族"></a>二、offset 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的自身宽高、包含元素自身设置的宽高、padding、border</li>
<li>offsetWidth 和 offsetHeight</li>
</ul>
<p>获取位置：</p>
<ul>
<li>获取元素距离自己<strong>定位父级</strong>元素的左、上距离</li>
<li><strong>offsetLeft</strong>和<strong>offsetTop</strong> 注意是只读属性</li>
</ul>
<h2 id="三、client-家族"><a href="#三、client-家族" class="headerlink" title="三、client 家族"></a>三、client 家族</h2><p>获取宽高：</p>
<ul>
<li>获取元素的可见部分宽高（不包含边框，滚动条等）</li>
<li>clientWidth 和 clientHeight</li>
</ul>
<p>获取位置：</p>
<ul>
<li>获取左边框和上边框宽度</li>
<li>clientLeft 和 clientTop 注意是只读属性</li>
</ul>
<p>触发时机：会在窗口尺寸改变的时候触发事件 | 检测屏幕宽度</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.offset 家族</p>
<ul>
<li><p>获取元素自身大小：包括自身设置的宽高、padding、border</p>
</li>
<li><p>获取元素距离定位父级的左和上距离 只读属性</p>
<p>2.client 家族</p>
</li>
<li><p>获取元素可见区域的大小</p>
</li>
<li><p>获取元素左、上边框距离 只读属性</p>
<p>3.scroll 家族</p>
</li>
<li><p>获取元素内容的总大小</p>
</li>
<li><p><strong>获取元素向左向上滚出去看不见的</strong>距离 可读写属性</p>
</li>
</ul>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>scroll</tag>
        <tag>offset</tag>
        <tag>client</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动事件和加载事件</title>
    <url>/blog/2020/02/13/%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="滚动事件和加载事件"><a href="#滚动事件和加载事件" class="headerlink" title="滚动事件和加载事件"></a>滚动事件和加载事件</h1><h2 id="一、滚动事件"><a href="#一、滚动事件" class="headerlink" title="一、滚动事件"></a>一、滚动事件</h2><p>触发时机：当页面进行滚动时触发的事件</p>
<p>为什么要使用？</p>
<p>​ 因为很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部</p>
<p>事件名：scroll</p>
<pre><code class="js">// 语法
window.addEventListener(&#39;scroll&#39;, function () &#123;
  // 执行的操作
&#125;)

// 给 window 或 document 添加 scroll 事件
</code></pre>
<p>监听那个元素的内部滚动直接给某个元素加即可</p>
<h2 id="二、加载事件"><a href="#二、加载事件" class="headerlink" title="二、加载事件"></a>二、加载事件</h2><p>触发时机：加载外部资源（如图片、外联 CSS 和 JavaScript 等）加载完毕时触发的事件</p>
<p>为什么要使用？</p>
<ul>
<li>有些时候需要等页面资源全部处理完了做一些事情</li>
<li>老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到</li>
</ul>
<p>事件名：load</p>
<p>例如：给 window 添加 load 事件</p>
<pre><code class="js">// 语法
// 页面加载事件
window.addEventListener(&#39;load&#39;, function () &#123;
  // 执行的操作
&#125;)

// 给 window 添加 load 事件
</code></pre>
<p>注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定 load 事件</p>
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>滚动事件</tag>
        <tag>加载事件</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM- 事件对象、事件流、事件委托</title>
    <url>/blog/2020/02/06/DOM-%20%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%B5%81%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h1 id="DOM-事件对象、事件流、事件委托"><a href="#DOM-事件对象、事件流、事件委托" class="headerlink" title="**DOM- 事件对象、事件流、事件委托"></a>**DOM- 事件对象、事件流、事件委托</h1><h2 id="一、事件对象"><a href="#一、事件对象" class="headerlink" title="一、事件对象"></a>一、事件对象</h2><h3 id="1-获取事件对象"><a href="#1-获取事件对象" class="headerlink" title="1.获取事件对象"></a>1.获取事件对象</h3><p><strong>事件对象是什么：</strong></p>
<ul>
<li>也是个对象，这个对象里有事件触发时的相关信息</li>
<li>例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息</li>
</ul>
<p><strong>如何获取：</strong></p>
<ul>
<li>在事件绑定的回调函数的第一个参数就是事件对象</li>
<li>一般命名为 event、ev、e</li>
</ul>
<pre><code class="js">// 例如
元素.addEventListener(&#39;click&#39;, function (e) &#123;&#125;) //  这里的e就是事件对象参数
</code></pre>
<h3 id="2-事件对象常用属性"><a href="#2-事件对象常用属性" class="headerlink" title="2.事件对象常用属性"></a>2.事件对象常用属性</h3><p><strong>部分常用属性：</strong></p>
<ul>
<li>type：获取当前的事件类型</li>
<li>clientX&#x2F;clientY：获取光标相对于浏览器可见窗口左上角的位置</li>
<li>offsetX&#x2F;offsetY：获取光标相对于当前 DOM 元素左上角的位置</li>
<li>key：用户按下的键盘键的值</li>
</ul>
<p>注意：现在不提倡使用 keyCode</p>
<h3 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h3><h3 id="1-事件流与两个阶段说明"><a href="#1-事件流与两个阶段说明" class="headerlink" title="1.事件流与两个阶段说明"></a>1.事件流与两个阶段说明</h3><p>事件流：指的是事件完整执行过程中的流动路径</p>
<p>简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父</p>
<h3 id="2-事件捕获和事件冒泡"><a href="#2-事件捕获和事件冒泡" class="headerlink" title="2.事件捕获和事件冒泡"></a>2.事件捕获和事件冒泡</h3><p><strong>事件冒泡</strong></p>
<ul>
<li>概念：当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡</li>
<li>简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件</li>
<li>注意：事件冒泡是默认存在的</li>
</ul>
<p><strong>事件捕获</strong></p>
<ul>
<li><p>概念： 从 DOM 的根元素开始去执行对应的事件 (从外到里)</p>
</li>
<li><p>说明：addEventListener 第三个参数传入 true 代表是捕获阶段触发（很少使用）</p>
<p>​ 若传入 false 代表冒泡阶段触发，默认就是 false</p>
<p>​ 若是用 L0 事件监听，则只有冒泡阶段，没有捕获</p>
</li>
</ul>
<p><strong>阻止事件流动的方式</strong></p>
<p>语法：</p>
<pre><code class="js">事件对象.stopPropagation()

// 注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效
</code></pre>
<p><strong>阻止默认行为</strong></p>
<p>使用场景：l 比如链接点击不跳转，表单域的不提交</p>
<p>语法：</p>
<pre><code class="js">e.preveentDefault()
</code></pre>
<p><strong>两种注册事件的区别：</strong></p>
<p>传统 on 注册（L0）</p>
<ul>
<li>同一个对象,后面注册的事件会覆盖前面注册(同一个事件)</li>
<li>直接使用 null 覆盖偶就可以实现事件的解绑</li>
<li>都是冒泡阶段执行的</li>
</ul>
<p>事件监听注册（L2）</p>
<ul>
<li>语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获)</li>
<li>后面注册的事件不会覆盖前面注册的事件(同一个事件)</li>
<li>可以通过第三个参数去确定是在冒泡或者捕获阶段执行</li>
<li>必须使用 removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段)</li>
<li>匿名函数无法被解绑</li>
</ul>
<h3 id="3-阻止事件流动"><a href="#3-阻止事件流动" class="headerlink" title="3.阻止事件流动"></a>3.阻止事件流动</h3><h3 id="三、事件委托"><a href="#三、事件委托" class="headerlink" title="三、事件委托"></a>三、事件委托</h3><p><strong>原理：</strong>事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发</p>
<p><strong>使用场景：</strong>当子元素是动态创建并且需要注册事件的时候，推荐使用事件委托</p>
<p><strong>优点：</strong>给父级元素加事件（可以提高性能）</p>
<p><strong>实现：</strong>事件对象.target 可以获得真正触发事件的元素</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648482711(1).2qvzd2cnol40.webp">
]]></content>
      <categories>
        <category>WebAPI</category>
      </categories>
      <tags>
        <tag>WebAPI</tag>
        <tag>事件对象</tag>
        <tag>事件流</tag>
        <tag>事件委托</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-类-继承</title>
    <url>/blog/2020/04/10/ES6-%E7%B1%BB-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="ES6-类-继承"><a href="#ES6-类-继承" class="headerlink" title="ES6-类-继承"></a>ES6-类-继承</h1><h2 id="1、类"><a href="#1、类" class="headerlink" title="1、类"></a>1、类</h2><p><strong>概念:</strong> 将对象中公共的方法或者属性封装成一个模板 (es5 中的构造函数)</p>
<p><strong>作用:</strong> 创建对象</p>
<pre><code class="js">// 语法
class 自定义类名 &#123;&#125;
let 实例对象 = new 类名()
</code></pre>
<p><strong>注意事项:</strong></p>
<ul>
<li>通过类创建对象必须使用 new 关键字</li>
<li>类的命名规范与构造函数的命名规范一样(帕斯卡命名法)</li>
<li>创建对象后类名后面必须加()</li>
</ul>
<pre><code class="js">// 设置属性语法
class 自定义类名 &#123;
      constructor(形参,形参) &#123;
         this.属性 = 形参;
         this.属性 = 形参;
     &#125;
&#125;

// 类设置方法
class 类名 &#123;
    constructor() &#123;&#125;
    方法名() &#123;&#125;
&#125;
注意事项:
1. 类中设置方法名,不能添加function关键字
2. 类中方法之间不需要任何的分割符
</code></pre>
<p><strong>constructor 介绍:</strong></p>
<ul>
<li>类中默认的构造函数,用来初始化操作</li>
<li>constructor 构造函数用来接收创建对象时候传递的参数,创建对象并返回</li>
<li>通过 new + 类名创建对象的时候,程序就会自动调用类中 constructor’</li>
<li>如果我们在类中没有定义 constructor 函数,程序在执行的时候也会自动创建的</li>
</ul>
<p><strong>继承(子类继承父类)</strong></p>
<pre><code class="js">// 语法:

class 子类 extends 父类 &#123;&#125;
</code></pre>
<pre><code class="js">// 例如
//父类
class Student &#123;
  ks(ksName) &#123;
    alert(ksName)
  &#125;
&#125;
//子类继承父类
class C_student extends Student &#123;&#125;
class A_student extends Student &#123;&#125;
var zs = new C_student()
var ls = new A_student()
zs.ks(&#39;汉语&#39;)
ls.ks(&#39;英语&#39;)
</code></pre>
<p><strong>super 关键字</strong></p>
<pre><code class="js">作用：子类继承父类时候,如果子类中设置了构造函数,则通过super关键字调用父类中的构造函数

语法:  super(参数)

子类中如果要执行父类中的方法,可以通过super调用父类中的方法
super.方法名()
</code></pre>
<p><strong>call,bind,apply</strong></p>
<p><strong>作用：</strong>修改 this 指向</p>
<pre><code class="js">call作用: 调用函数 + 修改this指向
call语法: 函数.call(对象,参数1,参数2...)

apply作用: 调用函数 + 修改this指向
apply语法:函数.apply(对象,[值,值]);

bind作用: 不调用函数 + 修改this指向
bind语法: 函数.bind(对象,参数1,参数2...)
bind返回值: 返回当前函数
</code></pre>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>继承</tag>
        <tag>class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery-动画-操作元素</title>
    <url>/blog/2020/05/02/JQuery-%E5%8A%A8%E7%94%BB-%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="JQuery-动画-操作元素"><a href="#JQuery-动画-操作元素" class="headerlink" title="JQuery-动画-操作元素"></a>JQuery-动画-操作元素</h1><h3 id="1-JQuery-动画"><a href="#1-JQuery-动画" class="headerlink" title="1. JQuery 动画"></a>1. JQuery 动画</h3><h4 id="1-1-显示-隐藏动画"><a href="#1-1-显示-隐藏动画" class="headerlink" title="1.1 显示-隐藏动画"></a>1.1 显示-隐藏动画</h4><ul>
<li><p><code>show()</code></p>
<pre><code class="js">语法:
$(对象).show([speed, [easing], [fn]])
//参数介绍:
1. show() 方法中的3个参数可以不用设置, 显示元素没有动画效果
2. 第一个参数表示动画速度,可以设置 &#39;slow&#39; , &#39;normal&#39;, &#39;fast&#39; 或者表示动画的时长毫秒
3. 第二个参数表示动画切换效果, 默认 &#39;swing[摇动摆动,由快到慢]&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示动画完成后执行的函数(回调函数)

//代码演示1,未设置任何参数,控制元素显示,没有动画效果
var btn = $(&#39;input&#39;);
var div = $(&#39;div&#39;);
btn.click(function()&#123;
    div.show();
&#125;)

//代码演示2,设置第一个参数,元素按照动画显示
var btn = $(&#39;input&#39;);
var div = $(&#39;div&#39;);
btn.click(function()&#123;
    div.show(&#39;fast&#39;);
&#125;)

//代码演示3,设置两个参数,元素实现切换效果
btn.click(function()&#123;
    div.show(&#39;normal&#39;,&#39;swing&#39;);
&#125;)

//代码4演示,设置第三个参数,动画执行完后回调函数
btn.click(function()&#123;
    div.show(&#39;normal&#39;,&#39;swing&#39;, function()&#123;
        alert(&#39;动画完成&#39;);
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><code>hide()</code></p>
<pre><code class="js">语法:
$(对象).hide([speed, [easing], [fn]);
//参数介绍:
1. 参数可以省略,隐藏元素没有动画效果
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行
//代码演示同上
</code></pre>
</li>
<li><p><strong>课堂案例-好友列表案例</strong></p>
</li>
</ul>
<h4 id="1-2-滑动动画"><a href="#1-2-滑动动画" class="headerlink" title="1.2 滑动动画"></a>1.2 滑动动画</h4><ul>
<li><p><code>slideDown()</code></p>
<pre><code class="js">介绍: slideDown()  显示元素(通过改变元素高度)
语法:
// $(对象).slideDown([speed],[easing],[fn]);

参数介绍:
1. 参数可以省略
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行

//代码演示1:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown();
&#125;)

//代码演示2
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown(&#39;fast&#39;);
&#125;)

//代码演示3
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown(&#39;fast&#39;, &#39;linear&#39;);
&#125;)

//代码演示4
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideDown(&#39;fast&#39;, &#39;linear&#39;, function()&#123;
        alert(&#39;动画完成&#39;)
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><code>slideUp()</code></p>
<pre><code class="js">介绍: 通过高度变化（向上减小）来动态地隐藏所有匹配的元素
语法:
// $(对象).slideUp([speed,[easing],[fn]])

参数介绍:
1. 参数可以省略
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行

//代码演示:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).slideUp(&#39;fast&#39;, &#39;linear&#39;, function()&#123;
        console.log(&#39;动画完成&#39;)
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><strong>小米课堂案例</strong></p>
<pre><code class="js">//1. 鼠标进入大盒子显示内容区域,鼠标离开隐藏内容区域
$(&#39;.nav&#39;).hover(
  function () &#123;
    $(&#39;.content&#39;).slideDown(&#39;fast&#39;)
    //2.给每一项设置鼠标进入事件
    $(this)
      .find(&#39;a&#39;)
      .mouseenter(function () &#123;
        $(this).css(&#39;color&#39;, &#39;red&#39;).parent().siblings().find(&#39;a&#39;).css(&#39;color&#39;, &#39;#888&#39;)
        //获取索引
        var index = $(this).parent().index()
        //显示内容区域
        $(&#39;.item&#39;).eq(index).show().siblings().hide()
      &#125;)
  &#125;,
  function () &#123;
    $(&#39;.content&#39;).slideUp()
    $(&#39;a&#39;).css(&#39;color&#39;, &#39;#888&#39;)
  &#125;
)
</code></pre>
</li>
</ul>
<h4 id="1-3-淡入淡出动画"><a href="#1-3-淡入淡出动画" class="headerlink" title="1.3 淡入淡出动画"></a>1.3 淡入淡出动画</h4><ul>
<li><p><code>fadeIn()</code></p>
<pre><code class="js">介绍: 通过透明度的变化来实现所有匹配元素的淡入效果[显示]
语法:
// $(对象).fadeIn([speed],[easing],[fn])

参数介绍:
1. 参数可以不用设置
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行

//代码演示1:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeIn();
&#125;)

//代码演示2
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeIn(&#39;fast&#39;);
&#125;)

//代码演示3
$(&#39;input&#39;).click(function()&#123;
     $(&#39;div&#39;).fadeIn(&#39;fast&#39;, &#39;linear&#39;);
&#125;)

//代码演示4
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeIn(&#39;fast&#39;, &#39;linear&#39;, function() &#123;
         alert(&#39;动画完成&#39;);
    &#125;);
&#125;)
</code></pre>
</li>
<li><p><code>fadeOut()</code></p>
<pre><code class="js">介绍: 通过透明度的变化来实现所有匹配元素的淡出效果[隐藏]
语法:
// $(对象).fadeOut([speed],[easing],[fn])

参数介绍:
1. 参数可以不用设置
2. 第一个参数表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间
3. 第二个参数表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. 第三个参数表示回调函数,动画完成后执行
</code></pre>
</li>
<li><p><code>fadeTo()</code></p>
<pre><code class="js">介绍:  可以自定义透明度动画效果
语法:
//  $(对象).fadeTo([[speed],opacity,[easing],[fn]])

参数介绍:
1. speed 表示动画速度,可以设置 &#39;fast&#39;, &#39;normal&#39;, &#39;slow&#39; 或者自定义毫秒时间  [必须设置]
2. opacity 表示透明度, 0 - 1 之间必须设置
3. easing 表示动切换效果, 默认值 &#39;swing&#39; 或者 设置 &#39;linear&#39;
4. fn 表示回调函数,动画完成后执行

//代码演示:
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).fadeTo(1000, 0.1);
&#125;)
</code></pre>
</li>
<li><p><strong>课堂高亮显示案例</strong></p>
<pre><code class="js">$(&#39;.item&#39;).hover(
  function () &#123;
    $(this).fadeTo(&#39;fast&#39;, 1, &#39;linear&#39;).siblings().fadeTo(&#39;fast&#39;, 0.5, &#39;linear&#39;)
  &#125;,
  function () &#123;
    $(&#39;.item&#39;).fadeTo(&#39;fast&#39;, 1)
  &#125;
)
// 问题: 当鼠标无限次晃动,动画会一直排队执行

// 解决: 通过stop()停止动画排队,必须写到动画前
$(&#39;.item&#39;).hover(
  function () &#123;
    $(this).stop().fadeTo(&#39;fast&#39;, 1, &#39;linear&#39;).siblings().stop().fadeTo(&#39;fast&#39;, 0.5, &#39;linear&#39;)
  &#125;,
  function () &#123;
    $(&#39;.item&#39;).stop().fadeTo(&#39;fast&#39;, 1)
  &#125;
)
</code></pre>
</li>
</ul>
<h4 id="1-5-自定义动画"><a href="#1-5-自定义动画" class="headerlink" title="1.5 自定义动画"></a>1.5 自定义动画</h4><ul>
<li><p><code>animate()</code></p>
<pre><code class="js">介绍: 用于创建自定义动画的函数。
语法:
// $(对象).animate(params,[speed],[easing],[fn]);

参数介绍:
1.params 一组包含作为动画属性和终值的样式属性和及其值的集合   [必须设置]
2.speed  三种预定速度之一的字符串(&quot;slow&quot;,&quot;normal&quot;, or &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)
3.easing 默认jQuery提供&quot;linear&quot; 和 &quot;swing&quot;.
4.fn:在动画完成时执行的函数

//代码演示1
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;)
&#125;)

//代码演示2
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;, &#39;fast&#39;)
&#125;)

//代码演示3
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;, &#39;fast&#39;, &#39;linear&#39;)
&#125;)

//代码演示4
$(&#39;input&#39;).click(function()&#123;
    $(&#39;div&#39;).animate(&#123;
        &#39;left&#39;: &#39;500px&#39;
    &#125;, &#39;fast&#39;, &#39;linear&#39;, function()&#123;
        alert(&#39;动画完成&#39;)
    &#125;)
&#125;)

//注意:
1. animate自定义动画,无法实现颜色动画效果,如果需要改变颜色,需要单独下载插件实现
2. 无法直接实现css中转化效果,如果需要实现,则可以通过添加类名得的方式实现
3. 单独的属性,可以使用驼峰命名法 (&#39;marginLeft&#39; 替代 &#39;margin-left&#39;)

https://www.runoob.com/jquery/eff-animate.html
</code></pre>
</li>
<li><p><strong>课堂案例-手风琴案例</strong></p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>搭建 HTML 结构</p>
<pre><code class="html">&lt;div class=&quot;box&quot;&gt;
  &lt;ul&gt;
    &lt;!--注意这里写结构的时候不需要加类名current--&gt;
    &lt;li class=&quot;current&quot;&gt;
      &lt;img src=&quot;imgs/c1.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
      &lt;img src=&quot;imgs/c.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;img src=&quot;imgs/h1.jpg&quot; alt=&quot;&quot; class=&quot;small&quot; /&gt;
      &lt;img src=&quot;imgs/h.png&quot; alt=&quot;&quot; class=&quot;big&quot; /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>设置 CSS 样式</p>
<pre><code class="css">.box &#123;
  width: 773px;
  background: url(&#39;imgs/bg.png&#39;) no-repeat;
  padding: 10px;
  margin: 50px auto;
&#125;
.box ul &#123;
  overflow: hidden;
&#125;
.box li &#123;
  width: 70px;
  height: 70px;
  float: left;
  position: relative;
  margin-right: 5px;
&#125;
.box li img &#123;
  position: absolute;
&#125;
.small &#123;
  width: 70px;
  height: 70px;
&#125;
.big &#123;
  display: none;
&#125;
.box .current .big &#123;
  display: block;
&#125;
.box .current .small &#123;
  display: none;
&#125;
.box .current &#123;
  width: 224px;
&#125;
</code></pre>
</li>
<li><p>设置 JS 代码</p>
<ul>
<li><p>鼠标移动到当前元素(li)上,修改当前 li 的宽度及兄弟元素的宽度</p>
<pre><code class="js">$(this).animate(&#123; width: 224 &#125;).siblings().animate(&#123; width: 70 &#125;)
</code></pre>
</li>
<li><p>设置当前元素中的大图片显示,小图片隐藏</p>
<pre><code class="js">$(this).find(&#39;.big&#39;).fadeIn().siblings().fadeOut()
</code></pre>
</li>
<li><p>设置当前元素兄弟元素中大图片隐藏,小图片显示</p>
<pre><code class="js">$(this).siblings().find(&#39;.big&#39;).fadeOut().siblings().fadeIn()
</code></pre>
</li>
<li><p><strong>注意: 在所有动画前加 stop()方法停止动画排队</strong></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-JQ-操作元素属性"><a href="#3-JQ-操作元素属性" class="headerlink" title="3.JQ 操作元素属性"></a>3.JQ 操作元素属性</h3><h4 id="1-1-回顾-webAPI-中操作标签属性"><a href="#1-1-回顾-webAPI-中操作标签属性" class="headerlink" title="1.1 回顾 webAPI 中操作标签属性"></a>1.1 回顾 webAPI 中操作标签属性</h4><ul>
<li><p>操作标签内置系统属性</p>
<ul>
<li><code>getAttribute(属性名)</code></li>
<li><code>setAttribute(属性名, 值)</code></li>
</ul>
</li>
<li><p>操作标签自定义属性</p>
<ul>
<li><p><code>getAttribute(属性名)</code> <code>setAttribute(属性名, 值)</code></p>
</li>
<li><p><code>DOM.dataset</code></p>
<pre><code class="js">DOM.dataset  返回的是一个对象
☞ 获取自定义属性值:   DOM.dataset.属性名
☞ 设置自定义属性值:   DOM.dataset.自定义属性名 = 值;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-JQ-操作元素属性"><a href="#1-2-JQ-操作元素属性" class="headerlink" title="1.2 JQ 操作元素属性"></a>1.2 JQ 操作元素属性</h4><ul>
<li><p><strong>获取标签内置系统属性</strong></p>
<pre><code class="js">语法: $(对象).prop(&#39;属性名&#39;)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.prop(&#39;class&#39;)
console.log(res)
</code></pre>
</li>
<li><p><strong>设置标签内置系统属性</strong></p>
<pre><code class="js">语法: $(对象).prop(&#39;属性名&#39;, 值)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.prop(&#39;class&#39;, 123)

//备注如果设置多个可以通过对象的方式设置,例如:
$(&#39;input&#39;).prop(&#123;
  id: &#39;test&#39;,
  name: &#39;abc&#39;
&#125;)
</code></pre>
</li>
<li><p><strong>获取标签自定义属性</strong></p>
<pre><code class="js">语法: $(对象).attr(自定义属性名)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.attr(&#39;data-myname&#39;)
</code></pre>
</li>
<li><p><strong>设置标签自定义属性</strong></p>
<pre><code class="js">语法: $(对象).attr(自定义属性名, 值)

//代码演示:
var div = $(&#39;div&#39;)
var res = div.attr(&#39;myAge&#39;, 18)
</code></pre>
</li>
<li><p><strong>备注</strong></p>
<pre><code class="js">$(对象).attr() 既可以操作标签自定义属性也可以操作标签内置属性
</code></pre>
</li>
</ul>
<h3 id="4-JQ-操作标签中的值"><a href="#4-JQ-操作标签中的值" class="headerlink" title="4. JQ 操作标签中的值"></a>4. JQ 操作标签中的值</h3><h4 id="1-1-获取-x2F-设置表单控件中的值"><a href="#1-1-获取-x2F-设置表单控件中的值" class="headerlink" title="1.1 获取&#x2F;设置表单控件中的值"></a>1.1 获取&#x2F;设置表单控件中的值</h4><ul>
<li><p><strong>获取</strong></p>
<pre><code class="js">语法: $(对象).val()
</code></pre>
</li>
<li><p><strong>设置</strong></p>
<pre><code class="js">语法: $(对象).val(值)
</code></pre>
</li>
</ul>
<h4 id="1-2-获取-x2F-设置普通标签中的值"><a href="#1-2-获取-x2F-设置普通标签中的值" class="headerlink" title="1.2 获取&#x2F;设置普通标签中的值"></a>1.2 获取&#x2F;设置普通标签中的值</h4><ul>
<li><p><strong>获取</strong></p>
<pre><code class="js">语法: $(对象).text() // 特点与原生js中的innerText一样

$(对象).html() // 特点与原生js中的innerHTML一样
</code></pre>
</li>
<li><p><strong>设置</strong></p>
<pre><code class="js">语法: $(对象).text(值) // 特点与原生js中的innerText一样

$(对象).html(值) // 特点与原生js中的innerHTML一样
</code></pre>
</li>
</ul>
<h4 id="1-3-课堂案例-小计功能"><a href="#1-3-课堂案例-小计功能" class="headerlink" title="1.3 课堂案例-小计功能"></a>1.3 课堂案例-小计功能</h4><ul>
<li><p>步骤:</p>
<ol>
<li><p>设置 HTML 结构</p>
</li>
<li><p>设置 CSS 样式</p>
</li>
<li><p>实现具体功能</p>
<ol>
<li><p>点击<code>加号/减号</code>修改输入框中的值</p>
<pre><code class="js">//获取输入框中的值: 当前按钮的兄弟元素
var num_v = $(this).siblings(&#39;input&#39;).val()

// 将当前值增加1
num_v++

//将当前值赋值给输入框
$(this).siblings(&#39;input&#39;).val(num_v)
</code></pre>
</li>
<li><p>点击<code>加号/减号</code>计算小计总价</p>
<pre><code class="js">补充: 价格保留2位小数  toFixed(2)

例如:  var num = 123;
      num = num.toFixed(2);
</code></pre>
<pre><code class="js">//计算总价: 当前商品数量 * 商品单价
var money = num_v * $(this).parent().siblings(&#39;.sprice&#39;).find(&#39;strong&#39;).text()

//将当前总价设置给总价标签
$(this).parent().siblings(&#39;.t_price&#39;).find(&#39;strong&#39;).text(money.toFixed(2))
</code></pre>
</li>
<li><p>用户修改输入框中的值计算小计总结</p>
<pre><code class="js">$(&#39;.num1 input&#39;).change(function () &#123;
  //获取当前输入框中的值
  var num_v = $(this).val()

  //计算总价: 当前商品数量 * 商品单价
  var money = num_v * $(this).parent().siblings(&#39;.sprice&#39;).find(&#39;strong&#39;).text()

  //将当前总价设置给总价标签
  $(this).parent().siblings(&#39;.t_price&#39;).find(&#39;strong&#39;).text(money.toFixed(2))
&#125;)
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>####1.4 课堂案例-商品总数-总价功能</p>
<ul>
<li><p>步骤</p>
<ol>
<li><p>设置 HTML 结构</p>
</li>
<li><p>设置 CSS 样式</p>
</li>
<li><p>实现功能</p>
<ol>
<li><p><strong>JQ 遍历对象,获取对象中的值</strong></p>
<pre><code class="js">&lt;ul&gt;
  &lt;li&gt;12&lt;/li&gt;
  &lt;li&gt;12&lt;/li&gt;
  &lt;li&gt;12&lt;/li&gt;
&lt;/ul&gt;
如何获取li标签中的值?

语法:
$对象.each(function(index, item)&#123; &#125;)

参数介绍:
1. index 伪数组中的索引值
2. item 伪数组中的每一个DOM对象

注意:
1. each遍历后item是一个dom对象不是JQ对象
</code></pre>
</li>
<li><p><strong>JQ 遍历方式二</strong></p>
<pre><code class="js">//语法:
$.each(数组对象, function(index, item)&#123; &#125;)

//参数介绍:
index  数组中索引值
item   数组中的每一个值
</code></pre>
</li>
<li><p>实现总数求和功能</p>
<pre><code class="js">var num_sum = 0
//数量求和: 获取页面中的每一个input标签中的值累加
$(&#39;.num1 input&#39;).each(function (index, item) &#123;
  num_sum += parseInt($(item).val())
&#125;)
//将总和设置给对应的标签
$(&#39;.product_num strong&#39;).text(num_sum)
</code></pre>
</li>
<li><p>实现总计求和功能</p>
<pre><code class="js">var money_sum = 0
$(&#39;.t_price strong&#39;).each(function (i, item) &#123;
  money_sum += Number($(item).text())
&#125;)
//将总价设置给对应的标签
$(&#39;.product_money strong&#39;).text(money_sum.toFixed(2))
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="5-JQ-删除元素"><a href="#5-JQ-删除元素" class="headerlink" title="5. JQ 删除元素"></a>5. JQ 删除元素</h3><h4 id="1-1-删除元素-x2F-元素中内容"><a href="#1-1-删除元素-x2F-元素中内容" class="headerlink" title="1.1 删除元素&#x2F;元素中内容"></a>1.1 删除元素&#x2F;元素中内容</h4><ul>
<li><p><code>remove()</code></p>
<pre><code class="js">语法: $对象.remove()

// 特点: 从页面中将当前标签删除
</code></pre>
</li>
<li><p><code>empty()</code></p>
<pre><code class="js">语法: $对象.empty()
// 特点: 将标签中的所有内容清空
</code></pre>
</li>
<li><p><code>html()</code></p>
<pre><code class="js">语法: $对象.html(&#39;&#39;)
//特点: 将标签中的所有内容清空,当标签标签依然保留
</code></pre>
</li>
</ul>
<h4 id="1-2-课堂案例-删除功能"><a href="#1-2-课堂案例-删除功能" class="headerlink" title="1.2 课堂案例-删除功能"></a>1.2 课堂案例-删除功能</h4><h3 id="6-JQ-创建元素"><a href="#6-JQ-创建元素" class="headerlink" title="6.JQ 创建元素"></a>6.JQ 创建元素</h3><h4 id="1-1-创建元素"><a href="#1-1-创建元素" class="headerlink" title="1.1 创建元素"></a>1.1 创建元素</h4><ul>
<li><p><code>$对象.html(标签)</code></p>
<pre><code class="js">语法:
$对象.html(&#39;html标签名&#39;);

例如:
$(&#39;div&#39;).html(&#39;&lt;h1&gt;我是标题标签&lt;/h1&gt;&#39;);

特点:
与原生js中 innerHTML的效果一样
</code></pre>
</li>
<li><p><code>$(html标签)</code></p>
<pre><code class="js">语法: $(&#39;html标签&#39;)

返回: JQ标签对象

例如: var span = $(&#39;&lt;span&gt;&lt;/span&gt;&#39;)
</code></pre>
</li>
</ul>
<h4 id="1-2-添加元素"><a href="#1-2-添加元素" class="headerlink" title="1.2 添加元素"></a>1.2 添加元素</h4><ul>
<li><p>父元素末尾添加元素</p>
<pre><code class="js">语法: $父元素.append(元素)

例如: var p = $(&#39;&lt;p&gt;我是创建的p&lt;/p&gt;&#39;)
$(&#39;div&#39;).append(p)
</code></pre>
</li>
<li><p>父元素开始位置添加元素</p>
<pre><code class="js">语法
$父元素.prepend(元素)

例如: var p = $(&#39;&lt;p&gt;我是创建的p&lt;/p&gt;&#39;)
$(&#39;div&#39;).prepend(p)
</code></pre>
</li>
</ul>
<p>​</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jq</tag>
        <tag>jq动画</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery-获取元素大小和位置-事件-表单</title>
    <url>/blog/2020/05/11/JQuery-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE-%E4%BA%8B%E4%BB%B6-%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="JQuery-获取元素大小和位置-事件-表单"><a href="#JQuery-获取元素大小和位置-事件-表单" class="headerlink" title="JQuery-获取元素大小和位置-事件-表单"></a>JQuery-获取元素大小和位置-事件-表单</h1><h3 id="1-JQ-方式获取元素大小和位置"><a href="#1-JQ-方式获取元素大小和位置" class="headerlink" title="1.JQ 方式获取元素大小和位置"></a>1.JQ 方式获取元素大小和位置</h3><h4 id="1-1-JQ-获取元素大小"><a href="#1-1-JQ-获取元素大小" class="headerlink" title="1.1 JQ 获取元素大小"></a>1.1 JQ 获取元素大小</h4><ul>
<li><p><strong>获取元素大小</strong></p>
<ul>
<li><p><code>$对象.width()</code></p>
<pre><code class="js">语法: $对象.width() //获取当前元素大小,只包含内容区域大小

代码演示: console.log($(&#39;div&#39;).width())
</code></pre>
</li>
<li><p><code>$对象.height()</code></p>
<pre><code class="js">语法: $对象.height() //获取当前元素高度,只包含内容区域高度

代码演示: console.log($(&#39;div&#39;).height())
</code></pre>
</li>
<li><p><code>$对象.innerWidth()</code></p>
<pre><code class="js">语法: $对象.innerWidth() //获取当前元素宽度 = 内容区域大小 + 内边距

代码演示: console.log($(&#39;div&#39;).innerWidth())
</code></pre>
</li>
<li><p><code>$对象.innerHeight()</code></p>
<pre><code class="js">语法: $对象.innerHeight() //获取当前元素高度 = 内容区域大小 + 内边距

代码演示: console.log($(&#39;div&#39;).innerHeight())
</code></pre>
</li>
<li><p><code>$对象.outerWidth()</code></p>
<pre><code class="js">语法:
$对象.outerWidth();   //获取当前元素宽度 = 内容区域大小 + 内边距 +边框

代码演示:
console.log($(&#39;div&#39;).outerWidth();
</code></pre>
</li>
</ul>
</li>
<li><p><strong>设置元素大小</strong></p>
<ul>
<li><p><code>$对象.width(值)</code> <code>$对象.height(值)</code></p>
<pre><code class="js">代码演示:
$(&#39;div&#39;).width(&#39;200&#39;).height(&#39;200&#39;);

//注意:
1. 在设置值的时候可以带单位px也可以不用带单位px
</code></pre>
</li>
<li><p><code>$对象.innerWidth(值)</code> <code>$对象.innerHeight(值)</code></p>
<pre><code class="js">代码演示:
$(&#39;div&#39;).innerWidth(&#39;200&#39;).innerHeight(&#39;200&#39;);

//注意:
1. 此时设置的值中已经包含内边距,内边距默认为0,如果在css中给当前元素设置内边距,则元素大内容区域大小会发生改变
</code></pre>
</li>
<li><p><code>$对象.outerWidth(值)</code> <code>$对象.outerHeight(值)</code></p>
<pre><code class="js">代码演示:
$(&#39;div&#39;).outerWidth(&#39;200&#39;, true).outerHeight(&#39;200&#39;, true);

//注意
1. 此时设置的值是包含外边距的,如果通过css给当前元素设置外边距,则元素内容区域大小会发生改变
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-2JQ-获取元素位置"><a href="#1-2JQ-获取元素位置" class="headerlink" title="1.2JQ 获取元素位置"></a>1.2JQ 获取元素位置</h4><ul>
<li><p><code>offset()</code></p>
<pre><code class="js">语法:
$(对象).offset();

//总结:
1. $对象.offset() 返回的是一个对象
2. $对象.offset() 返回对象中包含 left 属性 和 top属性
3. 获取当前元素的位置是相对整个页面
4. 类似于固定定位

//代码演示:
$(&#39;.one&#39;).offset().left
$(&#39;.one&#39;).offset().top
</code></pre>
</li>
<li><p><code>position()</code></p>
<pre><code class="js">语法:
$(对象).position();

//总结:
1. $对象.position() 返回的是一个对象
2. $对象.position() 返回对象中包含 left 属性和 top属性
3. 获取当前元素的位置,如果当前父元素没有定位,相对整个页面,如果父元素有定位,参照父元素
4. 类似于绝对定位

//代码演示:
$(&#39;.one&#39;).position().left
$(&#39;.one&#39;).position().top
</code></pre>
</li>
<li><p><code>scrollTop()</code></p>
<pre><code class="js">语法:
$(对象).scrollTop();
//总结:
1. 获取当前元素(内容)滚动出去的距离
2. 如果希望在程序中获取当前距离大小,需要在scroll事件中获取
//代码演示:
$(&#39;.box&#39;).scroll(function()&#123;
    console.log($(this).scrollTop());
&#125;);
</code></pre>
</li>
</ul>
<h4 id="1-3-课堂案例-返回顶部案例"><a href="#1-3-课堂案例-返回顶部案例" class="headerlink" title="1.3 课堂案例-返回顶部案例"></a>1.3 课堂案例-返回顶部案例</h4><h3 id="2-JQ-方式注册事件"><a href="#2-JQ-方式注册事件" class="headerlink" title="2.JQ 方式注册事件"></a>2.JQ 方式注册事件</h3><h4 id="1-1-通过常规方式注册事件"><a href="#1-1-通过常规方式注册事件" class="headerlink" title="1.1 通过常规方式注册事件"></a>1.1 通过常规方式注册事件</h4><pre><code class="js">事件源.事件类型(function()&#123;&#125;);

//代码演示:

$(&#39;.box&#39;).click(function()&#123;
    $(this).css(&#39;background&#39;,&#39;pink&#39;);
&#125;);
$(&#39;.box&#39;).mouseenter(function()&#123;
    $(this).css(&#39;background&#39;,&#39;blue&#39;);
&#125;);
$(&#39;.box&#39;).mouseleave(function()&#123;
    $(this).css(&#39;background&#39;, &#39;red&#39;)
&#125;);

特点:
1. 只能给事件源注册一个事件
2. 如果注册多个事件,重复设置,不符合JQ的特性(do more do less)
</code></pre>
<h4 id="1-2-通过-on-方式注册事件"><a href="#1-2-通过-on-方式注册事件" class="headerlink" title="1.2 通过 on 方式注册事件"></a>1.2 通过 on 方式注册事件</h4><pre><code class="js">事件源.on(&#39;事件类型&#39;, function () &#123;&#125;)

//代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, function () &#123;
  console.log(123)
&#125;)

事件源.on(&#123;
  事件类型: function () &#123;&#125;,
  事件类型: function () &#123;&#125;
&#125;)

//代码演示:
$(&#39;.box&#39;).on(&#123;
  click: function () &#123;
    $(this).css(&#39;background&#39;, &#39;blue&#39;)
  &#125;,
  mouseenter: function () &#123;
    $(this).css(&#39;background&#39;, &#39;pink&#39;)
  &#125;
&#125;)
</code></pre>
<h4 id="1-3-通过委托方式注册事件"><a href="#1-3-通过委托方式注册事件" class="headerlink" title="1.3 通过委托方式注册事件"></a>1.3 通过委托方式注册事件</h4><pre><code class="js">父事件源.on(&#39;事件类型&#39;, &#39;子选择器&#39;, function () &#123;&#125;)

// 代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, &#39;.one&#39;, function () &#123;
  console.log(123)
&#125;)
// 注意:
// 1. 如果页面中的元素是动态创建的,给元素注册事件,需要使用委托的方式
//代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, &#39;.one&#39;, function () &#123;
  console.log(123)
&#125;)
$(&#39;&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;&#39;).appendTo(&#39;.box&#39;)
</code></pre>
<h4 id="1-4-课堂案例-发布微博案例"><a href="#1-4-课堂案例-发布微博案例" class="headerlink" title="1.4 课堂案例-发布微博案例"></a>1.4 课堂案例-发布微博案例</h4><p>![1594695224614](D:&#x2F;前端_资料&#x2F;就业班&#x2F;JQuery&#x2F;JQuery 第三天&#x2F;03&#x2F;01-课堂笔记&#x2F;img&#x2F;1594695224614.png)</p>
<h4 id="1-5-解绑事件"><a href="#1-5-解绑事件" class="headerlink" title="1.5 解绑事件"></a>1.5 解绑事件</h4><ul>
<li><p><code>off()</code></p>
<pre><code class="js">$对象.off([事件名]);

//代码演示1:
$(&#39;.box&#39;).click(function()&#123;
    alert(123);
&#125;)
$(&#39;.box&#39;).off();

//代码演示2:
$(&#39;div&#39;).on(&#39;click&#39;, function()&#123;
    alert(123);
&#125;)
$(&#39;.box&#39;).off();

// 如果元素身上有很多事件如何解绑?
$(&#39;.box&#39;).on(&#123;
    click: function() &#123;
        alert(123);
    &#125;,
    mouseenter: function() &#123;
        alert(789);
    &#125;
&#125;)
$(&#39;.box&#39;).off();
或者:
$(&#39;.box&#39;).off(&#39;mouseenter&#39;);
// 总结
1. 如果off() 中没有设置任何参数,代表将所有的事件移除
2. 如果要移除对应的事件,在off方法中设置对应的方法名称即可
</code></pre>
</li>
<li><p><code>off()解绑委托事件</code></p>
<pre><code class="js">$父元素对象.off(&#39;事件类型&#39;, &#39;选择器&#39;)

// 代码演示:
$(&#39;.box&#39;).on(&#39;click&#39;, &#39;.one&#39;, function () &#123;
  console.log(123)
&#125;)
$(&#39;.box&#39;).off(&#39;click&#39;, &#39;.one&#39;)
</code></pre>
</li>
</ul>
<h3 id="3-表单"><a href="#3-表单" class="headerlink" title="3.表单"></a>3.表单</h3><h4 id="3-1-通过-jQuery-监听表单提交"><a href="#3-1-通过-jQuery-监听表单提交" class="headerlink" title="3.1 通过 jQuery 监听表单提交"></a>3.1 通过 jQuery 监听表单提交</h4><pre><code class="js">HTML 标签本身具有数据提交的能力，然而现实中更常见的是通过监听 DOM 事件获取表单的数据，然后通过 Ajax 将表单的数据提交至服务端。
&lt;form&gt;
  昵称: &lt;input type=&quot;text&quot; name=&quot;nickname&quot;&gt;
  &lt;br&gt;
  密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
  &lt;br&gt;
  &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;script src=&quot;your/path/jquery-版本号.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
 // 监听表单的 submit 事件
  $(&#39;form&#39;).submit(function (ev) &#123;
    // 表单提交的相关逻辑...

    // 阻止 HTML 表单的默认提交
    // ev.preventDefault();

    // ev.preventDefault() 在 jQuery 中可以
    // 被简写成 return false
    return false;
  &#125;)
&lt;/script&gt;
</code></pre>
<h4 id="3-2-表单序列化"><a href="#3-2-表单序列化" class="headerlink" title="3.2 表单序列化"></a>3.2 表单序列化</h4><pre><code class="js">HTML 标签默认提交表单时会自动根据表单项的 name 属性将用户在表单中填写的数据提交至服务端，然而采用监听 DOM 事件对表单提交时，需要开发者自行获取表单项中用户填写的数据，其用户如下代码所示：

&lt;form&gt;
  昵称: &lt;input type=&quot;text&quot; name=&quot;nickname&quot;&gt;
  &lt;br&gt;
  密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
  &lt;br&gt;
  &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;script src=&quot;your/path/jquery-版本号.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 监听表单的 submit 事件
  $(&#39;form&#39;).on(&#39;submit&#39;, function () &#123;

    // 通过 jQuery 对象的 serialize 方法，获取所有表单元素的数据
    $(this).serialize();

    // 阻止表单默认提交
    return false;
  &#125;)
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jq</tag>
        <tag>jq表单</tag>
        <tag>jq事件</tag>
      </tags>
  </entry>
  <entry>
    <title>git-操作命令</title>
    <url>/blog/2020/05/22/git-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="git-操作命令"><a href="#git-操作命令" class="headerlink" title="git-操作命令"></a>git-操作命令</h1><p><strong>git init</strong><br>本地初始化仓库<br><strong>git add .</strong><br>将项目提交到缓存区<br><strong>git commit -m “备注说明”</strong><br>将项目提交到本地仓库<br><strong>git branch “新分支名称”</strong><br><strong>git checkout master</strong><br>切换主分支<br><strong>git branch -d 分支名称</strong><br>删除分支(切换到主分支，并且合并完之后)<br><strong>git remote add origin SSH 地址</strong><br>关联远程（与远程建立联系）<br><strong>git push -u origin master</strong><br>执行远程同步<br>多次同步 git push<br><strong>git clone SSSH 地址</strong><br>克隆项目<br><strong>git pull origin master</strong><br>更新远程代码（下拉）<br><strong>git log &#x2F; git log –oneline</strong><br>查看本地有几次提交记录<br><strong>git resset –hard 序号</strong><br>回滚（查看之前提交过的存档文件）<br><strong>git branch</strong><br>查看本地所有分支<br><strong>git remote show origin</strong><br>查看远程仓储分支<br><strong>git status (-s)</strong><br>查看文件状态<br><strong>git checkout 新分支名</strong><br>切换新分支<br><strong>git merge 分支名</strong><br>合并分支</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery-基本操作</title>
    <url>/blog/2020/04/21/jQuery-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="jQuery-基本操作"><a href="#jQuery-基本操作" class="headerlink" title="jQuery-基本操作"></a>jQuery-基本操作</h1><h2 id="1、入口函数"><a href="#1、入口函数" class="headerlink" title="1、入口函数"></a>1、入口函数</h2><p>DOM 中如果在 HTML 结构之前写 JS 代码,需要设置加载事件,获取 HTML 元素</p>
<pre><code class="js">window.onload = function () &#123;
  var div = document.querySelector(&#39;div&#39;)
  console.log(div)
&#125;
</code></pre>
<p>JQ 如果在 HTML 结构之前写 js 代码,需要设置加载事件(入口函数)</p>
<pre><code class="js">$(function () &#123;
  var div = document.querySelector(&#39;div&#39;)
  console.log(div)
&#125;)
</code></pre>
<h2 id="2、-符号介绍"><a href="#2、-符号介绍" class="headerlink" title="2、$符号介绍"></a>2、$符号介绍</h2><p>1.就是 JQuer 的一个别名</p>
<p>$(function(){})</p>
<p>2.可以如下写法:</p>
<pre><code class="js">jQuery(function () &#123;&#125;)
</code></pre>
<p>3.是 JQ 中的顶级对象</p>
<pre><code class="js">$(function () &#123;
  console.dir($)
&#125;)
</code></pre>
<h2 id="3、DOM-对象和-jQuery-对象转化"><a href="#3、DOM-对象和-jQuery-对象转化" class="headerlink" title="3、DOM 对象和 jQuery 对象转化"></a>3、DOM 对象和 jQuery 对象转化</h2><p><strong>DOM 对象:</strong></p>
<p>​ 通过 document 方式获取到的元素都叫 DOM 对象</p>
<p><strong>jQuery 对象</strong></p>
<p>​ 通过 $ 方式获取到的元素都叫 JQ 对象</p>
<p><strong>将 JQ 对象转为 DOM 对象方式:</strong></p>
<ul>
<li>JQ 对象[索引]</li>
<li>JQ 对象.get(索引)</li>
<li>将 DOM 对象转化为 JQ 对象:</li>
<li>$(dom 对象)</li>
</ul>
<h2 id="4、获取元素"><a href="#4、获取元素" class="headerlink" title="4、获取元素"></a>4、获取元素</h2><p>1.<strong>语法:</strong> $(‘选择器’);</p>
<p>2.选择器可以是 CSS 中的选择器</p>
<p>3.选择器可以是 jQ 中提供的: :first :last :odd (获取索引是奇数的元素) :even (获取索引是偶数的元素) :eq(index)</p>
<p>4.通过方法找对应的元素</p>
<p>5.parent() 或者 parents(选择器)</p>
<p>6.children([选择器])</p>
<p>7.find(选择器)</p>
<p>8.siblings(选择器)</p>
<p>9.nextAll([选择器])</p>
<p>10.prevAll([选择器])</p>
<p>11.eq(值)</p>
<h2 id="5、注册事件"><a href="#5、注册事件" class="headerlink" title="5、注册事件"></a>5、注册事件</h2><p><strong>语法:</strong></p>
<pre><code class="js">JQ对象.事件名称(function () &#123;
  处理程序
&#125;)
</code></pre>
<p><strong>事件:</strong></p>
<ul>
<li>点击事件: click</li>
<li>鼠标进入事件: mouseenter</li>
<li>鼠标离开事件: mouseleave</li>
</ul>
<h2 id="6、设置样式"><a href="#6、设置样式" class="headerlink" title="6、设置样式"></a>6、设置样式</h2><p>$(‘元素’).css(‘属性’, 值); 设置单个属性样式</p>
<p>$(‘元素’).css({‘属性’: ‘值’,’属性’: ‘值’}) 设置多个属性样式</p>
<p>$(‘元素’).addClass(‘类名 类名’);</p>
<p>$(‘元素’).removeClass(‘类名’);</p>
<p>$(‘元素’).toggleClass(‘类名’);</p>
]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jq</tag>
        <tag>$</tag>
      </tags>
  </entry>
  <entry>
    <title>node-操作命令</title>
    <url>/blog/2020/05/30/node-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="node-操作命令"><a href="#node-操作命令" class="headerlink" title="node-操作命令"></a>node-操作命令</h1><img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648561357(1).4q52g88dmns0.webp">
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/blog/2020/02/27/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h2><p><strong>全局作用域:</strong> 在 javaScript 中,函数外部的所有作用范围都称为全局作用域</p>
<p><strong>全局变量:</strong> 在全局作用域中定义的变量,叫全局变量</p>
<p><strong>全局变量特点:</strong> 在全局作用域中的全局变量可以在任何地方被访问到</p>
<pre><code class="js">// 例如：
&lt;script&gt;

  变量a是一个全局变量

  let a = 123;

  函数fn是一个全局变量

  function fn() &#123;&#125;

  数组ary是一个全局变量

  let ary = []
&lt;script&gt;
</code></pre>
<h2 id="2、局部作用域"><a href="#2、局部作用域" class="headerlink" title="2、局部作用域"></a>2、局部作用域</h2><p><strong>局部作用域:</strong> 在函数内部形成的作用范围称为局部作用域或者函数作用域</p>
<p><strong>局部变量:</strong> 在局部作用域中定义的变量称为局部变量</p>
<p><strong>局部变量特点:</strong> 局部变量只能在当前作用域中被访问</p>
<p><strong>局部作用域和全局作用域之间的关系</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648557530(1).3nhkowhdmpa0.webp">

<h2 id="3、块级作用域"><a href="#3、块级作用域" class="headerlink" title="3、块级作用域"></a>3、块级作用域</h2><p><strong>块级作用域:</strong> 在 javaScript 中,通过 let 关键字&#x2F;const 关键字 定义变量且位于{}中,就会形成块级作用域</p>
<p><strong>块级作用域特点:</strong> 变量只能在当前块级作用域中被访问</p>
<pre><code class="js">&lt;script&gt;
      &#123;let a = 123; console.log(a)&#125;

      if(true) &#123;
          let userName = &#39;dhl&#39;;
      &#125;
&lt;script&gt;
</code></pre>
<h2 id="4、作用域链"><a href="#4、作用域链" class="headerlink" title="4、作用域链"></a>4、作用域链</h2><p><strong>作用域链:</strong> 在 javaScript 中,多个作用域嵌套形成的一个链状结构</p>
<p><strong>作用域链作用:</strong> 通过作用域链进行变量查找</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648557734(1).44hmkm9i3ry0.webp">

<h2 id="5、const-关键字"><a href="#5、const-关键字" class="headerlink" title="5、const 关键字"></a>5、const 关键字</h2><p><strong>const 关键字:</strong> 在程序中定义常量的关键字</p>
<p><strong>const 关键字注意事项:</strong></p>
<ul>
<li>const 定义常量时候必须设置初始值</li>
<li>const 定义常量后,常量的值不能被修改</li>
<li>const 定义常量名不能重复</li>
<li>const 可以产生块级作用域</li>
</ul>
<pre><code class="js">&lt;script&gt;
    const  a = 123;
    const  b = 456;
   &#123;const c = 678&#125;;
&lt;script&gt;
</code></pre>
<h2 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h2><p><strong>闭包:</strong> 闭包就是能够读取其他函数内部变量的函数(简单理解的就是：一个函数定义到了另一个函数的内部，并且还可以使用这个函数内部 定义的变量)</p>
<p><strong>闭包作用:</strong> 可以延长变量的使用生命周期</p>
<p><strong>闭包总结:</strong></p>
<ul>
<li>闭包本质上就是一个函数</li>
<li>闭包函数就是在一个函数中访问另外一个函数中的变量</li>
<li>闭包函数的作用延长了变量的使用生命周期</li>
</ul>
<h2 id="7、变量提升"><a href="#7、变量提升" class="headerlink" title="7、变量提升"></a>7、变量提升</h2><p><strong>变量提升:</strong> 使用 var 关键字定义变量的时候,程序会先将变量的声明提升到当前作用域的开始,不包括赋值</p>
<p><strong>函数提升:</strong> 定义函数的时候,程序会将函数的声明提升到当前作用域的开始位置,不包括函数的调用</p>
<p><strong>let 不存在变量提升</strong></p>
<p><strong>注意:</strong></p>
<p>当程序中同时出现变量和函数的时候,先提升函数,再提升变量(前提是通过 var 定义的变量才可以)</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>全局作用域</tag>
        <tag>局部作用域</tag>
        <tag>块级作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/blog/2020/03/15/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1、默认值参数"><a href="#1、默认值参数" class="headerlink" title="1、默认值参数"></a>1、默认值参数</h2><ol>
<li><p>函数中的形参可以设置默认值,函数中的形参本质就是一个变量,可以直接默认赋值</p>
</li>
<li><p>函数中的形参如果设置了默认值,在没有设置实参的情况下,就是默认值,否则就是实参的值</p>
<pre><code class="js">&lt;script&gt;
function fn(a,b) &#123;
    console.log(a, b);
&#125;
fn()
function fn2(a = 1, b = 2) &#123;
    console.log(a, b);
&#125;
fn2()
&lt;script&gt;
</code></pre>
</li>
</ol>
<h2 id="2、动态参数"><a href="#2、动态参数" class="headerlink" title="2、动态参数"></a>2、动态参数</h2><p>​ 1.<strong>arguments</strong>是函数中用来保存实参信息的一个数组</p>
<p>​ 2.当函数中实参个数不确定的时候,可以通过 arguments 获取实参信息</p>
<pre><code class="js">&lt;script&gt;
    function fn() &#123;
        console.log(arguments);
    &#125;
   fn(1, 2, 3, 4);
&lt;script&gt;
</code></pre>
<h2 id="3、剩余参数"><a href="#3、剩余参数" class="headerlink" title="3、剩余参数"></a>3、剩余参数</h2><ol>
<li><p>语法: **…**自定义参数名</p>
</li>
<li><p>作用: 用来获取多余的实参值 (类似于 arguments)</p>
</li>
<li><p>注意事项:</p>
<p>3.1 剩余参数必须写到函数形参的最后</p>
<p>3.2 剩余参数的名字是自定义的</p>
<p>3.3 剩余参数保存的值是以数组形式保存的</p>
<pre><code class="js">&lt;script&gt;
function fn(a, b, ...c) &#123;
   console.log(a, b, c);
&#125;
 fn(1,2,3);
 fn(1,2,3,4,5);
&lt;script&gt;
</code></pre>
</li>
</ol>
<h2 id="4、箭头函数"><a href="#4、箭头函数" class="headerlink" title="4、箭头函数"></a>4、箭头函数</h2><p>1.<strong>箭头函数语法</strong>: () &#x3D;&gt; {} 等价于 function() {}</p>
<p>2.<strong>函数的组成</strong></p>
<p>​ 2.1 函数名</p>
<p>​ 2.2 参数</p>
<p>​ 2.3 函数体</p>
<p>​ 2.4 返回值</p>
<p><strong>3.箭头函数注意事项</strong>:</p>
<p>​ 3.1 如果只有且只有一个参数,可以省略()</p>
<p>​ 3.2 如果函数体只有一行代码,可以省略{}</p>
<p>​ 3.3 如果函数只有一行代码,返回值 return 可以省略</p>
<p>​ 3.4 箭头函数中不能使用 arguments,只能使用剩余参数</p>
<p>​ 3.5 箭头函数中没有自己的 this,this 是父级作用域中的<strong>this</strong></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值 | 内置对象</title>
    <url>/blog/2020/03/26/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="解构赋值-内置对象"><a href="#解构赋值-内置对象" class="headerlink" title="解构赋值 | 内置对象"></a>解构赋值 | 内置对象</h1><h2 id="一、解构赋值"><a href="#一、解构赋值" class="headerlink" title="一、解构赋值"></a>一、解构赋值</h2><h3 id="1-数组解构"><a href="#1-数组解构" class="headerlink" title="1.数组解构"></a>1.数组解构</h3><p><strong>解构:</strong> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
<p><strong>数组解构:</strong> 将数组中的值一一对应的方式取出赋值给变量</p>
<p><strong>数组解构本质:</strong> 将数组中的值获取到赋值给变量</p>
<p><strong>数组解构语法:</strong> let [变量 1, 变量 2, 变量 3] &#x3D; 数组;</p>
<p><strong>数组解构特点:</strong></p>
<ol>
<li><p>数组解构是将数组中的值一一对应取出分别赋值给变量</p>
</li>
<li><p>如果被赋值的变量个数大于数组中的值,则多余的变量值为 undefined</p>
</li>
<li><p>在数组解构中可以为变量设置默认值</p>
<pre><code class="js">&lt;script&gt;
   let [name1, name2, name3] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
   console.log(name1, name2, name3);
&lt;script&gt;
</code></pre>
</li>
</ol>
<h3 id="2-对象解构"><a href="#2-对象解构" class="headerlink" title="2.对象解构"></a>2.对象解构</h3><p><strong>对象解构:</strong> 将对象中的属性或方法取出赋值给变量</p>
<p><strong>语法 1:</strong> let {属性名:变量名 1, 属性名:变量名 2 …} &#x3D; 对象</p>
<p><strong>语法 2:</strong> let {属性名,属性名} &#x3D; 对象</p>
<p><strong>对象解构总结</strong></p>
<ol>
<li><p>对象解构中,属性名和对象中的属性必须保持一致,否则值为 undefined</p>
</li>
<li><p>对象解构中,如果属性名和变量名一样,则可以省略变量名,但属性名必须与对象中的属性一样</p>
<pre><code class="js">&lt;script&gt;
   let persone = &#123;uname: &#39;zs&#39;, uage: 23&#125;
   let &#123;uname: n1, uage: n2&#125; = persone;
   let &#123;uname, uage&#125; = persone;
&lt;script&gt;
</code></pre>
</li>
</ol>
<h2 id="二、内置对象-js-内部提供的对象"><a href="#二、内置对象-js-内部提供的对象" class="headerlink" title="二、内置对象 (js 内部提供的对象)"></a>二、内置对象 (js 内部提供的对象)</h2><h3 id="1-数组对象"><a href="#1-数组对象" class="headerlink" title="1.数组对象"></a>1.数组对象</h3><ol>
<li><p>数组内置对象: Array()</p>
</li>
<li><p>Array 中的实例方法</p>
<p>- reverse() 翻转数组</p>
<p>- indexOf() 检索数组中的值</p>
<p>- lastIndexOf() 检索数组中的值</p>
<p>- splice() 删除或其他数组中的值</p>
<p>- concat()合并两个数组的值</p>
<p>- join() 将数组中的值拼接为字符串</p>
<p>- forEach(function(item, index){}) 遍历数组</p>
<p>- filter(function(item, index){}) 过滤筛选数组,返回一个新数组</p>
<p>- map(function(item, index){})迭代原数组,生成新数组</p>
</li>
</ol>
<h3 id="2-字符串对象"><a href="#2-字符串对象" class="headerlink" title="2.字符串对象"></a>2.字符串对象</h3><p>1.Array 内置对象中的静态方法</p>
<p>2.Array.from(对象) 将伪数组转换为数组</p>
<h3 id="3-包装类型"><a href="#3-包装类型" class="headerlink" title="3.包装类型"></a>3.包装类型</h3><p><strong>String 构造函数</strong></p>
<p>- 属性 : length 属性</p>
<p>- 方法: 拼接字符串 concat()</p>
<p>- 方法: split()分割字符串 toUpperCase()转大写 toLowerCase()转小写</p>
<p>- substring(indexStart, indexEnd) - substr(start[,length])</p>
<p>- 方法: startsWith() 检测是否以某个字母开始 endsWith()检测是否以某个字母结束</p>
<p>- 方法: replace(‘被替换的字符’, ‘替换后的字符’)替换 indexOf()</p>
<p>- 方法: padStart(位数, ‘值’), 是否够几位数,如果不够在前面添加对应的内容</p>
<p>- 方法: padEnd(‘位数’, ‘值’),是否够几位数,如果不够在后面添加对应的内容</p>
<p><strong>Number 构造函数</strong></p>
<p>- 方法: toFixed()保留几位小数</p>
<p><strong>Boolean 构造函数</strong></p>
<p><strong>包装类型:</strong> 一个简单类型可以通过 js 内部的构造函数包装成一个对象</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>解构赋值，内置对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/blog/2020/04/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1、封装"><a href="#1、封装" class="headerlink" title="1、封装"></a>1、封装</h2><p><strong>封装:</strong> 将一段功能代码封装成一个函数</p>
<p>封装一个构造函数创建对象</p>
<pre><code class="js">function People(uname) &#123;
  this.uname = uname

  this.eat = function () &#123;&#125;
&#125;
</code></pre>
<p>通过构造函数封装后,创建多个对象,对象调用同一个方法,在内存中执行的并不是同一个方法</p>
<h2 id="2、原型对象"><a href="#2、原型对象" class="headerlink" title="2、原型对象"></a>2、原型对象</h2><p><strong>prototype:</strong> 叫原型,是每一个构造函数身上的一个属性,该属性是以对象的形式存在的(原型对象)</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648559112(1).5zhb0ex1q7k0.webp">

<p><strong>作用:</strong> 通过原型对象设置构造函数中功能的方法</p>
<p><strong>语法:</strong> 构造函数.prototype.方法名 &#x3D; function(){}</p>
<p><strong>构造函数与 prototype 之间的关系:</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648559174(1).3l4p5n5gemm0.webp">

<h2 id="3、对象原型"><a href="#3、对象原型" class="headerlink" title="3、对象原型"></a>3、对象原型</h2><p><strong>什么是 proto</strong> : 每一个实例对象身上的一个属性,该属性是以对象的形式存在的(对象原型)</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/1648559283(1).30dukq6xfpa0.webp">

<p>*<strong>*proto</strong>作用:** <strong>proto</strong>指向了原型对象 prototype,可以让实例对象访问构造函数中的公共方法</p>
<p><strong>prototype 与 proto 之间的关系</strong></p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片1.2wfynnkwmyw0.webp">

<h2 id="4、原型链"><a href="#4、原型链" class="headerlink" title="4、原型链"></a>4、原型链</h2><p><strong>原型链:</strong> 多个原型对象之间形成的一个链状结构</p>
<p><strong>作用:</strong> 通过原型链可以确定方法的执行顺序</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片2.6v5blgn2wh40.webp">

<h2 id="5、继承"><a href="#5、继承" class="headerlink" title="5、继承"></a>5、继承</h2><p><strong>什么是继承:</strong> 子类中使用父类中的属性或方法</p>
<p><strong>继承的作用:</strong> 继承可以减少重复代码</p>
<p><strong>继承分类:</strong> 属性继承 + 方法继承</p>
<p><strong>属性继承语法:</strong> 构造函数.call(对象,参数 1,参数 2…)</p>
<img src="https://cdn.jsdelivr.net/gh/3-ygd/image-hosting@master/图片3.58c1tmd10gg0.webp">
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型对象</tag>
      </tags>
  </entry>
</search>
